var rM = require('refs');
var fs = require('fs');
var utils = require('utils');
var commit = require('commit');
var tree = require('tree');
var blob = require('blob');
var iM = require('indexFile');



/* NIE WYROBILEM SIE Z PELNYM SKONCZENIEM I PRZETESTESOWANIEM, MACHNE JPP, BO MI TO CIAZY I SKONZCE TO*/


// NOT TESTED, DON NOT USE IT YET
var gitCheckout = function(branchName, repoPath, callback) {
	var indexManager = new iM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
		var refsManager = new rM.Refs(repoPath, function(err) {
			if (err) {
				callback(err);
				return;
			}
			getCommitSHA_1(repoPath, branchName, function(err, commitSHA_1){
				if (err) {
					if (err != ('error: pathspec \'' + branchName + '\' did not match any file(s) known to git')) {
						callback(err);
						return;
					}
					getHeadSha1(repoPath.slice(0, repoPath.length - 4), function(err, headSHA_1) {
						if (err) {
							callback(err);
							return;
						}
						commit.readFileToCommit(headSHA_1, repoPath, function(err, commitObject) {
							var treeSHA_1 = commitObject.objectId;
							removeFiles(treeSHA_1, repoPath, repoPath + '/../', indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								fs.writeFile(repoPath + '/HEAD', 'ref: refs/heads/' + branchName, function (err) {
									if (err) {
										callback(err);
										return;
									}
									refsManager.getBranchSHA_1UsingName(branchName, function(err, branchSHA_1) {
										commit.readFileToCommit(branchSHA_1, repoPath, function(err, commitObject) {
											var treeSHA_1 = commitObject.objectId;
											console.log('?????' + treeSHA_1);
											restoreFiles(treeSHA_1, repoPath, repoPath + '/../', indexManager, function(err) {
												if (err) {
													callback(err);
												}
											});
										});
									});
								});
							});
						});
					});
				} else {
					getHeadSha1(repoPath.slice(0, repoPath.length - 4), function(err, headSHA_1) {
						if (err) {
							callback(err);
							return;
						}
						commit.readFileToCommit(headSHA_1, repoPath, function(err, commitObject) {
							var treeSHA_1 = commitObject.objectId;
							removeFiles(treeSHA_1, repoPath, repoPath + '/../', indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								fs.writeFile(repoPath + '/HEAD', commitSHA_1, function (err) {
									if (err) {
										callback(err);
										return;
									}
									commit.readFileToCommit(commitSHA_1, repoPath, function(err, commitObject) {
										var treeSHA_1 = commitObject.objectId;
										console.log('?????' + treeSHA_1);
										restoreFiles(treeSHA_1, repoPath, repoPath + '/../', indexManager, function(err) {
											if (err) {
												callback(err);
											}
										});
									});
								});
							});
						});
					});
				}

				////console.log(commitSHA_1);
			});
		});
	});
}
 
// FROM MARCIN -> TO DELETE FROM HERE
var getHeadSha1 = function(gitpath, callback) {
    correctGitPath(gitpath);
    try {
        fs.readFile(gitpath + '.git/HEAD', function (err, data) {
            if (err) throw err;
            var datastr = data.toString();
            var refs = 'ref: ';
            var headSha1 = datastr;
            if(datastr[datastr.length - 1] === '\n') 
                datastr = datastr.substr(0, datastr.length - 1);
            if (datastr.substr(0,5) === refs) {
                fs.readFile(gitpath+'.git/' + datastr.substr(5, datastr.length - 5), function(err, data) {
                    if (err) {
                        //there's no commit yet
                        callback(null, undefined);
                    } else {
                        headSha1 = data.toString();
                        //we read '/n'
                        if(headSha1[headSha1.length-1] === '\n')
                            headSha1 = headSha1.substr(0, headSha1.length - 1);
                        //domorework
                        callback(err, headSha1);
                    }
                });
            } else {
                if(headSha1[headSha1.length-1] === '\n')
                            headSha1 = headSha1.substr(0, headSha1.length - 1);
                callback(err, headSha1);
            }
        });
    } catch(err) {
        callback(err);   
    }
}

// FROM MERCIN -> TO DELETE FROM HERE
var correctGitPath = function(gitpath) {
    if(gitpath.length > 0 && gitpath[gitpath.length - 1] !== '/')
        gitpath = gitpath + '/';
    if(gitpath === '') gitpath = '/';
    return gitpath;
}

// NOT TESTED, DON NOT USE IT YET
var isFolderNameInObjects = function(folderName, objects, callback) {
	for (var index in objects) {
		if (folderName == objects[index]) {
			callback(true);
			return;
		}
	}

	callback(false);
	return;
}

// NOT TESTED, DON NOT USE IT YET
var howManyObjectsMatchToShortSHA_1 = function(objects, SHA_1, callback) {
	var objectsNumber = 0;
	var SHA_1Last = SHA_1.slice(2);
	var SHA_1LastLength = SHA_1Last.length;
	for (var index in objects) {
		if (SHA_1Last == objects[index].slice(0, SHA_1LastLength)) {
			++objectsNumber;
		}
	}

	callback(objectsNumber);
	return;
}

// NOT TESTED, DON NOT USE IT YET
var getLongSHA_1UsingShortSHA_1 = function(objects, shortSHA_1, callback) {
	var shortSHA_1Last = shortSHA_1.slice(2);
	var objectsNumber = 0;
	var longSHA_1;
	for (var index in objects) {
		if (shortSHA_1Last == objects[index].slice(0, shortSHA_1Last.length)) {
			longSHA_1 = shortSHA_1.slice(0, 2) + objects[index];
			++objectsNumber;
		}
	}

	switch (objectsNumber) {
		case 0: 	callback('fatal: Not a valid object name ' + shortSHA_1, '');
					return;
		case 1: 	callback('', longSHA_1);
					return;
		default:	callback('error: short SHA1 ' + shortSHA_1 + ' is ambiguous', '');
					return;
	}
}

// NOT TESTED, DON NOT USE IT YET
var getCommitSHA_1 = function(repoPath, commit, callback) {
	fs.readdir(repoPath + '/objects', function(err, objects) {
		if (err) {
			callback(err, '');
			return;
		}
		var folderName = commit.slice(0, 2);
		isFolderNameInObjects(folderName, objects, function(isFolder) {
			if (!isFolder) {
				callback('error: pathspec \'' + commit + '\' did not match any file(s) known to git', '');
				return;
			}
			fs.readdir(repoPath + '/objects/' + folderName, function(err, objects) {
				howManyObjectsMatchToShortSHA_1(objects, commit, function(objectsNumber) {
					switch (objectsNumber) {
						case 0: 	callback('fatal: Not a valid object name ' + commit, '');
									return;
						case 1: 	getLongSHA_1UsingShortSHA_1(objects, commit, function(err, SHA_1) {
										if (err) {
											callback(err, '');
											return;
										}
										callback('', SHA_1);
										return;
									});
									return;
						default: 	callback('error: short SHA1 ' + commit + ' is ambiguous', '');
									return;
					}
				});
				
			});
		});
	});
}

// NOT TESTED, DON NOT USE IT YET
var makeRestoreForEveryObjectOnOneLevel = function(objects, keys, index, repoPath, path, indexManager, callback) {
	if (index == keys.length) {
		callback('');
		return;
	}
	var object = objects[keys[index]];
	var objectId = keys[index];
	////console.log(objectId);
	if (object.type == 'tree') {
		////console.log(path);
		fs.exists(path + objectId, function(exists) {
			if (exists) {
				restoreFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						callback('');
						return;
					});
				});
			} else {
				fs.mkdir(path + objectId, 0777, function(err) {
					if (err) {
						callback(err);
						return;
					}
					restoreFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					});
				});
			}
		});
		/*if (!fs.existsSync(path + objectId)) {
			var err = fs.mkdirSync(path + objectId, 0777);
			if (err) {
				callback(err);
				return;
			}
		}
		restoreFiles(object.sha1, repoPath, path + objectId + '/', function(err) {
			if (err) {
				callback(err);
				return;
			}
			makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
		});*/
	} else if (object.type == 'blob') {
		////console.log(path);
		blob.saveBlobAsFile(object.sha1, repoPath, path + objectId, function(err) {
			if (err) {
				callback(err);
				return;
			}
			indexManager.addObject(path + objectId, function(err) {
				if (err) {
					callback(err);
					return;
				}
				makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					callback('');
					return;
				});
			});
		});
	}		
}

// NOT TESTED, DON NOT USE IT YET
var restoreFiles = function(treeSHA_1, repoPath, path, indexManager, callback) {
//	//console.log('*****');
	utils.readObject(treeSHA_1, repoPath, function(err, treeObject) {
		if (err) {
	//		//console.log('1111111111');
			callback(err);
			return;
			////console.log('EaRR');
		}
		//console.log(treeObject.toString());
		tree.objectToTree(treeObject, function(err, treeDict) {

			if (err) {
			//	//console.log('2222222222');
				callback(err)
				return;
				////console.log('ERR');
			}
		//	//console.log(treeDict);
			/*for (var objectId in treeDict) {
				if (treeDict[objectId].type == 'tree') {
					//console.log(path);
					if (!fs.existsSync(path + objectId)) {
						var err = fs.mkdirSync(path + objectId, 0777);
						if (err) {
							callback(err);
							return;
						}
					}
					restoreFiles(treeDict[objectId].sha1, repoPath, path + objectId + '/', function(err) {
						if (err) {
							callback(err);
							return;
						}
					});
				} else if (treeDict[objectId].type == 'blob') {
					//console.log(path);
					blob.saveBlobAsFile(treeDict[objectId].sha1, repoPath, path + objectId, function(err) {
						if (err) {
							callback(err);
							return;
						}
					});
				}
				
			}*/
			var keys = new Array();
			for (var key in treeDict) {
				keys.push(key);
			}
			////console.log('????');
			makeRestoreForEveryObjectOnOneLevel(treeDict, keys, 0, repoPath, path, indexManager, function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
			
		});
		
	});

}

// NOT TESTED, DON NOT USE IT YET
var makeRemoveForEveryObjectOnOneLevel = function(objects, keys, index, repoPath, path, indexManager, callback) {
	if (index == keys.length) {
		callback('');
		return;
	}
	var object = objects[keys[index]];
	var objectId = keys[index];
	////console.log(objectId);
	if (object.type == 'tree') {
	//	//console.log(path);
		console.log('Usuwam ' + path + objectId);
		removeFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
			if (err) {
				callback(err);
				return;
			}
			fs.exists(path + objectId, function(exists) {
				if (exists) {
					fs.readdir(path + objectId, function(err, files) {
						if (err) {
							callback(err);
							return;
						}
						if (files.length == 0) {
							fs.rmdir(path + objectId, function(err) {
								if (err) {
									callback(err);
									return;
								}
								makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
									if (err) {
										callback(err);
										return;
									}
									callback('');
									return;
								});
							});
						} else {
							makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								callback('');
								return;
							});
						}
					});
				} else {
					makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						callback('');
						return;
					});
				}
			});
		});
	} else if (object.type == 'blob') {
		//console.log(path);
		console.log('Usuwam ' + path + objectId);
		fs.exists(path + objectId, function(exists) {
			if (exists) {
				indexManager.removeObject(path + objectId, function(err) {
					fs.unlink(path + objectId, function(err) {
						if (err) {
							callback(err);
							return;
						}
						makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					});
				});	
			} else {
				makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					callback('');
					return;
				});
			}
		});
	}		
}

// NOT TESTED, DON NOT USE IT YET
var removeFiles = function(treeSHA_1, repoPath, path, indexManager, callback) {
//	//console.log('------------------');
	utils.readObject(treeSHA_1, repoPath, function(err, treeObject) {
		if (err) {
			callback('1' + err);
			return;
		}
		//console.log(treeObject.toString());
		tree.objectToTree(treeObject, function(err, treeDict) {
			
			if (err) {
				callback('2' + err);
				return;
			}
		//	//console.log(treeDict);
			var keys = new Array();
			for (var key in treeDict) {
				keys.push(key);
			}
			//console.log('????' + path);
			makeRemoveForEveryObjectOnOneLevel(treeDict, keys, 0, repoPath, path, indexManager, function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
			/*for (var objectId in treeDict) {
				if (treeDict[objectId].type == 'tree') {
					removeFiles(treeDict[objectId].sha1, repoPath, path + objectId + '/', function(err) {
						if (err) {
							callback(err);
							return;
						}
						fs.readdir(path + objectId, function(err, files) {
							if (err) {
								callback(err);
								return;
							}
							if (files.length == 0) {
								fs.rmdir(path + objectId, function(err) {
									callback(err);
									return;
								});
							}
						});
					});

				} else if (treeDict[objectId].type == 'blob') {
					fs.unlink(path + objectId)	
				}
			};*/
		});
	});
}

exports.gitCheckout = gitCheckout
