/**
 * Produce buffer from given tree dictionary
 * @param treeEntries
 * dictionary of the following format:
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 * @return buffer which is binary representation of tree git object
 */
var treeGetBuffer = function(treeEntries) {
    var bufferResult = new Buffer(0);
    for (var filename in treeEntries) {
        if(treeEntries.hasOwnProperty(filename)) {
            var sha1 = treeEntries[filename]['sha1'];
            var sha1Buff = convertHexToDigest(sha1);
            var treeEntry = treeEntries[filename];
            var entryStr = treeEntry['mode'] + ' ' + filename;
            entryStr = entryStr + '\0';
            entryBuff = new Buffer(entryStr);
            //console.log(sha1Buff.length);
            bufferResult = Buffer.concat([bufferResult, entryBuff, sha1Buff]);
        }
    }
    //add prefix to buff?
    var prefixStr = 'tree ' + bufferResult.length.toString() + '\0';
    var prefixBuf = new Buffer(prefixStr);
    bufferResult = Buffer.concat([prefixBuf, bufferResult])
    return bufferResult;
}

/**
 * Add entry to tree dictionary
 * @param treeEntries
 * dictionary of the following format:
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 * @param treeEntry {'sha1' : sha1, 'mode' : mode, 'type' : type}
 * @param filename filename associated with treeEntry
 */
var treeAddEntry = function(treeEntries, treeEntry, filename) {
    treeEntries[filename] = treeEntry;
}

/**
 * Delete entry with given sha1 from tree dictionary
 * @param treeEntries
 * dictionary of the following format:
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 * @param filename filename associated with treeEntry
 */
var treeDeleteEntry = function(treeEntries, filename) {
    delete treeEntries[filename];
}

/**
 * Convert buffer containing 20 byte sha1 to 40 byte hex representation
 * @param buffer 20byte sha1
 * @return string hex sha1 representation
 */
var convertDigestToHex = function(buffer) {
    var dict = {10: 'a', 11 : 'b', 12 : 'c' , 13 : 'd', 14 : 'e', 15 : 'f'};
    var res = '';
    for(var i = 0; i <= 9; ++i) dict[i] = i.toString();
    for(var i = 0 ; i < buffer.length; ++i) {
        res = res + (dict[Math.floor(buffer[i]/16)]);
        res = res + (dict[buffer[i] % 16]);
    }
    return res;
}

/**
 * Convert sha1 40 byte hex string to 20 byte sha1 buffer
 * @param string hex sha1 representation
 * @return buffer 20byte sha1
 */
var convertHexToDigest = function(sha1) {
    var dict = {10: 'a', 11 : 'b', 12 : 'c' , 13 : 'd', 14 : 'e', 15 : 'f'};
    for(var i = 0; i <= 9; ++i) dict[i] = i.toString();
    var dictRev = {}
    for (var v in dict)
        if(dict.hasOwnProperty(v))
            dictRev[dict[v]] = v;
    var resBuf = new Buffer(20);
    for(var i = 0; i < 20; ++i) {
        var value1 = parseInt(dictRev[sha1[2*i]]*16);
        var value2 = parseInt(dictRev[sha1[2*i+1]]);
        resBuf[i] = value1 + value2;
    }
    return resBuf;
}

/**
 * Closure method used as helper for parseTree
 * @return function(buffer)
 * returned function parses buffer representing git tree entry and
 * returns [OK, res, filename] where
 * OK = true iff buffer represents correct tree entry
 * res dictionary {'sha1' : sha1, 'mode' : mode, 'type' : type}
 * filename is filename of git tree entry
 */
var _parseTreeEntry = function() {
    var modes = ['100644', '40000', '040000', '100000', '120000', '160000'];
    var types = {100644 : 'blob', 40000 : 'tree', 100755 : 'executable',
                120000 : 'symlink', 160000 : 'gitlink'};
    return function(buffer) {
        var i = 0;
        var space = ' '.charCodeAt(0);
        var mode;
        var OK = false;
        var res = {};
        var nullIndex = 0;
        var fileNameIndex = 0;
        var filename = '';
        while(i < buffer.length && buffer[i] !== space) ++i;
        fileNameIndex = i + 1;
        mode = buffer.slice(0, i).toString();
        for (var j = 0; j < modes.length; ++j) {
            if(mode === modes[j]) {
                OK = true;
                res['mode'] = parseInt(modes[j]);
                res['type'] = types[res['mode']];
                break;
            }
        }
        while (i < buffer.length && buffer[i] !== 0) ++i;
        nullIndex = i;
        OK = OK && i + 21 === buffer.length;
        if(OK) {
            filename = buffer.slice(fileNameIndex, nullIndex).toString();
            res['sha1'] = convertDigestToHex(buffer.slice(nullIndex + 1, buffer.length));
        }
        return [OK, res, filename];
    }
}


/**
 * Produce tree dictionary from given buffer if buffer represents correct
 * git tree object
 * throws exception if buffer doesn't represent correct tree
 * @param buffer which is binary representation of tree git object
 * @param callback function(err, treeEntries)
 * treeEntries is dictionary of the following format
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 */
var treeGetDictionary = function(buffer, callback) {
    var stringData = buffer.toString();
    var parseTreeEntry = _parseTreeEntry();
    var OK = true;
    var number = 0;
    var i = 5;
    var treeEntries = {};
    //check if buffer contains 'tree {length}\0'
    OK = OK && stringData.substring(0,5) === 'tree ';
    while (i < buffer.length && buffer[i] !== 0) {
        var zero = '0'.charCodeAt(0);
        var digit = buffer[i] - zero;
        OK = OK && digit <= 9 && digit >= 0;
        number *= 10;
        number += digit;
        ++i;
    }
    ++i;
    OK = OK && (buffer.length - number === i && number !== 0);
    //check tree entries {mode} {filename}\0{sha1}
    while (i < buffer.length) {
        var begining = i;
        while(i < buffer.length && buffer[i] !== 0) ++i;
        i = i + 21;
        //if (i > buffer.length) return false;
        if (i > buffer.length) callback('error');
        var res = parseTreeEntry(buffer.slice(begining, i))
        OK = OK && res[0];
        treeEntries[res[2]] = res[1];
    }
    //if(!OK) throw new Exception('buffer doesn\'t contain correct tree');
    callback('buffer doesn\'t contain correct tree');
    callback(undefined, treeEntries);
}

exports.objectToTree = treeGetDictionary;
exports.getBuffer = treeGetBuffer;
exports.addEntry = treeAddEntry;
exports.deleteEntry = treeDeleteEntry;
