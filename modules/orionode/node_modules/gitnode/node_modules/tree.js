var utils = require('utils.js');


/**
 * Tree object:
 * entries
 * dictionary of the following format:
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 */


/**
 * Add entry to tree dictionary
 * @param treeEntries {'sha1' : sha1, 'mode' : mode, 'type' : type}
 * dictionary of the following format:
 * {filename : {'sha1' : sha1, 'mode' : mode, 'type' : type}};
 * dict can be empty
 */
function Tree(treeEntries) {
    this.entries = treeEntries;
}


/**
 * Produce buffer from this.entries
 * @return buffer which is binary representation of tree git object
 */
Tree.prototype.toFile = function () {
    var bufferResult = new Buffer(0);
    var sortedEntries = Object.keys(this.entries).sort();
    var tree = this;
    sortedEntries.forEach(function(filename) {
        var sha1 = tree.entries[filename]['sha1'];
        var sha1Buff = utils.convertHexToDigest(sha1);
        var entryStr = tree.entries[filename]['mode'] + ' ' + filename;
        var entryBuff;
        entryStr = entryStr + '\0';
        entryBuff = new Buffer(entryStr);
        //console.log(sha1Buff.length);
        bufferResult = Buffer.concat([bufferResult, entryBuff, sha1Buff]);
    });
    //add prefix to buff?
    var prefixStr = 'tree ' + bufferResult.length.toString() + '\0';
    var prefixBuf = new Buffer(prefixStr);
    bufferResult = Buffer.concat([prefixBuf, bufferResult])
    return bufferResult;
}

/**
 * return sha1 of this tree
 */
Tree.prototype.getSha1 = function () {
    var buf = this.toFile();
    return utils.getSha1(buf);
}

/**
 * Add entry to tree dictionary
 * @param treeEntry {'sha1' : sha1, 'mode' : mode, 'type' : type}
 * @param filename filename associated with treeEntry
 */
Tree.prototype.treeAddEntry = function(treeEntry, filename) {
    this.entries[filename] = treeEntry;
}

/**
 * Delete entry with given sha1 from tree dictionary
 * @param filename filename associated with treeEntry
 */
Tree.prototype.treeDeleteEntry = function(filename) {
    delete this.entries[filename];
}



/**
 * Closure method used as helper for parseTree
 * @return function(buffer)
 * returned function parses buffer representing git tree entry and
 * returns [OK, res, filename] where
 * OK = true iff buffer represents correct tree entry
 * res dictionary {'sha1' : sha1, 'mode' : mode, 'type' : type}
 * filename is filename of git tree entry
 */
var _parseTreeEntry = function() {
    var modes = ['100644', '40000', '040000', '100000', '120000', '160000'];
    var types = {100644 : 'blob', 40000 : 'tree', 100755 : 'executable',
                120000 : 'symlink', 160000 : 'gitlink'};
    return function(buffer) {
        var i = 0;
        var space = ' '.charCodeAt(0);
        var mode;
        var OK = false;
        var res = {};
        var nullIndex = 0;
        var fileNameIndex = 0;
        var filename = '';
        
        while(i < buffer.length && buffer[i] !== space) ++i;
        fileNameIndex = i + 1;
        mode = buffer.slice(0, i).toString();
        for (var j = 0; j < modes.length; ++j) {
            if(mode === modes[j]) {
                OK = true;
                res['mode'] = parseInt(modes[j]);
                res['type'] = types[res['mode']];
                
                break;
            }
        }
        while (i < buffer.length && buffer[i] !== 0) ++i;
        nullIndex = i;
        OK = OK && i + 21 === buffer.length;
        if(OK) {
            filename = buffer.slice(fileNameIndex, nullIndex).toString();
            res['sha1'] = utils.convertDigestToHex(buffer.slice(nullIndex + 1, buffer.length));
        }
        return [OK, res, filename];
    }
}


/**
 * Produce tree dictionary from given buffer if buffer represents correct
 * git tree object
 * throws exception if buffer doesn't represent correct tree
 * @param buffer which is binary representation of tree git object
 * @param callback function(err, tree)
 */
function treeParser(buffer, callback) {
    var stringData = buffer.toString();
    var parseTreeEntry = _parseTreeEntry();
    var OK = true;
    var number = 0;
    var i = 5;
    var treeEntries = {};
    //check if buffer contains 'tree {length}\0'
    OK = OK && stringData.substring(0,5) === 'tree ';
    while (i < buffer.length && buffer[i] !== 0) {
        var zero = '0'.charCodeAt(0);
        var digit = buffer[i] - zero;
        OK = OK && digit <= 9 && digit >= 0;
        number *= 10;
        number += digit;
        ++i;
    }
    ++i;
    OK = OK && (buffer.length - number === i);
    //check tree entries {mode} {filename}\0{sha1}
    while (i < buffer.length) {
        var begining = i;
        
        while(i < buffer.length && buffer[i] !== 0) ++i;
        i = i + 21;
        if (i > buffer.length) {
            OK = false;
            break;
        }
        var res = parseTreeEntry(buffer.slice(begining, i))
        OK = OK && res[0];
        
        treeEntries[res[2]] = res[1];
    }
    
    //if(!OK) throw new Exception('buffer doesn\'t contain correct tree');
    if(OK) callback(undefined, new Tree(treeEntries));
    else callback('buffer doesn\'t contain correct tree');
}

/* Reads tree from file and gives Tree object
 * @param sha1 - tag sha1
 * @param repoPath - path of .git directory
 * @param callback - function (err, tree)
 */
var readFileToTree = function(sha1, repoPath, callback) {
    utils.readAndParse(sha1, repoPath, treeParser, callback);	
};


/* Saves Commit object to file
 * @param repoPath - path of .git directory
 * @param callback - function (err)
 */
Tree.prototype.save = function (repoPath, callback) {
    utils.saveObject(this.toFile(), repoPath, {}, callback);
};


function insertGraphEntry(graph, entries, graphIndex) {
    
    graph[graphIndex] = {};
    for(var filename in entries) {
        graph[graphIndex][filename] = {};
        graph[graphIndex][filename]['entry'] = entries[filename];
        graph[graphIndex][filename]['next'] = -1;
    }
}


/* 
 * repopath is used to read next tree from the repo, when we have its sha1
 * For example: repopath -> '/home/marcinek/gitrepotest/.git/'
 * 
 * done->callback(err, treeInfo, graph)
 * treeInfo is dictionary of all files containted in git tree after traversal
 * without directories
 * for example treeInfo = { a.txt : { 'sha1' : sha1}, b/a.txt : { 'sha1' : sha1} };
 * note there's  no b entry in treeInfo
 * 
 * on the other hand graph is an array representing graph
 * 
 * graph[0] = {'a.txt' : {'entry' : {'type' : 'blob', 'mode' : 100644, 'sha1' : sha1}, 'next' : -1}, 
 *              'b' : {'entry' : {'type' : 'tree', 'mode' : 40000, 'sha1' : sha1}, 'next' : 1}}
 * graph[1] = {'a.txt' {'entry' : {'type' : 'blob', 'mode' : 100644, 'sha1' : sha1}, 'next' : -1}}
 * 
 * so it's quite easy to do some known graph algorithms on this graph structure using the 'next' key
 * 
 */

Tree.prototype.walk = function (repopath, done) { 
    
    
    var error = false; //if there's an error we want to callback only once..
    var graph = [];
    var graphIndex = 0;
    var maping = {};
    var headSha1 = this.getSha1();
    var finish = function(err, filenames) {
        if(err) done(err);
        else {
            for(var i = 0; i < graphIndex; ++i) {
                for(var filename in graph[i]) {
                    if(graph[i][filename]['entry']['type'] === 'tree') {
                        graph[i][filename]['next'] = maping[graph[i][filename]['entry']['sha1']];
                    }
                }
            }
            done(null, filenames, graph);
        }
        
    }
    
    maping[headSha1] = graphIndex;
    insertGraphEntry(graph, this.entries, graphIndex);
    graphIndex++;
    var doJob = function (tree, repopath, recursiveDir, callback) {
        var filenames = {};
        var keys = Object.keys(tree.entries);
        var pending = keys.length;
        var treeCurrent = tree;
        keys.forEach(function(file) {
            if (!pending) return callback(null, filenames);
            var resPath = recursiveDir + file;
            if (treeCurrent.entries[file]['type'] === 'tree') {
                readFileToTree(treeCurrent.entries[file]['sha1'], repopath, function(err, tree) {
                    if(error) {
                        return;
                    }
                    if(err) {
                        error = true;
                        done(err);
                    }
                    else {
                        maping[treeCurrent.entries[file]['sha1']] = graphIndex;
                        insertGraphEntry(graph, tree.entries, graphIndex);
                        graphIndex++;
                        doJob(tree, repopath, recursiveDir + file + '/', function(err, res) {
                            if(err) ;
                            else {
                                for (var attrname in res) { filenames[attrname] = res[attrname]; }
                                if (!--pending) callback(null, filenames);
                            }
                        });
                    }
                });
            } else {
                filenames[recursiveDir + file] = {'sha1' : treeCurrent.entries[file]['sha1']};
                if (!--pending) callback(null, filenames);
            }
        });
    }
    doJob(this, repopath, '', finish);
};

/**
 * Function walks through graph from graph[0]
 * this function returns array of indexes which are accessible
 * from graph[0]
 * @param graph = graph object returned from tree.js walk
 * @return - array of integers
 */
function getGraphIndexes(graph) {
    var res = [];
    res.push(0);
    function seek(graphIndex) {
        for(var k in graph[graphIndex]) {
            if(graph[graphIndex][k]['next'] !== -1) {
                res.push(graph[graphIndex][k]['next']);
                seek(graph[graphIndex][k]['next']);
            }
        }
    } 
    seek(0);
    return res;
}

/**
 * Function saves recursively git tree objects to repository
 * Graph represents tree 
 * we save the only graph entries which are accessible from graph[0]
 * by walking
 * @param path = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @done - callback(err)
 */
function graphToRepo(repopath, graph, done) {
    var graphEntries = getGraphIndexes(graph);
    var pending = graphEntries.length;
    var error = false;
    for(var i = 0; i < graphEntries.length; ++i) {
        var tmpTree = new Tree({});
        for(var entry in graph[graphEntries[i]]) {
            tmpTree.entries[entry] = graph[i][entry]['entry'];
        }
        tmpTree.save(repopath, function(err) {
            if(error) {
                return ;   
            }
            if (err) {
                error = true;
                done(err);
            }
            if(!--pending) done(null);
        });
    }
    if(!--pending) {
        done(null);   
    }
}

exports.graphToRepo = graphToRepo;
exports.Tree = Tree;
exports.readFileToTree = readFileToTree;
exports.treeParser = treeParser;