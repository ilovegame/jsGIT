//TODO index na packIndex
//TODO we need int64!!
var co = require('crypto');
var fs = require('fs');
var ph = require('path');
var utils = require('utils');
var zlib = require('zlib');
var crc32 = require('buffer-crc32');

var typeCodes = {
	'tag' : 64,
	'tree' : 32,
	'commit' : 16,
	'blob' : (16 + 32)
}

function PackWriter(repoPath, objects)
{
	this.objects = objects;
	this.bytesWritten = 0;
	this.offset32 = new Array();
	this.offset64 = new Buffer(8 * this.objects.length);
	this.offset64TableOffset = 0;
	this.crc32 = new Array();	
	this.sortedObjects = this.sortObjects();
	this.sha1 = this.getPackName();
	
	this.repoPath = repoPath;
	var dir = ph.join(repoPath, 'objects/pack');
	var pack = 'pack-' + this.sha1 + '.pack';
	var index = 'pack-' + this.sha1 + '.idx';
	
	this.packPath = ph.join(dir, pack);
	this.indexPath = ph.join(dir, index);
}

PackWriter.prototype.sortObjects = function ()
{
	var i;
	var sortedObjects = new Array(this.objects.length);
	for (i = 0; i < this.objects.length; ++i)
	{
		sortedObjects[i] = this.objects[i];
	}
	return sortedObjects.sort();
}

PackWriter.prototype.getPackName = function()
{
	//sha1 of sorted sha1 objects list
	var shaBuf = new Buffer(20*this.sortedObjects.length);
	var offset = 0;
	var i;
	for (i = 0; i < this.sortedObjects.length; ++i)
	{
		shaBuf.write(this.sortedObjects[i], offset, 20, 'hex');
		offset += 20;
		
	}
	return utils.getSha1(shaBuf);
}

//objects - array of sha1 checksums
//repoPath
PackWriter.prototype.writePackHeader = function (callback)
{
	var header = new Buffer (12);
	header.write('PACK'); //signature
	header.writeUInt32BE(2, 4); // git version
	header.writeUInt32BE(this.objects.length, 8); // objects count
	var pw = this;
	
	fs.appendFile(this.packPath, header, function (err) {
		if (err) throw err;
		pw.bytesWritten += header.length;
		pw.writePackObject(0, callback);
	});
	
}

// returns bytes count
PackWriter.prototype.encodeTypeSize = function (type, rawLength, headerBuffer) {
	var nextLength = rawLength >> 4;
	headerBuffer[0] = (( (nextLength > 0) ? 0x80 : 0x00) | (type ) | (rawLength & 0x0F));

	rawLength = nextLength;
	var n = 1;
	while (rawLength > 0) {
		nextLength = nextLength >> 7;
		headerBuffer[n++] = ((nextLength > 0 ? 0x80 : 0x00) | (rawLength & 0x7F));
		rawLength = nextLength;
	}
	
	return n;
}




//callback
PackWriter.prototype.appendSha1 = function (callback)
{
	var shasum = co.createHash('sha1');
	var pw = this;
	
	var stream = fs.createReadStream(this.packPath, {
		flags: 'r',
		encoding: null,
		fd: null,
		mode: 0666,
		bufferSize: 64 * 1024
	});

	stream.on('data', function(data2){
		shasum.update(data2);
	});

	stream.on('error', function(){
		throw 'error during reading file'
	});

	stream.on('end', function(){
		var sha1 = shasum.digest('hex');
		sha1 = new Buffer(sha1, 'hex');

		pw.sha1 = sha1;
		fs.appendFile(pw.packPath, sha1, function (err) {
			if (err) 
			{
				throw err;
			}
			pw.bytesWritten += sha1.length;
			pw.writeIndexToFile(callback);
		});
	});
	
}

// fileIndex - which file
PackWriter.prototype.writePackObject = function (fileIndex, callback)
{
	if (fileIndex >= this.objects.length)
	{
		//all files have been written to pack
		this.appendSha1(callback);
	}
	else {
		var pw = this;
		var filePath = utils.getFilePath(this.objects[fileIndex], this.repoPath);

		utils.readObjectAndType(this.objects[fileIndex], pw.repoPath, function (err, object, type)
		{
			var typeCode = typeCodes[type]; 
			//now we have to append it
			var headerBuffer = new Buffer(100); // arbitrary
			var headerLen = pw.encodeTypeSize(typeCode, object.length, headerBuffer);
			utils.deflateOpts(object, function(err, deflatedData) { 
				if (err)
				{
					throw err;
				}
				var objectRepr = new Buffer(headerLen + deflatedData.length);
				headerBuffer.copy(objectRepr, 0, 0, headerLen);
				deflatedData.copy(objectRepr, headerLen);
				
				fs.appendFile(pw.packPath, objectRepr, function (err) {
					if (err) 
					{
						throw err;
					}
					pw.offset32[pw.objects[fileIndex]] = pw.bytesWritten;
					
					var objectCRC =  crc32.unsigned(objectRepr)
					pw.crc32[pw.objects[fileIndex]] = objectCRC;

					pw.writePackObject(fileIndex + 1, callback);
					pw.bytesWritten += objectRepr.length;
				});
			}, { level : -1 } ); //TODO should be set by git config
		});

	}
}

//object - array of sha1
function createPack (repoPath, objects, callback)
{
	var pw = new PackWriter(repoPath, objects);
	try {
		fs.exists(pw.packPath, function (exists) {
			if (exists)
			{
				fs.unlink(pw.packPath, function (err) {
					if (err) 
					{
						throw err;
					}
					pw.writePackHeader(callback);

				});
			}
			else
			{
				pw.writePackHeader(callback);
			}
		});
	}
	catch (err)
	{
		callback(err);
	}
}

/////////////////////////////

//TODO should use int 64 module
PackWriter.prototype.generateOffsets = function()
{
	var len = this.sortedObjects.length;
	//sha1 table
	for (i = 0; i < len; ++i)
	{
		var sha1 = this.sortedObjects[i];
		var offset = this.offset32[sha1];
		//TODO offset, bytesWritten should be 64 - bit number
		//if it's bigger than 32
		
		var IS_O64 = 1 << 31;
		//if offset > (Math.pow(2,31) - 1)
		if (offset & IS_O64)
		{
			this.offset32[sha1] = IS_O64 | offset64TableOffset;
			
			var first32 = offset >> 32;
			offset.writeUInt32BE(first32, offset64TableOffset);
			var second32 = (offset << 32) >> 32;
			offset.writeUInt32BE(second32, offset64TableOffset + 4);
			
			offset64TableOffset += 8;
			//this.offset64 = 
		}
		
	}
	
}

PackWriter.prototype.createIndexFileBuffer = function()
{
	var bufferSize = 2*4; //header
	bufferSize += 256*4; //fanout
	bufferSize += 20*this.objects.length; //sorted objects
	bufferSize += 4*this.objects.length; //crc
	bufferSize += 4*this.objects.length; //32 offset
	bufferSize += 8 * this.offset64TableOffset; //64 offset
	bufferSize += 2*20; //two sha1 checksums
	var buffer = new Buffer(bufferSize);
	return buffer;
}

PackWriter.prototype.writeIndexHeader = function (buffer)
{
	var offset = 0;

	var dummy = 0xff744f63; 
	buffer.writeUInt32BE(dummy, 0);
	offset += 4;
	buffer.writeUInt32BE(2, offset); //git version
	offset += 4;
	return offset;
}

PackWriter.prototype.generateFanout = function()
{
	var fanout = new Array(256);
	var i = 0;
	for (i = 0; i < 256; ++i)
	{
		var j = 0;
		while ( (j < this.objects.length) && ( (new Buffer(this.sortedObjects[j], 'hex') [0] ) <= i) )
		{
			++j;
		}
		fanout[i] = j;
	}
	return fanout;
}

PackWriter.prototype.writeIndexFanout = function (buffer, offset)
{
	var fanout = new Array(256);
	var i = 0;
	for (i = 0; i < 256; ++i)
	{
		var j = 0;
		while ( (j < this.objects.length) && ( (new Buffer(this.sortedObjects[j], 'hex') [0] ) <= i) )
		{
			++j;
		}
		fanout[i] = j;
	}
	
	var i = 0;
	for (i = 0; i < 256; ++i)
	{
		buffer.writeUInt32BE(fanout[i], offset);
		offset += 4;
	}
		
	return offset;
}

PackWriter.prototype.writeIndexObjects = function (buffer, offset)
{

	//sha1 table
	for (i = 0; i < this.sortedObjects.length; ++i)
	{
		buffer.write(this.sortedObjects[i], offset, 20, 'hex'); //correct?
		offset += 20;
	}
	return offset;
}

PackWriter.prototype.writeIndexCRC = function (buffer, offset)
{

	for (i = 0; i < this.sortedObjects.length; ++i)
	{
		var sha1 = this.sortedObjects[i];
		buffer.writeUInt32BE(this.crc32[sha1], offset);
		offset += 4;
	}
	return offset;
}

//TODO
PackWriter.prototype.writeIndexOffsets = function (buffer, offset)
{
	this.generateOffsets();
	
	//offset 32
	for (i = 0; i < this.sortedObjects.length; ++i)
	{
		var sha1 = this.sortedObjects[i];
		buffer.writeUInt32BE(this.offset32[sha1], offset);
		//big endian
		offset += 4;
	}
	
	this.offset64.copy(buffer, offset, 0, this.offset64TableOffset);
	offset += this.offset64TableOffset;
	return offset;
}

PackWriter.prototype.writeIndexSha1 = function (buffer, offset)
{
	this.sha1.copy(buffer, offset, 0, 20);
	offset += 20;
	
	var indexSha1 = utils.getSha1(buffer.slice(0,offset));
	buffer.write(indexSha1, offset, 20, 'hex');
	offset += 20;
	
	return offset;
}

PackWriter.prototype.writeIndexToFile = function (callback)
{
	var buffer = this.createIndexFileBuffer();
	
	var offset = this.writeIndexHeader(buffer);
	offset = this.writeIndexFanout(buffer, offset);
	offset = this.writeIndexObjects(buffer, offset);
	offset = this.writeIndexCRC(buffer, offset);
	offset = this.writeIndexOffsets(buffer, offset);
	offset = this.writeIndexSha1(buffer, offset);

	fs.writeFile(this.indexPath, buffer, function (err) {
		if (err) 
		{
			throw err;
		}
		callback(null);
	});
}

exports.createPack = createPack;