 //here be dragons
 //TODO: SENDING TAG REQUESTS, different server capabilities, ssh
 
net = require('net');
url = require('url');
 
var zeroId = '0000000000000000000000000000000000000000';
var headRef = 'HEAD';

/**
 * Returns buffer with call to git upload pack 
 * Used for reference discovery (start clone/fetch negotiation)
 * commands' format:
 * |4 bits with length in hex|command string
 * length = length(command string) 
 * Example:
 * repo = /kyloel/clone.git <= few cases, check for '/' etc
 * host = github.com
 * @param repo - name of repo, not all cases supported (TODO)
 * @param host - name of server containg repo
 */
var gitUploadPackBuff = function(repo, host)
{
    var reqbuf = new Buffer('git-upload-pack ' + repo + '\0host=' + host + '\0');
    //hexString = (reqbuf.length).toString(16); //magic  - ignore last \0, count lenbuf too.
    var hexString = (reqbuf.length + 4).toString(16);  //dunno witch one is good
    //hexString = (reqbuf.length + 3).toString(16); 
    //yourNumber = parseInt(hexString, 16);
    var len = '';
    for(var i = 0; i <  4 - hexString.length; i++)
    {
        len += '0';
    }
    len += hexString;
    var lenbuf = new Buffer(len);
    return new Buffer.concat([lenbuf, reqbuf]);
}


/**
 * Adds 4 bits of length at the begging of the command
 * @param commandBuffer - buffer with command
 * @return full command buffer with length at the begining
 */
var addPktLen = function(commandBuffer)
{
    var hexString = (commandBuffer.length + 4).toString(16); //? 4 or 3?
    var len = '';
    for(var i = 0; i <  4 - hexString.length; i++)
    {
        len += '0';
    }
    len += hexString;
    var lenbuf = new Buffer(len);
    return new Buffer.concat([lenbuf, commandBuffer]);
}

/**
 * Produces first want command (choosing server capabilities gitnode understands)
 * TODO: case where server doesn't include tags
 * @param objectId (string) should be HEAD or first object?
 * @param serverCapabilities array of strings with server capabilities (returned in server 
 * answer)
 * @return buffer with first want (without length)
 */
var firstWant = function(objectId, serverDisc)
{
    var tempString = 'want ' + objectId + ' ';
    if(serverDisc.supportsFlag('multi_ack')) //maybe turn this off? 
    {
        tempString += 'multi_ack ';
    }
    if(serverDisc.supportsFlag('ofs-delta')) //packV2
    {
        tempString += 'ofs-delta ';
    }
    if(serverDisc.supportsFlag('include-tag')) //copy with tags??
    {
        tempString += 'include-tag ';
    }
    var temp = new Buffer(tempString);
    temp[tempString.length-1] = 10;
    return temp;
}
/*
 * Constructs of wants command other than first line 
 * @param objectId (string) id of object for this want
 * @return buffer with want command
 */
var additionalWant = function(objectId)
{
    var tempString = 'want ' + objectId + "\n";
    return new Buffer(tempString);
}

/**
 * Produces array of whole 'wants' request needed to clone
 * @param serverDisc data obtained about server
 * @param count how many refs to be send in one packet (default 32 is approved by Linus)
 * @return buffer with command to be send to server
 */
var cloneWant = function(serverDisc, count)
{
    count = count || 32; 
    var ret = [];
    var query = [];
    var i;
    if(serverDisc.hasValidHead())
    {
        query.push(addPktLen(firstWant(serverDisc.objects[0].sha1, serverDisc)));
        i = 0;
    }
    else
    {
        query.push(addPktLen(firstWant(serverDisc.heads[0].sha1, serverDisc)));
        i = 1;
    }
    for(i; i < serverDisc.heads.length; i++)
    {
        query.push(addPktLen(additionalWant(serverDisc.objects[i].sha1)));
        if(query.length == count)
        {
            ret.push(Buffer.concat(query));
            query = [];
        }
    }
    if(!serverDisc.supportsFlag('include-tag'))
    {
        //todo, trzeba dodaÄ‡ tagi
    }
    //adding flush to last query
    if(query.length != 0){
        ret.push(addFlush(Buffer.concat(query)));
        query = [];
    }
    else{
        ret[ret.length - 1] = addFlush(ret[ret.length - 1]);
    }
    return ret;
}

/**
 * adds flush at the and of packet (0000)
 */
var addFlush = function(buffer)
{
    //pases array with two elements
    return Buffer.concat([buffer, new Buffer('0000')]);
}

/**
 * produces done command buffer
 */
var done = function()
{
    return addPktLen(new Buffer('done\n'));
}

/**
 * used for holding objects
 * @param sha1 (id of object)
 * @param path 
 */
var object = function(sha1, path)
{
    this.sha1 = sha1;
    this.path = path;
}

/**
 * objects are in order given by server
 * Holds data about server discovery
 */
serverDiscovery = function(objs, capabs, noRefs)
{
    this.noRefs = noRefs || false; 
    this.objects = objs || [];
    this.capabilities  = capabs || [];
    this.heads = []
    this.tags = []
    this.objects.forEach(function(elem){
        //TODO refs: pull/number/ and merge/numbre
        if(elem.path.indexOf('/heads') != -1)
        {
            this.heads.push(elem);
        }
        else if(elem.path.indexOf('/tags') != -1)
        {
            this.tags.push(elem);
        }
    }, this);
}

/**
 * Returns true if there is HEAD ref
 */
serverDiscovery.prototype.hasValidHead = function() 
{
    return this.objects[0].path === headRef;
}

/**
 *  Returns sha1 of HEAD, if there is no HEAD throws error
 */
serverDiscovery.prototype.headSha1 = function() 
{
    if(this.hasValidHead())
        return this.objects[0].sha1;
    else
        throw 'There is no valid head'; //TODO return?
}

/**
 * Returns true if there are refs
 */
serverDiscovery.prototype.haveRefs = function()
{
    return !this.noRefs;
}

/**
 * Returns true if server supports given flag
 * @param flag string with flag name
 */
serverDiscovery.prototype.supportsFlag = function(flag)
{
    if(this.capabilities.indexOf(flag) != -1)
        return true;
    else
        return false;
}

/**
 * Return number of heads/ refs
 */
serverDiscovery.prototype.headCount = function()
{
    return this.heads.length;
}


var checkExistance = function(buffer, start, end)
{
    if((buffer.length >= start) && (buffer.length >= end))
        return true;
    else
    {
        return false
    }
}

/**
 * Parse server answer from reference discovery 
 * @param data  whole reference discovery
 * @return serverDiscovery object
 */
var parseReferenceDiscoveryConcated = function(data)
{
    var objects = [];
    var options;
    for(var i = 0; (i < data.length); )
    {
        var len = data.slice(i, i+4);
        var parseLen = parseInt(len.toString(), 16);
        if(parseLen == 0) 
            break;
        var toParse = data.slice(i + 4, i + parseLen).toString().replace("\n",""); //ignore ptk-len
        if(i == 0) 
        {
            var firstRow = toParse.split("\0");
            if(firstRow.length == 2)
            {
                options = firstRow[1].split(" ");
                toParse = firstRow[0];
            }
            //parse options
        }
        var obj = toParse.split(" ");
        if(obj[0] === zeroId){
            return new serverDiscovery([], options, true);
        }
        objects.push(new object(obj[0], obj[1]));
        i += parseLen;
    }
        return new serverDiscovery(objects, options);  
}





/**
 * checks if there is flush (0000) at the end of buffer
 */
var checkForFlush = function(data)
{
    if((data[data.length-4] == 48) && (data[data.length-3] == 48) &&
        (data[data.length-2] == 48) && (data[data.length-1] == 48))
           return true;
    else
        return false;
}

/**
 * checks for NAK answer at the beggingin of the buffer (server accepted)
 */
var checkForNAK = function(data)
{
    var toComp = new Buffer("0008NAK\n");
    var ret = true;
    var i = 0;
    if(data.length != toComp.length)
        return false;
    for(i; i < data.length; i++)
    {
        if(data[i] != toComp[i])
            ret = false;
    }
    return ret;
}

/**
 * this is not used in the way it should be 
 */
var conversationState = 
{
    start: 0,
    discovery: 1,
    negotiation: 2,
    packfileFetch: 3
}

/**
 * if server sends more then one pack, used to produce array of packs
 * from server answer 
 * TODO there may be memory issues with many huge packs
 */
var cutPacks = function(data)
{
    var toComp = new Buffer("PACK");
    var packs = [];
    var lastSlice = 0;
    for(var i = 1; i < data.length - 4; i++)
    {
        if((data[i] == toComp[0]) && (data[i+1] == toComp[1])
        && (data[i+2] == toComp[2]) && (data[i+3] == toComp[3]))
        {
            packs.push(data.slice(lastSlice, i)); 
            lastSlice = i;
        }
        if(i == (data.length - 5))
        {
            packs.push(data.slice(lastSlice, data.length));
        }
    }
    return packs;
}

/*
 * Goes through whole git clone conversation and obtains packfiles
 * @param gitProtoLink f.e. 'git://github.com/user/repo.git'
 * @param callback(arrayOfPacks, serverDiscovery) where to pass the packs data 
 * and server discovery
 */
var gitCloneConversation = function(gitProtoLink, callback)
{
    var ans = [];
    var state = conversationState.start;
    var sDiscovery;
    var repoParams = url.parse(gitProtoLink);
    var options = {port: (repoParams.port || 9418), host: repoParams.hostname};
    //create connection with server over git://
    var client = net.createConnection(options, function(){
        //start reference discovery
        client.write(gitUploadPackBuff(repoParams.pathname, repoParams.hostname));
        
    });
    client.on('data', function(data){
        switch(state)
        {
            //got answer from reference discovery, parse it, and send requests
            case conversationState.start:
                ans.push(data);
                if(checkForFlush(data))
                {    
                    //this seems to work:
                    sDiscovery = parseReferenceDiscoveryConcated(Buffer.concat(ans));
                    if(sDiscovery.noRefs){
                        //TODO nothing to clone
                        //throw 'nothing to clone';
                        callback([], sDiscovery);
                        return;
                    }
                    state = conversationState.discovery;
                    ans = [];
                    cloneWant(sDiscovery).forEach(function(elem){
                        client.write(elem);
                    });
                    client.write(done());
                }
            break;
            case conversationState.discovery:
                //NAK - server accepted
                if(checkForNAK(data))
                {
                    state = conversationState.packfileFetch;
                    ans = [];
                    //need to add start of pack send in one packet with NAK
                    ans.push(data.slice(8,data.length));
                }
            break;
            case conversationState.negotiation:
                //clone doesent negotiate haves
            break;
            //gather pack data
            case conversationState.packfileFetch:
                ans.push(data);
            break;
        }
        
    });
    client.on('end', function(){
        //server sent whole data, pass pack files to callback
        if(state == conversationState.packfileFetch)
        {
            var pack = Buffer.concat(ans);
            //callback(cutPacks(pack), sDiscovery);
            //TODO check if true: assume there is only one pack in response:
            callback(pack, sDiscovery);
            client.end();
        }
    });
}


exports.getPack = gitCloneConversation;

//gitCloneConversation('git://github.com/kyloel/clone.git', test);

//gitCloneConversation('git://github.com/mozilla/monolith.git');
//gitCloneConversation('git://github.com/wakaleo/game-of-life.git')
//gitCloneConversation('git://github.com/torvalds/linux.git');
//gitCloneConversation('git://github.com/github/gitignore.git');
//gitCloneConversation('git://github.com/django/django.git');