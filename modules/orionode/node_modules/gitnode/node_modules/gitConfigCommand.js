var fs = require ('fs');
var ph = require('path');
var utils = require('utils');

// Config object constructor
// attribute variables - dictionary with variables values
// for example:
// variable remote in section [branch "master"] of config file ----> variables[branch.master.remote]
function Config(repoPath)
{
    this.variables = { };
    this.repoPath = repoPath;
    var path = ph.join(repoPath, '/config');
    this.path = path;
}

// Adds new variable to object or 
// overwrites it's previous value (if variable can't have multiple values) or
// add next value of variable otherwise
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - value to set
Config.prototype.updateVariable = function (key, variableValue)
{
    if (canHaveMultipleValues(key))
    {
        if (!this.variables[key])
        {
            this.variables[key] = new Array();
        }
        this.variables[key].push(variableValue);
    }
    else
    {
        this.variables[key] = variableValue;
    }
}


// Some variables can have multiple values.
// This function checks is variable key is one of these
// @param key - variable full name, f.e. branch.master.remote
function canHaveMultipleValues (key)
{
    var multipleValues = [ 'include.path', 'core.gitproxy']; //case sensitive
    key = key.toLowerCase();
    if (multipleValues.indexOf(key) !== -1)
    {
        return true;
    }
    
    //keys branch.<name>.merge are allowed too
    if (key.length > 'branch..merge'.length && key.substr(0, 7) === 'branch.' 
        && key.substr(key.length - 7, 6))
    {
        return true;
    }
    
    return false;   
}

// Removes both types of comments (; and #) from line
// @param line - string to modify
function removeComments(line)
{
    var str = line;
    if (str.indexOf(';') !== -1)
    {
        var temp = utils.splitByFirst(str, ';');
        str = temp[0];
    }
    
    if (str.indexOf('#') !== -1)
    {
        var temp = utils.splitByFirst(str, '#');
        str = temp[0];
    }
    
    return str;
}

// Parses line with assignment to variable name and value
// @param line - string, format: variable = value, but
// with possible whitespaces, comments to variable and value strings
function readVariable(line)
{
    var words = utils.splitByFirst(line, '=');
    var variableName = words[0].trim();
    // variable names are case-insensitive:
    variableName = variableName.toLowerCase();  
    var variableValue = words[1].trim();
                
    return [variableName, variableValue];   
}

// Parses line with section name from config file
// @param str - line with section name
function parseSectionName(str)
{
    // "Section names are not case sensitive."
    str = str.toLowerCase();
    if (str[str.length -1 ] !== ']')
    {
        throw 'lacks bracket ending';
    }
    
    var bracketText = str.substr(1, str.length - 2);
    var words = bracketText.split(' ');
    
    //is it section or subsection ?
    if (words.length === 1) //section
    {
        section = words[0];
    }
    else if (words.length === 2)//subsection
    {
        var subsection = words[1].substr(1, words[1].length - 2);
        section = words[0] + '.' + subsection;
    }
    else
    {
        throw 'err in parsing config file'
    }
    return section; 
}
// Reads and parses config file and updates Config object
// @callback - function (err)
Config.prototype.readFile = function (callback)
{
    var config = this;
    fs.readFile(config.path, function (err, dataBuffer) {
        if (err)
        {
            callback(err);
        }
        else
        {
            var data = dataBuffer.toString();
            var lines = data.split('\n');
            
            var i = 0;
            var section = null;

            for (i = 0; i < lines.length; ++i)
            {
                var line = removeComments(lines[i].trim());

                if (line.length === 0 || line[0] === ';'
                    || line[0] === '#')
                {

                }
                else if (line[0] === '[')
                {
                    section = parseSectionName(line);
                }
                else
                {
                    var res = readVariable(line);
                    config.updateVariable(section + '.' + res[0], res[1]);  
                }
            }
            callback(null);
        }
    });
    
}

// Modifies config file, it can: remove line, add new line(s) (at specified position),
//  modify specified line
// @param lines - config file content splitted by new line character
// @param lineIndex - index of line to modify
// @param operation - what we want to do: 'add' or 'modfiy' or 'remove'
// @param data - string to insert at specified position, can be null
// @param callback - function (err)
Config.prototype.modifyConfig = function (lines, lineIndex, operation, data, callback)
{
    
    var newConfigData = lines.slice(0, lineIndex + 1);
    
    if (operation === 'add')
    {
        newConfigData.push(data);
    }
    else if (operation === 'modify')
    {
        newConfigData[newConfigData.length-1] = data;
    }
    else //operation === remove
    {
        newConfigData.pop();
        //remove section if empty
        var i = lineIndex - 1;
        var isFound1 = false;
        // find prev section
        while (!isFound1 && i >= 0)
        {
            var prevLine = removeComments(lines[i].trim());
            if (prevLine[0] === '[')
            {
                isFound1 = true;
            }
            else if (prevLine !== '')
            {
                break;
            }
            else
            {
                --i;
            }
        }
        
        var j = lineIndex + 1;
        var isFound2 = false;
        // find next section
        while (!isFound2 && j < lines.length) 
        {
            var nextLine = removeComments(lines[j].trim());
            if (nextLine[0] === '[')
            {
                isFound2 = true;
            }
            else if (nextLine !== '')
            {
                break;
            }
            else
            {
                ++j;
            }
        }

        if (isFound1 && (isFound2 || (!isFound2 && j === lines.length)))
        {
            // remove i-th line
            var temp = lines.slice(0,i);
            var temp2 = newConfigData.slice(i+1);
            newConfigData = temp.concat(temp2)
            
            
        }
    }
    
    var restOfData = lines.slice(lineIndex + 1);
    newConfigData = newConfigData.concat(restOfData);
    
    var output = '';
    var i;
    for (i = 0; i < newConfigData.length; ++i)
    {
        output += newConfigData[i];
        
        if (i < newConfigData.length - 1)
        {
            output += '\n';
        }
    }

    fs.writeFile(this.path, output, function (err) {
        callback(err);
    });
}

// Takes key and gives it's section and variableName
// @param key - full variable name (f.e. branch.master.remote)
function parseKey(key)
{
    var i = key.lastIndexOf('.');
    var section = key.slice(0, i);
    var variableName = key.slice(i + 1);
    return [section, variableName]
}

// Takes section and creates section header (f.e. [branch "devel"] )
// @param section - (sub)section format in dot notation
function sectionToBracketFormat(section)
{
    if (section.indexOf('.') === -1)
    {
        var temp = '[' + section + ']';
        return temp;
    }
    else
    {
        var res = utils.splitByFirst(section, '.');
        var mainSection = res[0];
        var subsection = res[1];
        var temp = '[' + mainSection + ' \"' + subsection + '\"' + ']';
        return temp;
    }
    
}

// Reads config file, and looks for line, which gives verify(section, line) === true
// @param verify - function (section, line) indicates whether we found line we want
// @param callback - function (err, lineIndex, fileContent)
Config.prototype.findLine = function (verify, callback)
{
    var config = this;
    fs.readFile(this.path, function (err, dataBuffer) {
        if (err)
        {
            callback(err, null, null);
        }
        else
        {
            var data = dataBuffer.toString();
            var lines = data.split('\n');
            var i = 0;
            var section = null;
            var indexFound = -1;
            
            for (i = 0; i < lines.length && indexFound === -1; ++i)
            {
                var line = removeComments(lines[i].trim());
                if (line.length === 0 || line[0] === ';'
                    || line[0] === '#')
                {

                }
                else {
                    if (line[0] === '[')
                    {
                        section = parseSectionName(line);
                    }
                    
                    if (verify(section, line))
                    {
                        indexFound = i;
                    }
                }

            }
            callback(null, indexFound, data);
        }
    });
}


// Method to find line which contains assignment to given key
// @param repoPath - path of .git folder
// @param key - variable full name, f.e. branch.master.remote
// @param callback - function (err, lines, lineIndex);
Config.prototype.findVariable = function (key, callback)
{
    var j = key.lastIndexOf('.');
    var sectionToModify = key.substr(0, j);
    
    var variableName = key.slice(1 + j);
    
    var verify = function(section, line)
    {
        var res = readVariable(line);
        //return [variableName, variableValue]; 
        if (section && section === sectionToModify && key === (section + '.' + res[0]))
        {
            return true;
        }
        return false;
    };
    
    this.findLine(verify, function (err, lineIndex, fileContent) {
        if (err)
        {
            callback(err, null, null);
        }
        else
        {
            var lines = fileContent.split('\n');
            callback(err, lines, lineIndex);
        }
    });
}


// Reads config file and returns dictionary with all variables and values
// @param repoPath - path of .git folder
// @param callback - function (err, options), options is dictionary
function getOptions (repoPath, callback)
{
    var config = new Config(repoPath);
    config.readFile(function (err) {
        if (err) 
        { 
            callback(err, null);
        }
        else
        {
            callback(null, config.variables);
        }
    });
    
}

// Reads config file and returns given option value
// @param repoPath - path of .git folder
// @param callback - function (err, option)
function getOption (repoPath, variableName, callback)
{
    var config = new Config(repoPath);
    getOptions (repoPath, function (err, options) {
        if (err) 
        { 
            callback(err, null);
        }
        else
        {
            callback(err, options[variableName]);
        }
    });
}

// Adds new variable (or next value of variable, if it can have multiple values)
// @param repoPath - path of .git folder
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - string with value to set
// @param callback - function (err);
function addOption (repoPath, key, variableValue, callback)
{
    var config = new Config(repoPath);
    var res = parseKey(key);
    var sectionToModify = res[0];
    var variableName = res[1];  
    var dataToWrite = '        ' + variableName + ' = ' + variableValue;
    
    var verify = function(section, line) {
        return (sectionToModify === section);
    };

    config.findLine(verify, function (err, lineIndex, fileContent)
    {
        if (err)
        {
            callback(err)
        }
        else
        {
            var lines = fileContent.split('\n');
            
            if (lineIndex === -1)
            {
                var bracket = sectionToBracketFormat(sectionToModify);
                dataToWrite = bracket + '\n' + dataToWrite;
                lineIndex = lines.length;
            }
            
            config.modifyConfig(lines, lineIndex, 'add', dataToWrite, function (err){
                callback(err);
            });
        }
    });
    
}

// Updates option's value
// @param repoPath - path of .git folder
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - string with value to set
// @param callback - function (err);
function updateOption (repoPath, key, variableValue, callback)
{
    var config = new Config(repoPath);
    config.findVariable(key, function(err, lines, lineIndex) {
        if (err)
        {
            callback(err)
        }
        else
        {
            var res = parseKey(key);
            var sectionToModify = res[0];
            var variableName = res[1];
            
            var dataToWrite = '        ' + variableName + ' = ' + variableValue;
            
            
            if (lineIndex === -1)
            {
                callback('option not found');
                
            }
            else
            {
                config.modifyConfig(lines, lineIndex, 'modify', dataToWrite, function (err){
                    callback(err);
                });
            }
        }
    });
}

// Removes variable
// @param repoPath - path of .git folder
// @param key - variable full name, f.e. branch.master.remote
// @param callback - function (err);
function removeOption (repoPath, key, callback)
{
    var config = new Config(repoPath);
    config.findVariable(key, function(err, lines, lineIndex) {
        if (err)
        {
            callback(err)
        }
        else if (lineIndex === -1)
        {
            callback('option not found');
        }
        else
        {
            config.modifyConfig(lines, lineIndex, 'remove', null, function (err){
                callback(err);
            });
        }
    });
}

exports.getOptions = getOptions;
exports.getOption = getOption;
exports.addOption = addOption;
exports.updateOption = updateOption;
exports.removeOption = removeOption;