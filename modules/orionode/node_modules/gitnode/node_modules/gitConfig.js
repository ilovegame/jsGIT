var fs = require ('fs');
var ph = require('path');
var utils = require('utils');

// Config object constructor
// attribute variables - dictionary with variables values
// for example:
// variable remote in section [branch "master"] of config file ----> variables[branch.master.remote]
function Config(repoPath)
{
	this.variables = { };
	this.repoPath = repoPath;
	var path = ph.join(repoPath, '/config');
	this.path = path;
}

// Adds new variable to object or 
// overwrites it's previous value (if variable can't have multiple values) or
// add next value of variable otherwise
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - value to set
Config.prototype.updateVariable = function (key, variableValue)
{
	if (canHaveMultipleValues(key))
	{
		if (!this.variables[key])
		{
			this.variables[key] = new Array();
		}
		this.variables[key].push(variableValue);
	}
	else
	{
		this.variables[key] = variableValue;
	}
}


// Some variables can have multiple values.
// This function checks is variable key is one of these
// @param key - variable full name, f.e. branch.master.remote
function canHaveMultipleValues (key)
{
	var multipleValues = [ 'include.path', 'core.gitproxy']; //case sensitive
	key = key.toLowerCase();
	if (multipleValues.indexOf(key) !== -1)
	{
		return true;
	}
	
	//keys branch.<name>.merge are allowed too
	if (key.length > 'branch..merge'.length && key.substr(0, 7) === 'branch.' 
		&& key.substr(key.length - 7, 6))
	{
		return true;
	}
	
	return false;	
}

// Removes both types of comments (; and #) from line
// @param line - string to modify
function removeComments(line)
{
	var str = line;
	if (str.indexOf(';') !== -1)
	{
		var temp = utils.splitByFirst(str, ';');
		str = temp[0];
	}
	
	if (str.indexOf('#') !== -1)
	{
		var temp = utils.splitByFirst(str, '#');
		str = temp[0];
	}
	
	return str;
}

// Parses line with assignment to variable name and value
// @param line - string, format: variable = value, but
// with possible whitespaces, comments to variable and value strings
function readVariable(line)
{
	var words = utils.splitByFirst(line, '=');
	var variableName = words[0].trim();
	// variable names are case-insensitive:
	variableName = variableName.toLowerCase();	
	var variableValue = words[1].trim();
				
	return [variableName, variableValue];	
}

// Parses line with section name from config file
// @param str - line with section name
function parseSectionName(str)
{
	// "Section names are not case sensitive."
	str = str.toLowerCase();
	if (str[str.length -1 ] !== ']')
	{
		throw 'lacks bracket ending';
	}
	
	var bracketText = str.substr(1, str.length - 2);
	var words = bracketText.split(' ');
	
	//is it section or subsection ?
	if (words.length === 1) //section
	{
		section = words[0];
	}
	else if (words.length === 2)//subsection
	{
		var subsection = words[1].substr(1, words[1].length - 2);
		section = words[0] + '.' + subsection;
	}
	else
	{
		throw 'err in parsing config file'
	}
	return section;	
}
// Reads and parses config file and updates Config object
// @callback - function (err)
Config.prototype.readFile = function (callback)
{
	var config = this;
	fs.readFile(this.path, function (err, dataBuffer) {
		if (err)
		{
			callback(err);
		}
		else
		{
			var data = dataBuffer.toString();
			var lines = data.split('\n');
			
			var i = 0;
			var section = null;

			for (i = 0; i < lines.length; ++i)
			{
				var line = removeComments(lines[i].trim());

				if (line.length === 0 || line[0] === ';'
					|| line[0] === '#')
				{

				}
				else if (line[0] === '[')
				{
					section = parseSectionName(line);
				}
				else
				{
					var res = readVariable(line);
					config.updateVariable(section + '.' + res[0], res[1]);	
				}
			}
			callback(null);
		}
	});
	
}

// Modifies config file, it can: remove line, add new line(s) (at specified position),
//  modify specified line
// @param lines - config file content splitted by new line character
// @param lineIndex - index of line to modify
// @param operation - what we want to do: 'add' or 'modfiy' or 'remove'
// @param data - string to insert at specified position, can be null
// @param callback - function (err)
Config.prototype.modifyConfig = function (lines, lineIndex, operation, data, callback)
{
	
	var newConfigData = lines.slice(0, lineIndex + 1);
	
	if (operation === 'add')
	{
		newConfigData.push(data);
	}
	else if (operation === 'modify')
	{
		newConfigData[newConfigData.length-1] = data;
	}
	else //operation === remove
	{
		newConfigData.pop();
	}
	
	var restOfData = lines.slice(lineIndex + 1);
	newConfigData = newConfigData.concat(restOfData);
	
	var output = '';
	var i;
	for (i = 0; i < newConfigData.length; ++i)
	{
		output += newConfigData[i];
		
		if (i < newConfigData.length - 1)
		{
			output += '\n';
		}
	}

	fs.writeFile(this.path, output, function (err) {
		callback(err);
	});
}

// Takes key and gives it's section and variableName
// @param key - full variable name (f.e. branch.master.remote)
function parseKey(key)
{
	var i = key.lastIndexOf('.');
	var section = key.slice(0, i);
	var variableName = key.slice(i + 1);
	return [section, variableName]
}

// Takes section and creates section header (f.e. [branch "devel"] )
// @param section - (sub)section format in dot notation
function sectionToBracketFormat(section)
{
	if (section.indexOf('.') === -1)
	{
		var temp = '[' + section + ']';
		return temp;
	}
	else
	{
		var res = utils.splitByFirst(section, '.');
		var mainSection = res[0];
		var subsection = res[1];
		var temp = '[' + mainSection + ' \"' + subsection + '\"' + ']';
		return temp;
	}
	
}

// Reads config file, and looks for line, which gives verify(section, line) === true
// @param verify - function (section, line) indicates whether we found line we want
// @param callback - function (err, lineIndex, fileContent)
Config.prototype.findLine = function (verify, callback)
{
	var config = this;
	fs.readFile(this.path, function (err, dataBuffer) {
		if (err)
		{
			callback(err, null, null);
		}
		else
		{
			var data = dataBuffer.toString();
			var lines = data.split('\n');
			var i = 0;
			var section = null;
			var indexFound = -1;
			
			for (i = 0; i < lines.length && indexFound === -1; ++i)
			{
				var line = removeComments(lines[i].trim());
				if (line.length === 0 || line[0] === ';'
					|| line[0] === '#')
				{

				}
				else {
					if (line[0] === '[')
					{
						section = parseSectionName(line);
					}
					
					if (verify(section, line))
					{
						indexFound = i;
					}
				}

			}
			callback(null, indexFound, data);
		}
	});
}


// Method to find line which contains assignment to given key
// @param key - variable full name, f.e. branch.master.remote
// @param callback - function (err, lines, lineIndex);
Config.prototype.findVariable = function (key, callback)
{
	var j = key.lastIndexOf('.');
	var sectionToModify = key.substr(0, j);
	
	var variableName = key.slice(1 + j);
	
	var verify = function(section, line)
	{
		var res = readVariable(line);
		//return [variableName, variableValue];	
		if (section && section === sectionToModify && key === (section + '.' + res[0]))
		{
			return true;
		}
		return false;
	};
	
	this.findLine(verify, function (err, lineIndex, fileContent) {
		if (err)
		{
			callback(err, null, null);
		}
		else
		{
			var lines = fileContent.split('\n');
			callback(err, lines, lineIndex);
		}
	});
}


// Reads config file and returns dictionary with all variables and values
// @param callback - function (err, options), options is dictionary
Config.prototype.getAllOptions = function (callback)
{
	var config = this;
	this.readFile(function (err) {
		if (err) 
		{ 
			callback(err, null);
		}
		else
		{
			callback(null, config.variables);
		}
	});
	
}

// Reads config file and returns given option value
// @param callback - function (err, option)
Config.prototype.getOption = function (variableName, callback)
{
	this.getAllOptions (function (err, options) {
		if (err) 
		{ 
			callback(err, null);
		}
		else
		{
			callback(err, options[variableName]);
		}
	});
}

// Adds new variable (or next value of variable, if it can have multiple values)
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - string with value to set
// @param callback - function (err);
Config.prototype.addOption = function (key, variableValue, callback)
{
	var res = parseKey(key);
	var sectionToModify = res[0];
	var variableName = res[1];	
	var dataToWrite = '        ' + variableName + ' = ' + variableValue;
	
	var verify = function(section, line) {
		return (sectionToModify === section);
	};
	
	var config = this;
	this.findLine(verify, function (err, lineIndex, fileContent)
	{
		var lines = fileContent.split('\n');
		
		if (lineIndex === -1)
		{
			var bracket = sectionToBracketFormat(sectionToModify);
			dataToWrite = bracket + '\n' + dataToWrite;
			lineIndex = lines.length;
		}
		
		config.modifyConfig(lines, lineIndex, 'add', dataToWrite, function (err){
			callback(err);
		});
	});
	
}

// Updates option's value
// @param key - variable full name, f.e. branch.master.remote
// @param variableValue - string with value to set
// @param callback - function (err);
Config.prototype.updateOption = function (key, variableValue, callback)
{
	var config = this;
	config.findVariable(key, function(err, lines, lineIndex) {
		var res = parseKey(key);
		var sectionToModify = res[0];
		var variableName = res[1];
		
		var dataToWrite = '        ' + variableName + ' = ' + variableValue;
		
		
		if (lineIndex === -1)
		{
			callback('option not found');
			
		}
		else
		{
			config.modifyConfig(lines, lineIndex, 'modify', dataToWrite, function (err){
				callback(err);
			});
		}
	});
}

// Removes variable
// @param key - variable full name, f.e. branch.master.remote
// @param callback - function (err);
Config.prototype.removeOption = function (key, callback)
{
	var config = this;
	this.findVariable(key, function(err, lines, lineIndex) {
		if (lineIndex === -1)
		{
			callback('option not found');
		}
		else
		{
			config.modifyConfig(lines, lineIndex, 'remove', null, function (err){
				callback(err);
			});
		}
	});
}

exports.Config = Config;