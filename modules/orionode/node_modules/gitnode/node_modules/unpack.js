
var clone = require('clone.js');
var zlib = require('zlib')
var utils = require('utils')

//copied from pack file:
//

var types = { 
	0 : 'invalid',
	1 : 'commit',
	2 : 'tree',
	3 : 'blob',
	4 : 'tag',
	5 : 'invalid',
	6 : 'delta1',
	8 : 'delta2'
}

//  Decodes encoded length. If the most sign. bit is set - read next byte
// @param buffer - delta encoded objects
// @param objectOffset - index of object's first byte in pack file
// returns pair: number of bytes read, length
function getIntLE128Base(buffer, bufferIndex)
{
	var moreFlag = 1;
	var length = 0;
	var coeff = 1;
	while (moreFlag !== 0)
	{
		var nextByte = buffer[bufferIndex];
		bufferIndex += 1;
		moreFlag = nextByte & 128;
		var lengthBits = nextByte & (~128);
		length += lengthBits * coeff;
		coeff *= 64;// *2^6
	}
	return [bufferIndex, length];
}


var getLenType = function(buffer)
{
    var index = 0;
    var firstByte = buffer[index];
    index += 1;

    var length = firstByte & (1 + 2 + 4 + 8);//bits 0-3
    var typeCode = (firstByte & (16 + 32 + 64)) / 16;//bits 6-4
    var type = types[typeCode];
    var moreFlag = (firstByte & 128)/128;
    var coeff = 16;
    while (moreFlag !== 0)
    {
            var nextByte = buffer[index];
            index += 1;
            moreFlag = nextByte & 128;
            var lengthBits = nextByte & (~128);
            length += lengthBits * coeff;
            coeff *= 64;// *2^6
    }
    return [type, index, length];
}

var checkSignature = function(data)
{
    var toComp = new Buffer("PACK");
    for(var i = 0; i < toComp.length; i++)
    {
        if(data[i] != toComp[i])
            return false
    }
    return true;
}

var read4ByteNetwOrd = function(buf)
{
    var res = 0;
    for(var i = 0; i < 4; i++)
    {
        res *= 256; //16^2
        res += buf[i];
    }
    return res;
}

var prefix = function(pref, buf)
{
    for(var i = 0; i < pref.length; i++)
    {
        if(pref[i] != buf[i])
            return false;
    }
    return true;
}


var seek = function(objData, cutData, elems, parsed, lvl, prevs, callback)
{
    console.log("Seek called with: elems: "+ elems+" parsed: "+parsed+ " lvl: "+lvl);
    if(parsed == elems)
    {
        if(cutData.length == 20)
        {
            callback(prevs);
            return;
        }
        else
        {
            console.log('Lost some info');
            wrongCompression(objData, elems, lvl, callback)();
        }
    }
    var len = getLenType(cutData, 0);
    console.log(len);
    var inflatedLength = len[2];
    var cut = len[1];
    var ans = [];
    var inflate = zlib.createInflate();
    cutData = cutData.slice(cut, cutData.length);
    inflate.on('end', function(){
        var last = Buffer.concat(ans);
        console.log(last.length);
        console.log(last.toString());
        if(last.length != inflatedLength)
        {
            //wrongCompression()
            console.log(last.toString());
            console.log('Wrong inflation ' + last.length + " != " + inflatedLength);
            //throw 'Wrong inflation ' + last.length + " != " + inflatedLength;
        }
        utils.deflateOpts(last, function(err, deflatedData){
            if(err)
                throw err;
            else
            {
                if((!prefix(deflatedData, cutData)) || elems < parsed)
                {
                    console.log('Prefix doesent match');
                    wrongCompression(objData, elems, lvl, callback)(); //YUP, calling closure;
                }
                else
                {
                    prevs.push(last);
                    console.log("CUTTING " + deflatedData.length+ "   " + cutData.length);
                    seek(objData, cutData.slice(deflatedData.length, cutData.length),
                    elems, parsed+1, lvl, prevs, callback);
                }
            }
        }, {level : lvl} );
    });
    inflate.on('data', function(data){
        console.log("DATA length: " +data.length+ " for elem: "+(parsed+1));
        ans.push(data);
    });
    inflate.on('error', wrongCompression(objData, elems, lvl, callback));
    inflate.on('drain', function(){
        console.log('drain');
    });
    inflate.on('finish', function(){
        console.log('finish');
    });
    inflate.write(cutData);
    var i = -1;
    for(var j = 0; j < 100000000; j++) 
        i++;
    inflate.end();
}


var wrongCompression = function(objData, elems, level, callback)
{
    var l = level;
    var o = objData;
    var e = elems;
    return function()
    {
        if(l == 9)
            throw 'pack decompression failed';
        else
        {
            console.log('Decompression error');
            seek(o, o, e, 0, l+1, [], callback);
        }
    }
    
}

var callSeek = function(objData, elems, callback)
{
    seek(objData, objData, elems, 0, -1, [], callback);
}


var createIndex = function(pack)
{
    //check for signature
    if(!checkSignature(pack))
        throw 'this is not a packfile';
    var version = read4ByteNetwOrd(pack.slice(4, 8));
    var elems = read4ByteNetwOrd(pack.slice(8, 12));
    //na pohybel!
    var objData = pack.slice(12, pack.length);
    var indx = 0;
    var len = getLenType(objData);
    //console.log(len);
    console.log(pack.slice(0, 40));
    callSeek(objData, elems, function(data){
        console.log(data.length);
    });
}

var test = function(packs)
{
    var fs = require('fs');
    var pck = fs.readFileSync("pack.pack");
    console.log(prefix(pck, packs[0]));
    console.log(prefix(packs[0], pck));
    createIndex(packs[0]);
}

clone.getPack('git://github.com/kyloel/clone.git', test);