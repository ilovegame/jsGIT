//copy to get exact length of data?
//var data = new Buffer(data);
//NOW fileDataTo... NEED TO GET AN UNMODIFIED BUFFER WITH FILE CONTENTS

//api somewhat similiar to node.js's fs
var fs = require('fs');
var co = require('crypto')
var zlib = require('zlib')

//"Convienience method with optional 'options' parameter"
//calback(err, deflatedData)
var deflateOpts = function(data, callback, options)
{
    //set default options for 1
    options = options || {};
    options.level = options.level || 1;
    // create a new deflate object
    var deflate = zlib.createDeflate(options); 
    var buffers=[];
       
    // attach event handlers...
    deflate.on('error', function(err) {
        callback(err);
        deflate.removeAllListeners();
        deflate=null;
    });

    deflate.on('data', function(chunk) {
        buffers.push(chunk);
    });

    deflate.on('end', function() {
        var endBuffer = Buffer.concat(buffers);
        deflate.removeAllListeners();
        deflate=null;

        // return the buffer to callback
        callback(err, endBuffer);
    });

    // pass the data
    deflate.write(data);
    deflate.end();
}

//deflate and save to file at once
var deflateOptsToFile = function(data, filePath, options)
{
    options = options || {};
    options.level = options.level || 1;
    var fileStream = fs.createWriteStream(filePath);
    var deflate = zlib.createDeflate(options); 
    //pipe data from deflate (readStream) to fileStream (writeStream);
    deflate.pipe(fileStream);
    //send the data
    deflate.write(data);
    deflate.end();
}


//uncompressedBlob coud be ignored? is it necessery to write 
//fileDataToSha1 (without blob data)?
//callback(err, sha1, uncompressedBlob)
var fileDataToSha1UCBlob = function(data, callback)
{
    var shasum = co.createHash('sha1');
    var header = 'blob '+data.length+'\0';
    var head = new Buffer(header);
    var store = Buffer.concat([head, data]);
    shasum.update(store);
    var sha = shasum.digest('hex');
    callback(err, sha, store);
}

//callback(err, sha1, uncompressedBlob)
var fileToSha1UCBlob = function(path, callback)
{
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToSha1UCBlob(data, callback);
    });
}

//calback(err, sha1, blob) 
//options - zlib options (optional argument)
var fileDataToBlob = function(data, callback, options)
{
    options = options || {};
    var shasum = co.createHash('sha1');
    
    var header = 'blob '+data.length+'\0';
    var head = new Buffer(header);
    var store = Buffer.concat([head, data]);
    shasum.update(store);
    var sha = shasum.digest('hex');
    deflateOpts(store, function(err, blob) {
        if(err) throw err;
        callback(err, sha, blob);
    }, options);
}

//calback(err, sha1, blob) 
//options - zlib options (optional argument)
var fileToBlob = function(path, callback, options)
{
    options = options || {};
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToBlob(data, callback, options);
    });
}

//options - zlib options 
var saveFileAsBlob = function(filePath, repoPath, options)
{
    options = options || {};
    
}

var saveFileDataAsBlob = function(data, repoPath, options)
{
    
}
exports.fileToBlob = fileToBlob;


/////**
// * callback(blob_content, sha1)
// */
//var fileToBlob_async = function(path, callback)
//{
//    absolute = ph.resolve(path); 
//    
//}
//
///**
// * Container for file with blob object factory
// * @param 
// */
//var fileContainer = function(path)
//{
//    this.path = ph.resolve(path); 
//    fs.readFile(this.path, function (err, data) {
//        if (err) throw err;
//        //jak wczytaæ plik
//        var shasum = co.createHash('sha1');
//        header = "blob #"+data.length
//        shasum.update(data);
//        var d = shasum.digest('hex');
//    });
//}
//
//
///* Lazy definition function pattern
// * http://michaux.ca/articles/lazy-function-definition-pattern
// var foo = function() {
//    var t = new Date();
//    foo = function() {
//        return t;
//    };
//    return foo();
//};
// */
//fileContainer.prototype =
//{
//    content: function(callback)
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            callback(data);
//        });
//    },
//    content_lazy : function()
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            this.content_lazy = function()
//            {
//                
//            }
//            callback(data);
//        });
//    },
//    
//    SHA1: function(callback)
//    {
//        var shasum = co.createHash('sha1');
//    }
//    
//    
//}

