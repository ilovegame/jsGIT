//copy to get exact length of data?
//var data = new Buffer(data);
//NOW fileDataTo... NEED TO GET AN UNMODIFIED BUFFER WITH FILE CONTENTS

//api somewhat similiar to node.js's fs
var fs = require('fs');
var ph = require('ph');
var co = require('crypto')
var zlib = require('zlib')

/**
 * "Convienience method" for deflate with easy access to compresion options.
 * @param data 
 * @param calback function(err, deflatedData)
 * @param options optional, default level set to 1
 */
var deflateOpts = function(data, callback, options)
{
    //set default options for 1
    options = options || {};
    options.level = options.level || 1;
    // create a new deflate object
    var deflate = zlib.createDeflate(options); 
    var buffers=[];
       
    // attach event handlers...
    deflate.on('error', function(err) {
        callback(err);
        deflate.removeAllListeners();
        deflate=null;
    });

    deflate.on('data', function(chunk) {
        buffers.push(chunk);
    });

    deflate.on('end', function() {
        var endBuffer = Buffer.concat(buffers);
        deflate.removeAllListeners();
        deflate=null;

        // return the buffer to callback
        callback(err, endBuffer);
    });

    // pass the data
    deflate.write(data);
    deflate.end();
}


/**
 * "Convienience method" for deflate with easy access to compresion options.
 * Deflate and save to file at once.
 * @param data
 * @param filePath
 * @param options optional, default level set to 1
 */
var deflateOptsToFile = function(data, filePath, options)
{
    options = options || {};
    options.level = options.level || 1;
    var fileStream = fs.createWriteStream(filePath);
    var deflate = zlib.createDeflate(options); 
    //pipe data from deflate (readStream) to fileStream (writeStream);
    deflate.pipe(fileStream);
    //send the data
    deflate.write(data);
    deflate.end();
}

/**
 * Closure to create fileDataToSha1 and fileDataToSha1Store functions
 * @param onlySha1 true if not to returne Store - (not deflated blob data)
 * @return apropriate function
 */
var _fileDataToSha1andStore = function(onlySha1){
    var cond = onlySha1;
    var fDToSha1Store = function(data, callback)
    {
        var shasum = co.createHash('sha1');
        var header = 'blob '+data.length+'\0';
        var head = new Buffer(header);
        var store = Buffer.concat([head, data]);
        shasum.update(store);
        var sha = shasum.digest('hex');
        if(cond)
        {
            callback(err, sha);
        }
        else
        {
            callback(err, sha, store);
        }
    }
    return fDToSha1Store;
}



/**
 * Calculates SHA1 of "blob_header space null_byte file_data"
 * @param data Buffer with file data, must have exact length to file
 * @param callback function(err, sha1)
 */
var fileDataToSha1 = _fileDataToSha1andStore(true);

/**
 * Calculates SHA1 of "blob_header space null_byte file_data"
 * @param data Buffer with file data, must have exact length to file
 * @param callback function(err, sha1, uncompressed_blob)
 */
var fileDataToSha1Store = _fileDataToSha1andStore(false);

//callback(err, sha1)
/**
 * Calculates SHA1 of "blob_header space null_byte file_data"
 * @param path 
 * @param callback function(err, sha1)
 */
var fileToSha1 = function(path, callback)
{
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToSha1(data, callback);
    });
}



/**
 * Calculates SHA1 of "blob_header space null_byte file_data"
 * @param path
 * @param callback function(err, sha1, uncompressed_blob)
 */
var fileToSha1Store = function(path, callback)
{
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToSha1Store(data, callback);
    });
}

/**
 * Calculates SHA1 and blob from data
 * @param data Buffer with file data, must have exact length to file
 * @param callback function(err, sha1, blob) 
 * @param options zlib options (optional argument)
 */
var fileDataToBlob = function(data, callback, options)
{
    options = options || {};
    //get sha and store
    fileDataToSha1Store(data, 
        function(err, sha1, store){
            if(err) callback(err);
            //deflate it and pass to callback
            deflateOpts(store, function(err, blob) {
                    //if(err) callback(err);
                    callback(err, sha1, blob);
                }, options);
        }
    );
}

/**
 * Calculates SHA1 and blob of file at path
 * @param path
 * @param callback function(err, sha1, blob) 
 * @param options zlib options (optional argument)
 */
var fileToBlob = function(path, callback, options)
{
    options = options || {};
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToBlob(data, callback, options);
    });
}

/**
 * Check if object with sha1 hash is new object and if so create new file for it
 * @param sha1 hash of object
 * @param repoPath path to .git
 * @param callback function(boolean) gets true if object was new and file
 * was created, otherwise false
 */
var checkSha1Path = function(sha1, repoPath, callback)
{
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    fs.exists(dir, function(dirExists){
        if(dirExists)
        {
            fs.exists(file, function(fileExists){
                if(fileExists)
                {
                    callback(false);
                }
                else
                {
                    fs.open(file, 'w', function(err, fd){
                        fs.close(fd, function(err){
                            if(err) throw err;
                            callback(true);
                        });
                    });
                }
            });
        }
        else
        {
            //isn't mode necessary?
            fs.mkdir(dir, function(err){
                if(err) throw err;
                fs.open(file, 'w', function(err, fd){
                    fs.close(fd, function(err){
                        if(err) throw err;
                        callback(true);
                    });
                });
            })
        }
    });
}


/**
 * Create path to git object
 * @param sha1 hash code of git object
 * @param repoPath path to .git (repo)
 * @return repoPath/sha1[0..1]/sha1[2..]/
 */
var getFilePath = function(sha1, repoPath){
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    return file;
}

/**
 * Creates blob from buffer and stores it in repo
 * @param data Buffer with file data, must have exact length to file
 * @param repoPath path to .git folder f.e. /my_project/.git/
 * @param options optional zlib compression options
 */
var saveFileDataAsBlob = function(data, repoPath, options)
{
    options = options || {};
    fileDataToSha1Store(data, function(err, sha1, store){
        if(err) throw err;
        checkSha1Path(sha1, repoPath, function(fileIsUnique){
            if(fileIsUnique)
                deflateOptsToFile(store, getFilePath(sha1), options);
        });
    });
}

/**
 * Reads file and saves it in repo as blob using optional options.
 * @param filePath path to file
 * @param repoPath path to .git folder f.e. /my_project/.git/
 * @param options optional zlib compression options
 */
var saveFileAsBlob = function(filePath, repoPath, options)
{
    options = options || {};
    fs.readFile(filePath, function (err, data) {
        if(err) callback(err);
        saveFileDataAsBlob(data, repoPath, options);
    });
}

/**
 * Produce buffer with file contents from given blob buffer
 * @param data
 * @param callback function(err, fileDataBuffer)
 */
var blobDataToFile = function(data, callback)
{
    zlib.inflate(data, function(err, buffer) {
        var i = 0;
        while(buffer[i] != 0)
        {
            i++;
        }
        var fileBuffer = buffer.slice(i);
        callback(err, fileBuffer); 
    });
}

/**
 * Produce buffer with file contents for given blob object
 * @param sha1 hash of blob object
 * @param repoPath
 * @param callback function(err, fileBuffer)
 */
var blobObjectToFile = function(sha1, repoPath, callback)
{
    fs.readFile(getFilePath(sha1, repoPath), function (err, data) {
        if(err) callback(err);
        zlib.inflate(data, function(err, buffer) {
            var i = 0;
            while(buffer[i] != 0)
            {
                i++;
            }
            var fileBuffer = buffer.slice(i);
            callback(err, fileBuffer); 
        });
    });
}

exports.blobDataToFile = blobDataToFile;
exports.blobObjectToFile = blobObjectToFile;
exports.checkSha1Path = checkSha1Path;
exports.deflateOpts = deflateOpts;
exports.deflateOptsToFile = deflateOptsToFile;
exports.fileDataToBlob = fileDataToBlob;
exports.fileDataToSha1 = fileDataToSha1;
exports.fileToBlob = fileToBlob;
exports.fileToSha1 = fileToSha1;
exports.getFilePath = getFilePath;
exports.saveFileAsBlob = saveFileAsBlob;
exports.saveFileDataAsBlob = saveFileDataAsBlob;
///**
// * callback(blob_content, sha1)
// */
//var fileToBlob_async = function(path, callback)
//{
//    absolute = ph.resolve(path); 
//    
//}
//
///**
// * Container for file with blob object factory
// * @param 
// */
//var fileContainer = function(path)
//{
//    this.path = ph.resolve(path); 
//    fs.readFile(this.path, function (err, data) {
//        if (err) throw err;
//        //jak wczytaÄ‡ plik
//        var shasum = co.createHash('sha1');
//        header = "blob #"+data.length
//        shasum.update(data);
//        var d = shasum.digest('hex');
//    });
//}
//
//
///* Lazy definition function pattern
// * http://michaux.ca/articles/lazy-function-definition-pattern
// var foo = function() {
//    var t = new Date();
//    foo = function() {
//        return t;
//    };
//    return foo();
//};
// */
//fileContainer.prototype =
//{
//    content: function(callback)
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            callback(data);
//        });
//    },
//    content_lazy : function()
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            this.content_lazy = function()
//            {
//                
//            }
//            callback(data);
//        });
//    },
//    
//    SHA1: function(callback)
//    {
//        var shasum = co.createHash('sha1');
//    }
//    
//    
//}

