//copy to get exact length of data?
//var data = new Buffer(data);
//NOW fileDataTo... NEED TO GET AN UNMODIFIED BUFFER WITH FILE CONTENTS

//api somewhat similiar to node.js's fs
var fs = require('fs');
var ph = require('ph');
var co = require('crypto')
var zlib = require('zlib')

//"Convienience method with optional 'options' parameter"
//calback(err, deflatedData)
var deflateOpts = function(data, callback, options)
{
    //set default options for 1
    options = options || {};
    options.level = options.level || 1;
    // create a new deflate object
    var deflate = zlib.createDeflate(options); 
    var buffers=[];
       
    // attach event handlers...
    deflate.on('error', function(err) {
        callback(err);
        deflate.removeAllListeners();
        deflate=null;
    });

    deflate.on('data', function(chunk) {
        buffers.push(chunk);
    });

    deflate.on('end', function() {
        var endBuffer = Buffer.concat(buffers);
        deflate.removeAllListeners();
        deflate=null;

        // return the buffer to callback
        callback(err, endBuffer);
    });

    // pass the data
    deflate.write(data);
    deflate.end();
}

//deflate and save to file at once
var deflateOptsToFile = function(data, filePath, options)
{
    options = options || {};
    options.level = options.level || 1;
    var fileStream = fs.createWriteStream(filePath);
    var deflate = zlib.createDeflate(options); 
    //pipe data from deflate (readStream) to fileStream (writeStream);
    deflate.pipe(fileStream);
    //send the data
    deflate.write(data);
    deflate.end();
}


//uncompressedBlob coud be ignored? is it necessery to write 
//fileDataToSha1 (without blob data)?
//callback(err, sha1, uncompressedBlob)
var fileDataToSha1Store = function(data, callback)
{
    var shasum = co.createHash('sha1');
    var header = 'blob '+data.length+'\0';
    var head = new Buffer(header);
    var store = Buffer.concat([head, data]);
    shasum.update(store);
    var sha = shasum.digest('hex');
    callback(err, sha, store);
}

//callback(err, sha1, uncompressedBlob)
var fileToSha1Store = function(path, callback)
{
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToSha1Store(data, callback);
    });
}

//calback(err, sha1, blob) 
//options - zlib options (optional argument)
var fileDataToBlob = function(data, callback, options)
{
    options = options || {};
    //get sha and store
    fileDataToSha1Store(data, 
        function(err, sha1, store){
            if(err) callback(err);
            //deflate it and pass to callback
            deflateOpts(store, function(err, blob) {
                    //if(err) callback(err);
                    callback(err, sha1, blob);
                }, options);
        }
    );
}

//calback(err, sha1, blob) 
//options - zlib options (optional argument)
var fileToBlob = function(path, callback, options)
{
    options = options || {};
    fs.readFile(path, function (err, data) {
        if(err) callback(err);
        fileDataToBlob(data, callback, options);
    });
}

//passes true to callbac if file was created
var checkSha1Path = function(sha1, repoPath, callback)
{
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    fs.exists(dir, function(dirExists){
        if(dirExists)
        {
            fs.exists(file, function(fileExists){
                if(fileExists)
                {
                    callback(false);
                }
                else
                {
                    fs.open(file, 'w', function(err, fd){
                        fs.close(fd, function(err){
                            if(err) throw err;
                            callback(true);
                        });
                    });
                }
            });
        }
        else
        {
            //isn't mode necessary?
            fs.mkdir(dir, function(err){
                if(err) throw err;
                fs.open(file, 'w', function(err, fd){
                    fs.close(fd, function(err){
                        if(err) throw err;
                        callback(true);
                    });
                });
            })
        }
    });
}

var getFilePath = function(sha1, repoPath){
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    return file;
}

//options - zlib options 
var saveFileDataAsBlob = function(data, repoPath, options)
{
    options = options || {};
    fileDataToSha1Store(data, function(err, sha1, store){
        if(err) throw err;
        checkSha1Path(sha1, repoPath, function(fileIsUnique){
            if(fileIsUnique)
                deflateOptsToFile(store, getFilePath(sha1), options);
        });
    });
    
}

//options - zlib options 
var saveFileAsBlob = function(filePath, repoPath, options)
{
    options = options || {};
    fs.readFile(filePath, function (err, data) {
        if(err) callback(err);
        saveFileDataAsBlob(data, repoPath, options);
    });
}





/////**
// * callback(blob_content, sha1)
// */
//var fileToBlob_async = function(path, callback)
//{
//    absolute = ph.resolve(path); 
//    
//}
//
///**
// * Container for file with blob object factory
// * @param 
// */
//var fileContainer = function(path)
//{
//    this.path = ph.resolve(path); 
//    fs.readFile(this.path, function (err, data) {
//        if (err) throw err;
//        //jak wczytaæ plik
//        var shasum = co.createHash('sha1');
//        header = "blob #"+data.length
//        shasum.update(data);
//        var d = shasum.digest('hex');
//    });
//}
//
//
///* Lazy definition function pattern
// * http://michaux.ca/articles/lazy-function-definition-pattern
// var foo = function() {
//    var t = new Date();
//    foo = function() {
//        return t;
//    };
//    return foo();
//};
// */
//fileContainer.prototype =
//{
//    content: function(callback)
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            callback(data);
//        });
//    },
//    content_lazy : function()
//    {
//        fs.readFile(this.path, function (err, data) {
//            if (err) throw err;
//            this.content_lazy = function()
//            {
//                
//            }
//            callback(data);
//        });
//    },
//    
//    SHA1: function(callback)
//    {
//        var shasum = co.createHash('sha1');
//    }
//    
//    
//}

