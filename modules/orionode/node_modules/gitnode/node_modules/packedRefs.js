/*******************************************************************************
 * Object for managing packed refs in .git/packed-refs
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');

/**
 * Constructor for PackedRefs object
 * @param path path to .git folder
 * @param callback callback(err)
 */
function PackedRefs(path, callback) {
	this.path = path;
	this.branches = new Array();
	this.tags = new Array();
	var packedRefsObject = this;
	fs.exists(this.path + '/packed-refs', function(exists) {
		if (exists) {
			packedRefsObject.parse(function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
		} else {
			callback('');
			return;
		}
	});
}

/**
 * Parses .git/packed-refs file and makes structures
 * @param callback callback(err)
 */
PackedRefs.prototype.parse = function(callback) {
	var packedRefsObject = this;
	var lastAddedPath;
	fs.readFile(this.path + '/packed-refs', function (err, fileContent) {
		if (err) {
			callback(err);
			return;
		}
		var index = 0;

		while (index < fileContent.length) {
			if (fileContent.toString('utf8', index, index + 1) == '#') {
				index = packedRefsObject.goToNextRow(fileContent, index);
				
				continue;
			}

			if (fileContent.toString('utf8', index, index + 1) == '^') {
				++index;
				var objectPointedSHA_1 = fileContent.toString('utf8', index,
					index + 40);
				index += 40;
				packedRefsObject.tags[lastAddedPath]['objectPointedSHA_1'] = objectPointedSHA_1;
			} else {
				var objectSHA_1 = fileContent.toString('utf8', index,
					index + 40);
				index += 41;
			
				var path = '';
				while (fileContent.toString('utf8', index, index + 1) != '\n') {
					path += fileContent.toString('utf8', index, index + 1);
					++index;
				}
				if (path.slice(5, 9) == 'tags') {
					lastAddedPath = path;
					var newTag = new Array();
					newTag['SHA_1'] = objectSHA_1;
					newTag['objectPointedSHA_1'] = null;
					packedRefsObject.tags[path] = newTag;	
				} else {
					packedRefsObject.branches[path] = objectSHA_1;
				}
			}
			++index;
		}
		callback('');
		return;
	});
};

/**
 * Moves index pointer to the first char in the next line
 * @param fileContent text data
 * @param index current position in the data
 */
PackedRefs.prototype.goToNextRow = function(fileContent, index) {
	while (index < fileContent.length &&
		fileContent.toString('utf8', index, index + 1) != '\n') {
		++index;
	}
	++index;

	return index;
}

/**
 * Gets name from patch
 * @param path path of the file
 */
PackedRefs.prototype.getName = function(path) {
	var words = path.split('/');

	return words[words.length - 1];
}

/**
 * Gets path name to display
 * @param path path of the file
 */
PackedRefs.prototype.getPathToDisplay = function(path) {
	var words = path.split('/');
	words.shift();
	
	if (words[0] == 'heads' || words[0] == 'tags') {
		words.shift();
	}
	
	words = words.join('/');


	return words;
}

/**
 * Gets all branches names placed in .git/packed-refs file
 * @param callback callback(branchesNames)
 */
PackedRefs.prototype.getBranchesNames = function(callback) {
	var names = new Array();
	for (var path in this.branches) {
		var name = this.getPathToDisplay(path);
		names.push(name);
	}

	callback(names);
	return;
}

/**
 * Adds branch to .git/packed-refs file
 * @param SHA_1 SHA_1 connected with the branch
 * @param path to the branch
 * @param callback callback()
 */
PackedRefs.prototype.addBranch = function(SHA_1, path, callback) {
	this.branches[path] = SHA_1;

	callback();
	return;
}

/**
 * Updates branch in .git/packed-refs file when branch exists
 * and only SHA_1 is changing
 * @param name name of the branch
 * @param SHA_1 new SHA_1
 * @param callback callback(err)
 */
PackedRefs.prototype.updateBranch = function(path, SHA_1, callback) {
	if (path in this.branches) {
		this.branches[path] = SHA_1;

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: branch \'' + path + '\' not found');
    	return;
    }
}

/**
 * Makes new path for existing branch in .git/packed-refs file
 * @param pathOld current path of the branch
 * @param pathNew new path
 * @param callback callback(err)
 */
PackedRefs.prototype.renameBranch = function(pathOld, pathNew, callback) {
	if (pathOld in this.branches) {
		this.branches[pathNew] = this.branches[pathOld];
		delete this.branches[pathOld];

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: branch \'' + pathOld + '\' not found');
    	return;
    }
}

/**
 * Removes branch from .git/packed-refs file
 * @param path path of the branch
 * @param callback callback(err)
 */
PackedRefs.prototype.removeBranch = function(path, callback) {
	if (path in this.branches) {
		delete this.branches[path];

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: branch \'' + path + '\' not found');
    	return;	
    }
}

/**
 * Gets all tags names placed in .git/packed-refs file
 * @param callback callback(tagsNames)
 */
PackedRefs.prototype.getTagsNames = function(callback) {
	var names = new Array();
	for (var path in this.tags) {
		var name = this.getPathToDisplay(path);
		names.push(name);
	}

	callback(names);
	return;
}

/**
 * Adds tag to .git/packed-refs file
 * @param SHA_1 SHA_1 connected with the tag
 * @param path to the tag
 * @param callback callback()
 */
PackedRefs.prototype.addTag = function(SHA_1, path, objectPointedSHA_1,
	callback) {
	var newTag = new Array();
	newTag['SHA_1'] = SHA_1;
	newTag['objectPointedSHA_1'] = objectPointedSHA_1;
	this.tags[path] = newTag;

	callback();
	return;
}

/**
 * Updates tag in .git/packed-refs file when tag exists
 * and only SHA_1 is changing
 * @param path path of the tag
 * @param SHA_1 new SHA_1
 * @param callback callback(err)
 */
PackedRefs.prototype.updateTag = function(path, SHA_1, callback) {
	if (path in this.tags) {
		this.tags[path] = SHA_1;

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: tag \'' + path + '\' not found');
    	return;
    }
}

/**
 * Makes new path for existing tag in .git/packed-refs file
 * @param pathOld current path of the tag
 * @param pathNew new path
 * @param callback callback(err)
 */
PackedRefs.prototype.renameTag = function(pathOld, pathNew, callback) {
	if (pathOld in this.tags) {
		this.tags[pathNew] = this.tags[pathOld];
		delete this.tags[pathOld];

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: tag \'' + pathOld + '\' not found');
    	return;
    }
}

/**
 * Removes tag from .git/packed-refs file
 * @param path path of the tag
 * @param callback callback(err)
 */
PackedRefs.prototype.removeTag = function(path, callback) {
	if (path in this.tags) {
		delete this.tags[path];

		this.saveInFile(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	} else {
		callback('error: tag \'' + pathOld + '\' not found');
    	return;	
    }
}

/**
 * Creates .git/packed-refs using inner structures
 * @param callback callback(err)
 */
PackedRefs.prototype.saveInFile = function(callback) {
	var fileContent = '# pack-refs with: peeled ' + '\n';

	for (var path in this.branches) {
		fileContent += this.branches[path] + ' ';
		fileContent += path + '\n';
	}
	for (var path in this.tags) {
		fileContent += this.tags[path].SHA_1 + ' ';
		fileContent += path + '\n';
		fileContent += '^' + this.tags[path].objectPointedSHA_1 + '\n';
	}
	fs.writeFile(this.path + '/packed-refs', fileContent, function (err) {
  		if (err) {
  			callback(err);
  			return;
  		}
  		
  		callback('');
  		return;
	});
}

/**
 * Gets branch name by given SHA_1
 * @param SHA_1 SHA_1 of the branch
 * @param callback callback(x) where x == '' if there is not specified branch
 * in .git/packed-refs file or x is the name if there is a branch
 */
PackedRefs.prototype.getBranchNameUsingSHA_1 = function(SHA_1, callback) {
	for (var path in this.branches) {
		if (this.branches[path] == SHA_1) {
			callback(this.getName(path));
			return;
		}
	}

	callback('');
	return;
}

/**
 * Gets branch SHA_1 by given name
 * @param name name of the branch
 * @param callback callback(x) where x == '' if there is not specified branch
 * in .git/packed-refs file or x is the SHA_1 if there is a branch
 */
PackedRefs.prototype.getBranchSHA_1UsingName = function(name, callback) {
	for (var index in this.branches) {
		if (this.getName(this.branches[index].path) == name) {
			callback(this.branches[index].SHA_1);
			return;
		}
	}

	callback('');
	return;
}

exports.PackedRefs = PackedRefs;
