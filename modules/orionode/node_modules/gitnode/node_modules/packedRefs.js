/*******************************************************************************
 * Object for managing packed refs in .git/packed-refs
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');

/**
 * Constructor for PackedRefs object
 * @param path path to .git folder
 * @param callback callback(err)
 */
function PackedRefs(path, callback) {
	this.path = path;
	this.branches = new Array();
	var packedRefsObject = this;
	fs.exists(this.path, function(exists) {
		if (exists) {
			packedRefsObject.parse(function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
		} else {
			callback('');
			return;
		}
	});
}

/**
 * Parses .git/packed-refs file and makes structure
 * @param callback callback(err)
 */
PackedRefs.prototype.parse = function(callback) {
	var packedRefsObject = this;
	fs.readFile(this.path + '/packed-refs', function (err, fileContent) {
		if (err) {
			callback(err);
			return;
		}
		var index = 0;

		while (index < fileContent.length) {

			if (fileContent.toString('utf8', index, index + 1) == '#') {
				index = packedRefsObject.goToNextRow(fileContent, index);
				
				continue;
			}
			var objectSHA_1 = fileContent.toString('utf8', index, index + 40);
			index += 41;
			
			var path = '';
			while (fileContent.toString('utf8', index, index + 1) != '\n') {
				path += fileContent.toString('utf8', index, index + 1);
				++index;
			}
			++index;
			
			var objectInfo = new Array();
			objectInfo['SHA_1'] = objectSHA_1;
			objectInfo['path'] = path;
			packedRefsObject.branches.push(objectInfo);
		}

		callback('');
		return;
	});
};

/**
 * Moves index pointer to the first char in the next line
 * @param fileContent text data
 * @param index current position in the data
 */
PackedRefs.prototype.goToNextRow = function(fileContent, index) {
	while (index < fileContent.length &&
		fileContent.toString('utf8', index, index + 1) != '\n') {
		++index;
	}
	++index;

	return index;
}

/**
 * Gets name from patch
 * @param path path of the file
 */
PackedRefs.prototype.getName = function(path) {
	var words = path.split('/');

	return words[words.length - 1];
}

/**
 * Gets all branches names placed in .git/packed-refs file
 * @param callback callback(branchesNames)
 */
PackedRefs.prototype.getBranchesNames = function(callback) {
	var names = new Array();
	for (var index in this.branches) {
		var name = this.getName(this.branches[index]['path']);
		names.push(name);
	}

	callback(names);
	return;
}

/**
 * Adds branch to .git/packed-refs file
 * @param SHA_1 SHA_1 connected with he branch
 * @param path to the branch
 * @param callback callback()
 */
PackedRefs.prototype.addBranch = function(SHA_1, path, callback) {
	var newBranch = new Array();
	newBranch['SHA_1'] = SHA_1;
	newBranch['path'] = path;

	this.branches.push(newBranch);

	callback();
	return;
}

/**
 * Creates .git/packed-refs using inner structures
 * @param callback callback(err)
 */
PackedRefs.prototype.saveInFile = function(callback) {
	var fileContent = '# pack-refs with: peeled ' + '\n';

	for (var index in this.branches) {
		fileContent += this.branches[index]['SHA_1'] + ' ';
		fileContent += this.branches[index]['path'] + '\n';
	}
	fs.writeFile(this.path + '/packed-refs', fileContent, function (err) {
  		if (err) {
  			callback(err);
  			return;
  		}
  		
  		callback('');
  		return;
	});
}

/**
 * Gets branch name by given SHA_1
 * @param SHA_1 SHA_1 of the branch
 * @param callback callback(x) where x == '' if there is not specified branch
 * in .git/packed-refs file or x is the name if there is a branch
 */
PackedRefs.prototype.getBranchNameUsingSHA_1 = function(SHA_1, callback) {
	for (var index in this.branches) {
		if (this.branches[index].SHA_1 == SHA_1) {
			callback(this.getName(this.branches[index].path));
			return;
		}
	}

	callback('');
	return;
}

exports.PackedRefs = PackedRefs;
