var commit = require('commit');
var gs = require('gitutils');
var ph = require('path');
var gitDiffCommand = require('gitDiffCommand'); 

// #Getting commit metadata
// @param repoPath - .git dir
// @param sha1 - commit's sha1
// @param callback - function(err, commitObject);
function getCommitMetadata(repoPath, sha1, callback)
{
	commit.readFileToCommit(sha1, repoPath, callback);
}

// Function to compare two commits
function compareCommits(a, b){
	var aTime = a.author.timestamp;
	var bTime = b.author.timestamp;
	if (aTime > bTime)
	{
		return 1;
	}
	else if (aTime === bTime)
	{
		return 0;
	}
	else
	{
		return -1;
	}
}

// Gets dictionary { sha1 : commitObject }, returns sorted array of commits
function sort(dict)
{
	var sorted = [];
	for(var key in dict) {
		sorted.push(dict[key]);
	}
	return sorted.sort(compareCommits);
	
}

// dict : { sha1 : commitObj }
function getCommitAncestors(repoPath, sha1, dict, callback)
{
	commit.readFileToCommit(sha1, repoPath, function(err, commitObj) {
		commitObj.sha1 = sha1;
		if (err)
		{
			callback(err, null);
		}
		else
		{
			if (sha1 in dict)
			{
				callback(null);
			}
			else if (commitObj.parents.length === 0) // root
			{
				dict[sha1] = commitObj;
				callback(null);
			}
			else
			{
				dict[sha1] = commitObj;
				var jobsLeft = commitObj.parents.length;
				var quit = false;
				for (var i = 0; i < commitObj.parents.length; ++i)
				{
					getCommitAncestors(repoPath, commitObj.parents[i], dict, function (err) {
						if (quit) return;
						jobsLeft--;
						if (err)
						{
							quit = true;
							callback(err);
						}
						else if (jobsLeft === 0)
						{
							callback(null);
						}
					});
				}
				
			}
		}
	});
}

function getBranchCommits(repoPath, sha1, callback)
{
	var dict = { };
	getCommitAncestors(repoPath, sha1, dict, function(err) {
		if (err)
		{
			callback(err, null);
		}
		else
		{
			var commits = sort(dict);
			callback(null, commits);
		}
	});
}


function getHeadCommits(repoPath, callback)
{
	//TODO gitutils can be changed!!!
	var path = ph.dirname(repoPath) + '/';
	gs.getHeadSha1(path, function (err, headSha1) {
		if (err)
		{
			callback(err, null);
		}
		else if (!headSha1) //no commit
		{
			callback(null, []);
		}
		else
		{
			getBranchCommits(repoPath, headSha1, callback);
		}
		
	});
	
}

// #Getting file content in a commit
// @param repoPath - path of .git dir
// @param relativeFilePath - file that we want to read
// @param callback - function(err, file)
function getFileFromCommit(repoPath, sha1, relativeFilePath, callback)
{
	gitDiffCommand.getCommitBlobs(repoPath, sha1, function(err, blobs) {
		if (err)
		{
			callback(err, null);
		}
		else
		{
			var fileSha1 = blobs[relativeFilePath]['sha1'];
			//TODO readBlobFile may be in different module
			gitDiffCommand.readBlobFile(repoPath, fileSha1, function(err, file){ 
				if (err)
				{
					callback(err, null);
				}
				else
				{
					callback(null, file);
				}
			});
		}
	});
}

// #Getting a file content from HEAD
// @param repoPath - path of .git dir
// @param relativeFilePath - file that we want to read
// @param callback - function(err, file)
function getFileFromHead(repoPath, relativeFilePath, callback)
{
	var path = ph.dirname(repoPath) + '/'; //TODO
	gs.getHeadSha1(path, function (err, headSha1) {
		if (err)
		{
			callback(err, null);
		}
		else if (!headSha1) //no commit
		{
			callback('no commits at head', null);
		}
		else
		{
			getFileFromCommit(repoPath, headSha1, relativeFilePath, callback);
		}
	});
}

exports.getCommitMetadata = getCommitMetadata;
exports.getHeadCommits = getHeadCommits;
// tag commit ? it's in gitTag
exports.getFileFromCommit = getFileFromCommit;
exports.getFileFromHead = getFileFromHead;