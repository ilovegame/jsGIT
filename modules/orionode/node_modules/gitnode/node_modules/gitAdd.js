var iFM = require('indexFile');
var bM = require('blob.js');
var ph = require('path');
var cPM = require('conflictParser.js');
//CHANGE FOR ASYNC
var gitAddOneFile = function(path, repoPath, callback) {
    var jobsCompleted = 0;
    var jobsAll = 2;
    var indexFileManager = new iFM.Index(repoPath, function() {
        var cParser = new cPM.conflictParser(repoPath);
        cPM.load(repoPath, function(err,cParser) {
            if (!err) {
                cParser.removeConflict(path);
                cParser.save(function(err) {
                    if (err) callback(err);
                });
            }
        });
        
    	indexFileManager.addObject(path, function(err) {
    		if (err) {
    			callback(err);
    			return;
    		}
    		++jobsCompleted;

    		if (jobsCompleted == jobsAll) {
    			callback('');
    			return;
    		}
    	});
    	bM.saveFileAsBlob(ph.join(ph.normalize(repoPath + '..'), path), repoPath, {}, function(err) {
            console.log('olol');
    		if (err) {
    			callback(err);
    			return;
    		}
    		++jobsCompleted;

    		if (jobsCompleted == jobsAll) {
    			callback('');
    			return;
    		}
    	});
    });
}

//CHANGE TO RECURSIVE INSTEAD OF LOOP
var gitAddManyFiles = function(paths, repoPath, callback) {
	var jobsCompleted = 0;
	var jobsAll = paths.length * 2;
    var save = false;
	var indexFileManager = new iFM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
        cPM.load(repoPath, function(err, cParser) {
            if (!err) {
                save = true;
            }
            for(var index in paths) {
                if (!err)
                    cParser.removeConflict(paths[index]);
                indexFileManager.addObject(paths[index], function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    ++jobsCompleted;
                    if (jobsCompleted == jobsAll) {
                        if (save) {
                            cParser.save(function(err) {
                                if (err) callback(err);
                            });   
                        }
                        indexFileManager.createIndexFile(function(err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            callback('');
                            return;
                        });
                    }
                });
                bM.saveFileAsBlob(ph.join(ph.normalize(repoPath + '..'), paths[index]), repoPath, {}, function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    ++jobsCompleted;
                    if (jobsCompleted == jobsAll) {
                        if (save) {
                            cParser.save(function(err) {
                                if (err) callback(err);
                            });   
                        }
                        indexFileManager.creteIndexFile(function(err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            callback('');
                            return;
                        });
                    }
                });
            }
        });
		
	});
}

var gitRemoveOneFile = function(path, repoPath, callback) {
	var indexFileManager = new iFM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
    	indexFileManager.removeObject(path, function(err) {
    		if (err) {
    			callback(err);
    			return;
    		}
    		callback('');
    		return;
    	});
    });
}

//CHANGE TO RECURSIVE INSTEAD OF LOOP
var gitRemoveManyFiles = function(paths, repoPath, callback) {
	var filesRemoved = 0;
	var indexFileManager = new iFM.Index(repoPath, function (err) {
		if (err) {
			callback(err);
			return;
		}
		for(var index in paths) {
			indexFileManager.removeObject(paths[index], function (err) {
				if (err) {
					callback(err);
					return;
				}
				++filesRemoved;
				if (filesRemoved == paths.length) {
					indexFileManager.creteIndexFile(function(err) {
						if (err) {
							callback(err);
							return;
						}
						callback('');
						return;
					});
				}
			});
		}
	});
}

//Not yet complete - How to get content file from blob?
var gitGetFileContent = function(path, callback) {
	var indexFileManager = new iFM.Index(repoPath, function () {
		indexFileManager.getObject(path, function(object) {
			var returnInfo = new Array();
			returnInfo['ContentLength'] = object.size;
			callback(returnInfo);
		});
	});
}

exports.gitAddOneFile = gitAddOneFile;
exports.gitAddManyFiles = gitAddManyFiles;
exports.gitRemoveOneFile = gitRemoveOneFile;
exports.gitRemoveManyFiles = gitRemoveManyFiles;
exports.gitGetFileContent = gitGetFileContent;
