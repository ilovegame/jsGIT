/*******************************************************************************
 * Module for managing .git/index file
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var crypto = require('crypto');

/**
 * Constructor for index manager
 * @param repoPath path to .git folder
 * @param callback callback(err)
 */

function Index (repoPath, callback) {
    this.objects = {};
    this.objectsNumber = 0;
    this.indexPath = repoPath + '/index';
	this.repoPath = repoPath;

    var indexFile = this;
    fs.exists(this.indexPath, function (exists) {
        if (exists) {
            Index.prototype.parse.call(indexFile, function (err) {
                if (err) {
                    callback('', indexFile);
                    return;
                }
                callback('', indexFile);
                return;
            });
        } else {
            callback('', indexFile);
            return;
        }
    });
}

/**
 * Parses index file .git/index and makes structures
 * @param callback callback(err)
 */
Index.prototype.parse = function (callback) {
    this.objects = {};
    var indexFile = this;
    fs.readFile(this.indexPath, function (err, fileIndexContent) {
        if (err) {
            callback(err);
            return;
        }
        var index = 0;
        var signature = fileIndexContent.toString('binary', index, index + 4);
        index += 4;
        var versionNumber = fileIndexContent.readInt32BE(index);
        index += 4;
        var numberOfIndexEntries = fileIndexContent.readInt32BE(index);
        index += 4;

        var stop = fileIndexContent.length - 20;
        while (index < stop) {
            if (indexFile.objectsNumber == numberOfIndexEntries) {
                indexFile.ignoreExtension(fileIndexContent, index, function(err, extensionSize) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    index += extensionSize;
                });
            } else {
                var objectInfo = new Array();
                objectInfo['ctime'] = fileIndexContent.readInt32BE(index);
                index += 4
                objectInfo['ctime_fraction'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['mtime'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['mtime_fraction'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['dev'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['ino'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['mode'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['uid'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['gid'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['size'] = fileIndexContent.readInt32BE(index);
                index += 4;
                objectInfo['SHA_1'] = fileIndexContent.toString('binary', index,
                    index + 20);
                index += 20;
                objectInfo['flag'] = fileIndexContent.readInt16BE(index);
                index += 2;
                var nullEndIndex = 0;
                while (fileIndexContent.toString('binary', index + nullEndIndex,
                    index + nullEndIndex + 1) != '\0') {
                    ++nullEndIndex;
                }
                var path = fileIndexContent.toString('binary', index,
                    index + nullEndIndex);
                objectInfo['path'] = path;

                index += nullEndIndex;
                while (fileIndexContent.toString('binary', index, index + 1)
                    == '\0') {
                    ++index;
                }
                indexFile.objects[path] = objectInfo;
                ++indexFile.objectsNumber;
            }
        }

        callback('');
        return;
    });
}

Index.prototype.ignoreExtension = function(fileIndexContent, index, callback) {
    if (fileIndexContent.toString('binary', index, index + 4) != 'TREE' &&
        fileIndexContent.toString('binary', index, index + 4) != 'REUC') {
        callback('Error during parsing index file', '');
        return;
    }
    index += 4;
    var extensionSize = fileIndexContent.readInt32BE(index);

    callback('', extensionSize + 8);
}

/**
 * Checks if structure has info about object
 * @param path path to file
 * @param callback callback(hasObject)
 */
Index.prototype.hasObject = function (path, callback) {
    var indexFile = this;
    this.getRelativePath(path, function(relativePath){
        callback(relativePath in indexFile.objects);
        return;
    });
}

/**
 * Creates header for index file
 * @param callback callback(header)
 */
Index.prototype.createHeader = function (callback) {
    var header = new Buffer(12);
    header.write('DIRC', 0, 4, 'binary');
    header.writeInt32BE(2, 4);
    header.writeInt32BE(this.objectsNumber, 8);

    callback(header);
    return;
}

/**
 * Creates null bytes, require for index file
 * @param number number of nulls
 * @param callback callback(nulls)
 */
Index.prototype.getNulls = function(number, callback) {
    var nulls = '';
    for (var nullNo = 0; nullNo < number; ++nullNo) {
        nulls += '\0';
    }

    callback(nulls);
    return;
}

/**
 * Creates SHA_1 from data
 * @param data data which SHA_1 will be calculated
 * @param callback callback(SHA_1)
 */
Index.prototype.calculateSHA_1 = function(data, callback) {
    var sha1Creator = crypto.createHash('sha1');
    sha1Creator.update(data.toString('binary'));
    
    callback(sha1Creator.digest());
    return;
}

/**
 * Creates structure with info about object
 * @param path path to file
 * @param callback callback(err, objectInfo)
 */
Index.prototype.createObjectInfo = function (path, callback) {
    var objectInfoSize = 62;
    var pathBuffer = new Buffer(path, 'binary');
    var remainNulls = 8 - ((pathBuffer.length - 2) % 8);

    var indexFile = this;
    fs.stat(path, function (err, stats) {
        if (err) {
            callback(err, '');
            return;
        }
        var objectInfo = new Array();
        var index = 0;
        objectInfo['ctime'] = stats.ctime.getTime() / 1000;
        objectInfo['ctime_fraction'] = 0;
        objectInfo['mtime'] = stats.mtime.getTime() / 1000;
        objectInfo['mtime_fraction'] = 0;
        objectInfo['dev'] = stats.dev;
        objectInfo['ino'] = stats.ino;
        objectInfo['mode'] = stats.mode;
        objectInfo['uid'] = stats.uid;
        objectInfo['gid'] = stats.gid;
        objectInfo['size'] = stats.size;

        fs.readFile(path, function(err, fileAddedContent) {
            if (err) {
                callback(err, '');
                return;
            }
            indexFile.calculateSHA_1(fileAddedContent, function (SHA_1) {
                objectInfo['SHA_1'] = SHA_1;
                objectInfo['flag'] = pathBuffer.length;
                indexFile.getRelativePath(path.toString('binary'), function(relativePath) {
                    objectInfo['path'] = relativePath;
                    callback('', objectInfo);
                    return;
                });
            });
        });
    });
}

/**
 * Prepares data from structure to index file format
 * @param object structure with info
 * @param callback callback(data)
 */
Index.prototype.objectToIndexFormat = function (object, callback) {
    var objectInfoSize = 62;
    var pathBuffer = new Buffer(object['path'], 'binary');
    var remainNulls = 8 - ((pathBuffer.length - 2) % 8);

    var data = new Buffer(objectInfoSize + pathBuffer.length + remainNulls);
    var index = 0;
    data.writeInt32BE(object['ctime'], index);
    index += 4;
    data.writeInt32BE(object['ctime_fraction'], index);
    index += 4;
    data.writeInt32BE(object['mtime'], index);
    index += 4;
    data.writeInt32BE(object['mtime_fraction'], index);
    index += 4;
    data.writeInt32BE(object['dev'], index);
    index += 4;
    data.writeInt32BE(object['ino'], index);
    index += 4;
    data.writeInt32BE(object['mode'], index);
    index += 4;
    data.writeInt32BE(object['uid'], index);
    index += 4;
    data.writeInt32BE(object['gid'], index);
    index += 4;
    data.writeInt32BE(object['size'], index);
    index += 4;

    data.write(object['SHA_1'], index, object['SHA_1'].length, 'binary');
    index += 20;
    data.writeInt16BE(pathBuffer.length, index);
    index += 2;
    pathBuffer.copy(data, index);
    index += pathBuffer.length;

    this.getNulls(remainNulls, function(nulls) {
        data.write(nulls, index, nulls.length, 'binary');

        callback(data);
        return;
    });
}

/**
 * Adds file to index file
 * @param path path to file
 * @param callback callback(err)
 */
Index.prototype.addObject = function (path, callback) {
    var indexFile = this;
    this.hasObject(path, function (has) {
        if (!has) {
            ++indexFile.objectsNumber;
        }
        indexFile.createObjectInfo(path, function (err, objectInfo) {
            if (err) {
                callback(err);
                return;
            }
            indexFile.getRelativePath(path, function(relativePath) {
                indexFile.objects[relativePath] = objectInfo;
				indexFile.createIndexFile(function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
            });
        });
    });
}

/**
 * Removes file from index file
 * @param path path to file
 * @param callback callback(err)
 */
Index.prototype.removeObject = function (path, callback) {
    var indexFile = this;
    this.hasObject(path, function (has) {
        if (has) {
            indexFile.getRelativePath(path, function(relativePath) {
                delete indexFile.objects[relativePath];
                --indexFile.objectsNumber;
                indexFile.createIndexFile(function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
            });
        } else {
            callback('fatal: pathspec \'' + path +
                '\' did not match any files');
            return;
        }
    });
}

/**
 * Creates data from all structures describes objects
 * @param callback callback(data)
 */
Index.prototype.createDatas = function (callback) {
    var datas = new Array();
    var objectsAdded = 0;
    var indexFile = this;
    if (this.objectsNumber > 0) {
        for (var object in this.objects) {
            this.objectToIndexFormat(this.objects[object], function (data) {
                datas.push(data);
                ++objectsAdded;
                if (objectsAdded == indexFile.objectsNumber) {
                    callback(datas);
                    return;
                }
            });
        }
    } else {
        callback(datas);
        return;
    }
}

/**
 * Get structure with object info
 * @param path path describes file
 * @param callback callback(err, objectInfo)
 */
Index.prototype.getObject = function(path, callback) {
    var indexFile = this;
    this.hasObject(path, function(has) {
        if (!has) {
            callback('fatal: pathspec \'' + path +
                '\' did not match any files', '');
            return;
        }

        indexFile.getRelativePath(path, function(relativePath) {
            callback('', indexFile.objects[relativePath]);
            return;
        });
    });
}

/**
 * Creates index file in .git/index from all structures
 * @param callback callback(err)
 */
Index.prototype.createIndexFile = function (callback) {
    var indexFile = this;
    var t = this.objects;
    this.createHeader(function (header) {
        indexFile.createDatas(function (datas) {
            var datasSize = 0;
            for (var data in datas) {
                datasSize += datas[data].length;
            }

            var indexFileContent = new Buffer(header.length + datasSize + 20);
            var index = 0;
            header.copy(indexFileContent, index);
            index += header.length;
            for (var data in datas) {
                datas[data].copy(indexFileContent, index);
                index += datas[data].length;
            }
            indexFile.calculateSHA_1(indexFileContent.toString('binary', 0,
            indexFileContent.length - 20), function (SHA_1) {
                indexFileContent.write(SHA_1, indexFileContent.length - 20,
                20, 'binary');
                fs.writeFile(indexFile.indexPath, indexFileContent, 'binary',
                function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
            });
        });
    });
}

Index.prototype.getRelativePath = function (path, callback) {
    callback(path.slice(this.repoPath.length - 4));
    return;
}

exports.Index = Index;
