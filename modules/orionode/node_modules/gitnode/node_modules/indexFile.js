/*******************************************************************************
 * Parser for index file. It is used when new object is added or removed
 * to/from git repository.
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var crypto = require('crypto');

function Index (path, callback) {
    this.objectsa = new Array();
    this.objectsNumber = 0;
    this.indexPath = path;

    var indexFile = this;
    fs.exists(this.indexPath, function (exists) {
        if (exists) {
            indexFile.parse(function () {
                callback();
            });
        } else {
            callback();
        }
    });
}

Index.prototype.parse = function (callback) {
    this.objectsa = [];
    var indexFile = this;
    fs.readFile(this.indexPath, function (err, fileIndexContent) {
        var index = 0;
        var signature = fileIndexContent.toString('binary', index, index + 4);
        index += 4;
        var versionNumber = fileIndexContent.readInt32BE(index);
        index += 4;
        var numberOfIndexEntries = fileIndexContent.readInt32BE(index);
        index += 4;

        var stop = fileIndexContent.length - 20;
        while (index < stop) {
            var objectInfo = new Array();
            objectInfo['ctime'] = fileIndexContent.readInt32BE(index);
            index += 4
            objectInfo['ctime_fraction'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['mtime'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['mtime_fraction'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['dev'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['ino'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['mode'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['uid'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['gid'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['size'] = fileIndexContent.readInt32BE(index);
            index += 4;
            objectInfo['SHA_1'] = fileIndexContent.toString('binary', index,
                index + 20);
            index += 20;
            objectInfo['flag'] = fileIndexContent.readInt16BE(index);
            index += 2;
            var nullEndIndex = 0;
            while (fileIndexContent.toString('binary', index + nullEndIndex,
                index + nullEndIndex + 1) != '\0') {
                ++nullEndIndex;
            }
            var path = fileIndexContent.toString('binary', index,
                index + nullEndIndex);
            objectInfo['path'] = path;

            index += nullEndIndex;
            while (fileIndexContent.toString('binary', index, index + 1)
                == '\0') {
                ++index;
            }
            indexFile.objectsa[path] = objectInfo;
            ++indexFile.objectsNumber;
        }

        callback();
    });
}



Index.prototype.hasObject = function (path, callback) {
    callback(path in this.objectsa);
}

Index.prototype.createHeader = function (callback) {
    var header = new Buffer(12);
    header.write('DIRC', 0, 4, 'binary');
    header.writeInt32BE(2, 4);
    header.writeInt32BE(this.objectsNumber, 8);

    callback(header);
}

Index.prototype.getNulls = function(number, callback) {
    var nulls = '';
    for (var nullNo = 0; nullNo < number; ++nullNo) {
        nulls += '\0';
    }

    callback(nulls);
}

Index.prototype.calculateSHA_1 = function(data, callback) {
    var sha1Creator = crypto.createHash('sha1');
    sha1Creator.update(data.toString('binary'));
    
    callback(sha1Creator.digest());
}

Index.prototype.createObjectInfo = function (path, callback) {
    var objectInfoSize = 62;
    var pathBuffer = new Buffer(path, 'binary');
    var remainNulls = 8 - ((pathBuffer.length - 2) % 8);

    var indexFile = this;
    fs.stat(path, function (err, stats) {
        var objectInfo = new Array();
        var index = 0;
        objectInfo['ctime'] = stats.ctime.getTime() / 1000;
        objectInfo['ctime_fraction'] = 0;
        objectInfo['mtime'] = stats.mtime.getTime() / 1000;
        objectInfo['mtime_fraction'] = 0;
        objectInfo['dev'] = stats.dev;
        objectInfo['ino'] = stats.ino;
        objectInfo['mode'] = stats.mode;
        objectInfo['uid'] = stats.uid;
        objectInfo['gid'] = stats.gid;
        objectInfo['size'] = stats.size;

        fs.readFile(path, function(err, fileAddedContent) {
            indexFile.calculateSHA_1(fileAddedContent, function (SHA_1) {
                objectInfo['SHA_1'] = SHA_1;
                objectInfo['flag'] = pathBuffer.length;
                objectInfo['path'] = path.toString('binary');
                callback(objectInfo);
            });
        });
    });
}

Index.prototype.objectToIndexFormat = function (object, callback) {
    var objectInfoSize = 62;
    var pathBuffer = new Buffer(object['path'], 'binary');
    var remainNulls = 8 - ((pathBuffer.length - 2) % 8);

    var data = new Buffer(objectInfoSize + pathBuffer.length + remainNulls);
    var index = 0;
    data.writeInt32BE(object['ctime'], index);
    index += 4;
    data.writeInt32BE(object['ctime_fraction'], index);
    index += 4;
    data.writeInt32BE(object['mtime'], index);
    index += 4;
    data.writeInt32BE(object['mtime_fraction'], index);
    index += 4;
    data.writeInt32BE(object['dev'], index);
    index += 4;
    data.writeInt32BE(object['ino'], index);
    index += 4;
    data.writeInt32BE(object['mode'], index);
    index += 4;
    data.writeInt32BE(object['uid'], index);
    index += 4;
    data.writeInt32BE(object['gid'], index);
    index += 4;
    data.writeInt32BE(object['size'], index);
    index += 4;

    data.write(object['SHA_1'], index, object['SHA_1'].length, 'binary');
    index += 20;
    data.writeInt16BE(pathBuffer.length, index);
    index += 2;
    pathBuffer.copy(data, index);
    index += pathBuffer.length;

    this.getNulls(remainNulls, function(nulls) {
        data.write(nulls, index, nulls.length, 'binary');

        callback(data);
    });
}

Index.prototype.addObject = function (path, callback) {
    var indexFile = this;
    var t = this;
    this.hasObject(path, function (has) {
        if (!has) {
            ++indexFile.objectsNumber;
        }
        indexFile.createObjectInfo(path, function (objectInfo) {
            indexFile.objectsa[path] = objectInfo;
            
            indexFile.creteIndexFile(function () {
                callback();
            });
        });
    });
}

Index.prototype.removeObject = function (path, callback) {
    var indexFile = this;
    this.hasObject(path, function (has) {
        if (has) {
            delete indexFile.objectsa[path];
            --indexFile.objectsNumber;
            indexFile.creteIndexFile(function () {
            });
        } else {
            console.log(
                'Index.prototype.removeObject: No object in index file');
        }
        callback();
    });
}

Index.prototype.createDatas = function (callback) {
    var datas = new Array();
    var objectsAdded = 0;
    var indexFile = this;

    for (var object in this.objectsa) {
        this.objectToIndexFormat(this.objectsa[object], function (data) {
            datas.push(data);
            ++objectsAdded;
            if (objectsAdded == indexFile.objectsNumber) {
                callback(datas);
            }
        });
    }
}

Index.prototype.creteIndexFile = function (callback) {
    var indexFile = this;

    this.createHeader(function (header) {
        indexFile.createDatas(function (datas) {
            
            var datasSize = 0;
            for (var data in datas) {
                datasSize += datas[data].length;
            }

            var indexFileContent = new Buffer(header.length + datasSize + 20);
            var index = 0;
            header.copy(indexFileContent, index);
            index += header.length;
            for (var data in datas) {
                datas[data].copy(indexFileContent, index);
                index += datas[data].length;
            }
            indexFile.calculateSHA_1(indexFileContent.toString('binary', 0,
            indexFileContent.length - 20), function (SHA_1) {
                indexFileContent.write(SHA_1, indexFileContent.length - 20,
                20, 'binary');
                fs.writeFile(indexFile.indexPath, indexFileContent, 'binary',
                function (err) {
                    
                    callback();
                });
            });
        });
    });
}

exports.Index = Index;
