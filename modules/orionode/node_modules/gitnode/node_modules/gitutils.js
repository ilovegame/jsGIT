cM = require('commit.js');
tM = require('tree.js');

//In all functions gitpath must be without .git


function correctGitPath(gitpath) {
    if(gitpath.length > 0 && gitpath[gitpath.length - 1] !== '/')
        gitpath = gitpath + '/';
    if(gitpath === '') gitpath = '/';
    return gitpath;
}


/*
 * if HEAD file points to commit which does not exist
 * we assume there has not been a commit yet
 * we return headSha1 = undefined to callback
 * 
 * 2. there's an error we return error to callback
 * 3. everything is fine we return err = null, and headSha1 defined(40 signs)
 */
function getHeadSha1(gitpath, callback) {
    correctGitPath(gitpath);
    try {
        fs.readFile(gitpath + '.git/HEAD', function (err, data) {
            if (err) throw err;
            var datastr = data.toString();
            var refs = 'ref: ';
            var headSha1 = datastr;
            if(datastr[datastr.length - 1] === '\n') 
                datastr = datastr.substr(0, datastr.length - 1);
            if (datastr.substr(0,5) === refs) {
                fs.readFile(gitpath+'.git/' + datastr.substr(5, datastr.length - 5), function(err, data) {
                    if (err) {
                        //there's no commit yet
                        callback(null, undefined);
                    } else {
                        headSha1 = data.toString();
                        //we read '/n'
                        if(headSha1[headSha1.length-1] === '\n')
                            headSha1 = headSha1.substr(0, headSha1.length - 1);
                        //domorework
                        callback(err, headSha1);
                    }
                });
            } else {
                if(headSha1[headSha1.length-1] === '\n')
                            headSha1 = headSha1.substr(0, headSha1.length - 1);
                callback(err, headSha1);
            }
        });
    } catch(err) {
        callback(err);   
    }
}

/**
 * @param gitpath -..
 * @param sha1 - 40 sign sha1
 * this function changes current head's sha1 to the one given as param
 * @param callback - callback(err)
 */
function updateHead(gitpath, sha1, callback) {
    correctGitPath(gitpath);
    try {
        fs.readFile(gitpath + '.git/HEAD', function (err, data) {
            if (err) throw err;
            var datastr = data.toString();
            var refs = 'ref: ';
            var headSha1 = datastr;
            datastr = datastr.substr(0, datastr.length - 1);
            if (datastr.substr(0,5) === refs) {
                fs.writeFile(gitpath+'.git/' + datastr.substr(5, datastr.length - 5), sha1, callback);
            } else {
                fs.writeFile(gitpath + '.git/HEAD', sha1, callback);
            }
        });
    } catch(err) {
        callback(err);   
    }
}


/*
 * if HEAD file points to co
 * commit which does not exist
 * we assume there has not been a commit yet
 * we return head = undefined with callback
 * 
 * 
 */

function getHeadCommit(gitpath, callback) {
    correctGitPath(gitpath);
    try {
        getHeadSha1(gitpath, function(err, headSha1) {
            if (err) throw err; 
            if (headSha1 === undefined) callback(null, undefined);
            else {
                console.log(headSha1);
                cM.readFileToCommit(headSha1, gitpath + '.git', function(err, head) {
                    if (err) throw err;
                    callback(null, head);
                });
            }
        });
    } catch (err) {
        callback(err);   
    }
}

/*
 * if HEAD file points to commit which does not exist
 * we assume there has not been a commit yet
 * we return head = undefined with callback and no tree info
 * 
 * 
 */

function getHeadAndTreeDir(gitpath, callback) {
    correctGitPath(gitpath);
    try {
        getHeadCommit(gitpath, function(err, head) {
            if (err) throw err;
            //not a single commit yet
            if (head === undefined) {
                callback(null, head);
            } else {
                tM.readFileToTree(head.objectId, gitpath + '.git', function(err, tree) {
                    if (err) throw err;
                    tree.walk(gitpath, function(err, treeInfo, graph)  {
                        if (err) throw err;
                        callback(null, head, treeInfo, graph);
                    });
                });
            }
        });
    } catch (err) {
        callback(err);   
    }
}

exports.updateHead = updateHead;
exports.getHeadAndTreeDir = getHeadAndTreeDir;
exports.getHeadCommit = getHeadCommit;
exports.getHeadSha1 = getHeadSha1;
