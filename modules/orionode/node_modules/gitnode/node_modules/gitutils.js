var cM = require('commit.js');
var tM = require('tree.js');
var fs = require('fs');
//In all functions repopath must be with /.git/

/*
function correctGitPath(repopath) {
    if(repopath.length > 0 && repopath[repopath.length - 1] !== '/')
        repopath = repopath + '/';
    if(repopath === '') repopath = '/';
    return repopath;
}*/


/*
 * if HEAD file points to commit which does not exist
 * we assume there has not been a commit yet
 * we return headSha1 = undefined to callback
 * 
 * 2. there's an error we return error to callback
 * 3. everything is fine we return err = null, and headSha1 defined(40 signs)
 */
function getHeadSha1(repopath, callback) {
    console.log(repopath + '/HEAD');
    fs.readFile(repopath + '/HEAD', function (err, data) {
        if (err) {
            callback(err);    
            return;
        }
        var datastr = data.toString();
        var refs = 'ref: ';
        var headSha1 = datastr;
        if(datastr[datastr.length - 1] === '\n') 
            datastr = datastr.substr(0, datastr.length - 1);
        if (datastr.substr(0,5) === refs) {
            fs.readFile(repopath + datastr.substr(5, datastr.length - 5), function(err, data) {
                if (err) {
                    //there's no commit yet
                    callback(null, undefined);
                } else {
                    headSha1 = data.toString();
                    //we read '/n'
                    if(headSha1[headSha1.length-1] === '\n')
                        headSha1 = headSha1.substr(0, headSha1.length - 1);
                    //domorework
                    callback(err, headSha1);
                }
            });
        } else {
            if(headSha1[headSha1.length-1] === '\n')
                        headSha1 = headSha1.substr(0, headSha1.length - 1);
            callback(err, headSha1);
        }
    });
}

/**
 * @param repopath -..
 * @param sha1 - 40 sign sha1
 * this function changes current head's sha1 to the one given as param
 * @param callback - callback(err)
 */
function updateHead(repopath, sha1, callback) {
    fs.readFile(repopath + 'HEAD', function (err, data) {
        if (err) {
            callback(err);
            return;
        }
        var datastr = data.toString();
        var refs = 'ref: ';
        var headSha1 = datastr;
        datastr = datastr.substr(0, datastr.length - 1);
        if (datastr.substr(0,5) === refs) {
            fs.writeFile(repopath + datastr.substr(5, datastr.length - 5), sha1, callback);
        } else {
            fs.writeFile(repopath + 'HEAD', sha1, callback);
        }
    });
}


/*
 * if HEAD file points to co
 * commit which does not exist
 * we assume there has not been a commit yet
 * we return head = undefined with callback
 * 
 * 
 */

function getHeadCommit(repopath, callback) {
    getHeadSha1(repopath, function(err, headSha1) {
        if (err) {
            
            callback(err);
            return;
        }
        if (headSha1 === undefined) callback(null, undefined);
        else {
            cM.readFileToCommit(headSha1, repopath, function(err, head) {
                if (err) {
                    callback(err);
                    return;
                }
                callback(null, head);
            });
        }
    });
}

function getHeadCommitParents(repopath, callback) {
    getHeadCommit(repopath, function(err, head) {
        if (err) {
            callback(err);
            return;
        }
        if (head === undefined) {
            callback(undefined, false);
            return ;
        }
        callback(undefined, head.parents);
    }); 
}





/*
 * if HEAD file points to commit which does not exist
 * we assume there has not been a commit yet
 * we return head = undefined with callback and no tree info
 * 
 * 
 */

function getHeadAndTreeDir(repopath, callback) {
    getHeadCommit(repopath, function(err, head) {
        if (err) {
            callback(err);
            return;
        }
        
        //not a single commit yet
        if (head === undefined) {
            callback(null, head);
        } else {
            tM.readFileToTree(head.objectId, repopath, function(err, tree) {
                if (err) {
                    callback(err);
                    return;
                }
                tree.walk(repopath, function(err, treeInfo, graph)  {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback(null, head, treeInfo, graph);
                });
            });
        }
    });
}

function getCommitAndTreeDir(repopath, sha1, callback) {
    
    cM.readFileToCommit(sha1, repopath, function(err, commit) {
        if (err) {
            callback(err);
            return;
        }
        tM.readFileToTree(commit.objectId, repopath, function(err, tree) {
            if (err) {
                callback(err);
                return;
            }
            tree.walk(repopath, function(err, treeInfo, graph)  {
                if (err) {
                    callback(err);
                    return;
                }
                callback(null, commit, treeInfo, graph);
            });
        });
    });

}




exports.updateHead = updateHead;
exports.getHeadAndTreeDir = getHeadAndTreeDir;
exports.getHeadCommit = getHeadCommit;
exports.getHeadSha1 = getHeadSha1;
exports.getCommitAndTreeDir = getCommitAndTreeDir;
exports.getHeadCommitParents = getHeadCommitParents;