 //here be dragons
 
 
 var http = require('http')
 var out = function(res) {
     res.on('data', function(chunk){
         console.log(chunk.toString());
     }); 
     console.log('got response: ' + res.statusCode)
 };
//http.get('http://github.com/kyloel/clone.git/info/refs?service=git-upload-pack', out);
//http.get('http://github.com/kyloel/clone.git/objects/0f3ff81824d26898f6ff2eb2cecb09ca268d7a77', out);
//http.get('http://github.com/kyloel/clone.git/objects/0f/3ff81824d26898f6ff2eb2cecb09ca268d7a77', out);



//var buf1 = new Buffer("0039git-upload-pack /schacon/gitbook.git\0host=example.com\0"); //039
//console.log(buf1.toString());
//console.log(buf1.length);
//console.log(buf1.toString('utf8', 0, 3*16+9));
//var buf11 = new Buffer(buf1.toString('utf8', 0, 3*16+9));
//console.log(buf11.length);
////console.log(convertDigestToHex(buf.length.toString()));
//var buf2 = new Buffer("0032git-upload-pack /project.git\0host=myserver.com\0");//032 == 50
//console.log(buf2.toString());
//console.log(buf2.length);
//
//var buf3 = new Buffer("003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0");//3f
//console.log(buf3.length);



//commands' format:
//|4 bits with length in hex|command string
//length = length(command string)
var gitUploadPackBuff = function(repo, host)
{
    // repo = /kyloel/clone.git <= few cases, check for '/' etc
    // host = github.com
    var reqbuf = new Buffer('git-upload-pack ' + repo + '\0host=' + host + '\0');
    //hexString = (reqbuf.length).toString(16); //magic  - ignore last \0, count lenbuf too.
    var hexString = (reqbuf.length + 4).toString(16);  //dunno witch one is good
    //hexString = (reqbuf.length + 3).toString(16); 
    //yourNumber = parseInt(hexString, 16);
    var len = '';
    for(var i = 0; i <  4 - hexString.length; i++)
    {
        len += '0';
    }
    len += hexString;
    var lenbuf = new Buffer(len);
    return new Buffer.concat([lenbuf, reqbuf]);
}

var addPktLen = function(commandBuffer)
{
    var hexString = (commandBuffer.length + 4).toString(16); //? 4 or 3?
    var len = '';
    for(var i = 0; i <  4 - hexString.length; i++)
    {
        len += '0';
    }
    len += hexString;
    var lenbuf = new Buffer(len);
    return new Buffer.concat([lenbuf, commandBuffer]);
}

var firstWant = function(objectId, serverCapabilities)
{
    var tempString = 'want ' + objectId + ' ';
    if(serverCapabilities.indexOf('multi_ack') != -1) //maybe turn this off? 
    {
        tempString += 'multi_ack ';
    }
    if(serverCapabilities.indexOf('ofs-delta') != -1) //packV2
    {
        tempString += 'ofs-delta ';
    }
    if(serverCapabilities.indexOf('include-tag') != -1) //copy with tags??
    {
        tempString += 'include-tag ';
    }
    var temp = new Buffer(tempString);
    temp[tempString.length-1] = 10;
    return temp;
}

var additionalWant = function(objectId)
{
    var tempString = 'want ' + objectId + "\n";
    return new Buffer(tempString);
}
var cloneWant = function(serverDisc, start, num)
{
    start = start || 0;
    num = num || (start + 32);
    var query = [];
    if((start == 0) && (serverDisc.objects[0].path == 'HEAD'))
    {
        query.push(addPktLen(
              firstWant(serverDisc.objects[0].sha1, serverDisc.capabilities)));
        for(var i = 1; (i < serverDisc.objects.length) && (i < num); i++)
        {
            if(serverDisc.objects[i].path.indexOf('/heads') != -1)
            {
                query.push(addPktLen(additionalWant(serverDisc.objects[i].sha1)));
            }

        }
    }
    else
    {
        for(var i = start; (i < serverDisc.objects.length) && (i < num); i++)
        {
            if(serverDisc.objects[i].path.indexOf('/heads') != -1)
            {
                query.push(addPktLen(additionalWant(serverDisc.objects[i].sha1)));
            }
                
        }
    }
    //can't use foreach, different case for index 0
    
    return Buffer.concat(query);
}

var addFlush = function(buffer)
{
    //pases array with two elements
    return Buffer.concat([buffer, new Buffer('0000')]);
}

var done = function()
{
    return addPktLen(new Buffer('done\n'));
}

var object = function(sha1, path)
{
    this.sha1 = sha1;
    this.path = path;
}

//objects are in order given by server
var serverDiscovery = function(objs, capabs)//, rst)
{
    this.objects = objs || [];
    this.capabilities  = capabs || [];
    //this.rest = rst;
}

//serverDiscovery.prototype.merge = function (lastSD)
//{
//    this.objects = this.objects.concat(lastSD.objects);
//    if(lastSD.capabilities != undefined)
//    {
//        this.capabilities = lastSD.capabilities;
//    }
//    this.rest = lastSD.rest;
//}

var checkExistance = function(buffer, start, end)
{
    //console.log("Jestem " + start + " do " + end +" z " + buffer.length);
    if((buffer.length >= start) && (buffer.length >= end))
        return true;
    else
    {
        //console.log("Jestem " + start + " do " + end +" z " + buffer.length);
        return false
    }
}

//draft implementation
//wtf is peeled ref
//warning: there could be more packets than one 
//var parseReferenceDiscovery = function(data)
//{
//    var objects = [];
//    var options;
//    var rest;
//    for(var i = 0; (i < data.length); )
//    {
//        if(checkExistance(data, i, i+4))
//        {
//            var len = data.slice(i, i+4);
//            var parseLen = parseInt(len.toString(), 16);
//            if(parseLen == 0) 
//                break;
//            if(checkExistance(data, i + 4, i + parseLen))
//            {
//                var toParse = data.slice(i + 4, i + parseLen).toString().replace("\n",""); //ignore ptk-len
//                if(i == 0) 
//                {
//                    var firstRow = toParse.split("\0");
//                    if(firstRow.length == 2)
//                    {
//                        options = firstRow[1].split(" ");
//                        toParse = firstRow[0];
//                    }
//                    //parse options
//                }
//                var obj = toParse.split(" ");
//                objects.push(new object(obj[0], obj[1]));
//                //console.log(parseLen);
//                //console.log(toParse.toString());
//                i += parseLen;
//            }
//            else
//            {
//                rest = data.slice(i);
//                break;
//            }
//        }
//        else
//        {
//            rest = data.slice(i);
//            break;
//        }
//    }
//    if(rest)
//    {
//        console.log("rest: "+ rest.toString());
//        return new serverDiscovery(objects, options, rest);
//    }
//    else
//    {
//        return new serverDiscovery(objects, options);
//    }
//        
//}

var parseReferenceDiscoveryConcated = function(data)
{
    var objects = [];
    var options;
    var rest;
    for(var i = 0; (i < data.length); )
    {
        var len = data.slice(i, i+4);
        var parseLen = parseInt(len.toString(), 16);
        if(parseLen == 0) 
            break;
        var toParse = data.slice(i + 4, i + parseLen).toString().replace("\n",""); //ignore ptk-len
        if(i == 0) 
        {
            var firstRow = toParse.split("\0");
            if(firstRow.length == 2)
            {
                options = firstRow[1].split(" ");
                toParse = firstRow[0];
            }
            //parse options
        }
        var obj = toParse.split(" ");
        objects.push(new object(obj[0], obj[1]));
        //console.log(parseLen);
        //console.log(toParse.toString());
        i += parseLen;
    }
        return new serverDiscovery(objects, options);  
}


//var parseRefDiscHelper = function(data, lastServerDiscovery)
//{
//    var newServerDiscovery;
//    //console.log("tu");
//    console.log(lastServerDiscovery.rest);
//    if(lastServerDiscovery.rest)
//    {
//        //console.log("w if");
//        //console.log(Buffer.concat([lastServerDiscovery.rest, data]).toString());
//        newServerDiscovery = parseReferenceDiscovery(
//                Buffer.concat([lastServerDiscovery.rest, data]));
//        
//        
//    }
//    else
//    {
//        newServerDiscovery = parseReferenceDiscovery(data);
//    }
//    lastServerDiscovery.merge(newServerDiscovery);
//    return lastServerDiscovery;
//}

net = require('net');

////git://github.com/torvalds/linux.git
//var client = net.createConnection({port: 9418, host: 'github.com'}, function(){
//    //client.write(gitUploadPackBuff('/kyloel/clone.git', 'github.com'));
//   client.write(gitUploadPackBuff('/torvalds/linux.git', 'github.com'));
//});
//var first = 0;
//client.on('data', function(data) {
//    console.log(data);
//    console.log(data.toString());
//    var discovery = parseReferenceDiscovery(data);
//    console.log(discovery);
////    if(first == 0)
////    {
////    var discovery = parseReferenceDiscovery(data);
////        first = 1;
////        console.log(discovery);
////        console.log(cloneWant(discovery).toString());
////    //    client.on('data', function(newData){
////    //        console.log("answer:")
////    //        console.log(newData);
////    //        console.log(newData.toString());
////    //    
////    //    });
////        client.write(addFlush(cloneWant(discovery)));
////        client.write(done());
////    }
//    client.end();
//});
//client.on('end', function() {
//    console.log('client disconnected');
//});

url = require('url');

var checkForFlush = function(data)
{
    if((data[data.length-4] == 48) && (data[data.length-3] == 48) &&
        (data[data.length-2] == 48) && (data[data.length-1] == 48))
           return true;
    else
        return false;
}

var checkForNAK = function(data)
{
    var toComp = new Buffer("0008NAK\n");
    var ret = true;
    var i = 0;
    for(i; i < data.length; i++)
    {
        if(data[i] != toComp[i])
            ret = false;
    }
    return ret;
}

var conversationState = 
{
    start: 0,
    discovery: 1,
    negotiation: 2,
    packfileFetch: 3
}

var cutPacks = function(data)
{
    var toComp = new Buffer("PACK");
    var packs = [];
    var lastSlice = 0;
    //console.log(data.toString());
    for(var i = 1; i < data.length - 4; i++)
    {
        if((data[i] == toComp[0]) && (data[i+1] == toComp[1])
        && (data[i+2] == toComp[2]) && (data[i+3] == toComp[3]))
        {
            packs.push(data.slice(lastSlice, i)); 
            lastSlice = i;
        }
        if(i == (data.length - 5))
        {
            packs.push(data.slice(lastSlice, data.length));
        }
    }
    //console.log(packs);
    return packs;
}

//callback where to pass the packs data
var gitCloneConversation = function(gitProtoLink, callback)
{
    var ans = [];
    var state = conversationState.start;
    var sDiscovery;
    var repoParams = url.parse(gitProtoLink);
    var options = {port: (repoParams.port || 9418), host: repoParams.hostname};
    var client = net.createConnection(options, function(){
        client.write(gitUploadPackBuff(repoParams.pathname, repoParams.hostname));
    });
    client.on('data', function(data){
        //console.log(data.toString());
        switch(state)
        {
            case conversationState.start:
                ans.push(data);
                if(checkForFlush(data))
                {
                    //This works with erros in capabilites
        //            ans.forEach(function(element){
        //                sDiscovery = parseRefDiscHelper(element, sDiscovery);
        //                //console.log(element);
        //            });
        //            
                    //this seems to work:
                    sDiscovery = parseReferenceDiscoveryConcated(Buffer.concat(ans));
                    state = conversationState.discovery;
                    ans = [];
                    client.write(addFlush(cloneWant(sDiscovery)));
                    client.write(done());
                    
                }
            break;
            case conversationState.discovery:
                if(checkForNAK(data))
                {
                    state = conversationState.packfileFetch;
                    ans = [];
                    //need to add start of pack send in one packet with NAK
                    ans.push(data.slice(8,data.length));
                    client.end();
                }
            break;
            case conversationState.negotiation:
                
            break;
            case conversationState.packfileFetch:
                ans.push(data);
            break;
        }
        
    });
    client.on('end', function(){
        console.log("tutaj1");
        if(state == conversationState.packfileFetch)
        {
            var pack = Buffer.concat(ans);
            callback(cutPacks(pack));
        }
    });
}

var test = function(packs)
{
    console.log(packs.length);
}





gitCloneConversation('git://github.com/kyloel/clone.git', test);
//gitCloneConversation('git://github.com/mozilla/monolith.git');
//gitCloneConversation('git://github.com/wakaleo/game-of-life.git');
//gitCloneConversation('git://github.com/torvalds/linux.git');
//gitCloneConversation('git://github.com/github/gitignore.git');
//gitCloneConversation('git://github.com/django/django.git');