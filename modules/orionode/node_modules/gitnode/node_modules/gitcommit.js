

gsM = require('gitstatus.js');
guM = require('gitutils.js');
tM = require('tree.js');
cM = require('commit.js');


/**
 * Private function, modifies the graph (returned from tree.walk)
 * using the results from gitstatus added and changed arrays
 * For example if git adds object a/b.txt
 * we might have new entries
 * graph[0]['a'] and graph[some_index]['b.txt']
 * We don't update sha1s here except for blobs(we have their sha1 from index)
 * 
 * @param path = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 */
function addChangedGraph(path, graph, index, graphModified) {
    var splitPath = path.split('/');
    var graphEntry = 0;
    for (var i = 0; i < splitPath.length; ++i) {
        var nextEntry = -1;
        var entry = {};
        
        if (i !== splitPath.length - 1) {
            entry.mode = 40000;
            entry.type = 'tree';
            entry.sha1 = '';
            if(graph[graphEntry][splitPath[i]] === undefined) {
                nextEntry = graph.length;
                graph[nextEntry] = {};
            } else {
                nextEntry = graph[graphEntry][splitPath[i]]['next'];   
            }
        } else {
            entry.mode = 100644;
            entry.type = 'blob';
            entry.sha1 = utils.convertDigestToHex(new Buffer(index.objects[path]['SHA_1'], 'binary'));
        }
        if(!graphModified[graphEntry]) {
            graphModified[graphEntry] = {}
        }
        graphModified[graphEntry][splitPath[i]] = true;
        graph[graphEntry][splitPath[i]] = {'entry' : entry, 'next' : nextEntry};
        graphEntry = nextEntry;
    }
}

/**
 * Private function, modifies the graph (returned from tree.walk)
 * using the results from removed array
 * For example if git removes object a/b.txt
 * we might have deleted entries from dictionaries
 * graph[0]['a'](if 'a' directory is empty after 'b.txt' deletion)
 * and graph[some_index]['b.txt']
 * We don't update sha1s here
 * 
 * @param path = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 */
function removeGraph(path, graph, index, graphModified) {
    var splitPath = path.split('/');
    var graphEntry = 0;
    var graphEntries = [];
    for (var i = 0; i < splitPath.length; ++i) {
        if(!graphModified[graphEntry]) {
            graphModified[graphEntry] = {};   
        }
        graphModified[graphEntry][splitPath[i]] = true;
        graphEntries.push(graphEntry);
        graphEntry = graph[graphEntry][splitPath[i]]['next'];
    }
    var previousEmpty = true;
    for (var i = graphEntries.length - 2; i >= 0; --i) {
        if(previousEmpty)
            delete graph[graphEntries[i]][splitPath[i]];
        previousEmpty = Object.keys(graph[graphEntries[i]]).length === 0;
    }
    
}
/**
 * Function retrieves tree sha1 from graph object(from tree.js walk)
 * @param graphEntry = graph[some_index]
 * but this graph[some_index] must have sha1 for all entries
 * so if graph[some_index] = {'a.txt' : [Object], 'b' : [Object]}
 * graph[some_index]['a.txt']['treeInfo']['sha1'] should be correct sha1
 * the same with b directory
 * @return sha1 of that tree
 */
function getSha1(graphEntry) {
    var tmpTree = new tM.Tree({});
    for(var entry in graphEntry) {
        tmpTree.entries[entry] = graphEntry[entry]['entry'];
    }
    return tmpTree.getSha1();
}

/**After the graph is modified by the added,changed and removed
 * arrays from gitstatus it doesn't contain correct sha1 anymore
 * we have to fix the graph
 * @param graph = tree.js walk graph result
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 * @return tree's sha1 after inserting graph[0] treeInfo entries
 */
function fixsha1(graph, graphModified) {
    var graphIndex = 0;
    function fix(graphI) {
        for(var k in graphModified[graphI]) {
            if(graph[graphI][k]) {
                if(graph[graphI][k]['next'] !== -1) {
                    graph[graphI][k]['entry']['sha1'] = fix(graph[graphI][k]['next'])    
                }
            }
        }
        return getSha1(graph[graphI]);
    }
    return fix(graphIndex);
}


/*
 * DEBUGING FUNCTION
function displayGraph(graph) {
    console.log('--------------------');
    for(var i = 0; i < graph.length; ++i) {
        console.log(i);
        for(var k in graph[i]) {
            console.log(k + " " + graph[i][k]['entry']['sha1'] + " " + graph[i][k]['next']);   
        }
    }
    console.log('--------------------');
}

*/

/**Change the graph with git status result
 * added/changed/removed
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @statusRes = object representing git status results
 * @return graph[0] sha1
 */

function modifyGraph(graph, index, statusRes) {
    var graphModified = [];
    statusRes.added.forEach(function(path) {
        addChangedGraph(path, graph, index, graphModified);   
    });
    statusRes.changed.forEach(function(path) {
        addChangedGraph(path, graph, index, graphModified);   
    });
    statusRes.removed.forEach(function(path) {
        removeGraph(path, graph, index, graphModified);   
    });
    var sh = fixsha1(graph, graphModified);
    return sh;
}

/**
 * Git commit 
 * @param gitpath = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @param commitInfo = dictionary { 'author' : author, 'authorMail' : authorMail,
 * 'committer' : committer, 'committerMail' : committerMail, 'description' : description}
 * @param callback(err, res);  atm res is empty dictionary
 * @param option - 'amend' or 'normal'
 * 
 * gitCommit executes gitStatus, then modifies and creates a new tree and new commit
 * Updates HEAD and refs/heads according to what's there 
 * (we can change master - if he'd on master, the same with branches, or if HEAD is a sha1)
 * We can commit if HEAD points to commit which does not exist -> HEAD points to refs/heads/xx
 * and xx doesn't exist(in native git it's the state after git init)
 * 
 * 
 * Example:
 * 
   gcM.gitCommit('/home/marcinek/gitrepotest/', 'normal', commitInfo, function(err, result) {
        //it doesn't msg anything and result is empty dict atm
        //only should make a legit commit
   });
 */
exports.gitCommit = function(gitpath, option, commitInfo, callback) {
    var parentId = undefined;
    var result = {};
    var date = new Date();
    var timeZoneN = -(date.getTimezoneOffset())/60;
    var timeZone = '';
    timeZone += (timeZoneN >= 0) ? '+' : '-';
    timeZone += (Math.abs(timeZoneN) < 10) ? '0' : '';
    timeZone += timeZoneN.toString();
    timeZone += '00';
    var timestamp = Math.floor(date.getTime()/1000);
    var authorInfo = new uM.OperationDetails(commitInfo.author, commitInfo.authorMail, timestamp, timeZone); 
    var committerInfo = new uM.OperationDetails(commitInfo.committer, commitInfo.committerMail, timestamp, timeZone); 
    try {
        gsM.gitStatus(gitpath, function(err, statusRes, treeDir, graph, index) {
            if (statusRes.changed.length === 0 && statusRes.added.length === 0 &&
                statusRes.removed.length === 0) {
                callback(null, result);
                return ;
            }
            var function1 = function(err, headSha1) {
                if(err) throw err;
                var parents = [];
                if(headSha1 !== undefined) {
                    parents.push(headSha1);
                }
                var treeSha1 = modifyGraph(graph, index, statusRes);
                
                tM.graphToRepo(gitpath, graph, function(err, sh) {
                    if(err) throw err;
                    var commitObject = new cM.Commit(treeSha1, parents,
                        commitInfo.description, authorInfo, committerInfo);
                    var newHeadSha1 = commitObject.getSha1();
                    commitObject.save(gitpath + '.git/', function(err) {
                        if(err) throw err;
                        
                        guM.updateHead(gitpath, newHeadSha1, function(err) {
                            
                            if(err) throw err;
                            callback(null, result);
                        });              
                    });
                });
            }
            var result = 0;
            if (err) throw err;
            if (graph === undefined) {
                graph = [{}];
                function1(null, undefined);
            } else {
                guM.getHeadSha1(gitpath, function1);
            }
            
        });
    } catch (err) {
        callback(err);  
    }

}