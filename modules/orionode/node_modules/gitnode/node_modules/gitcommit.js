

var gsM = require('gitstatus.js');
var guM = require('gitutils.js');
var tM = require('tree.js');
var cM = require('commit.js');
var ph = require('path');
var fs = require('fs');
var utils = require('utils.js');
var bM = require('blob.js');
var gaM = require('gitAddCommand.js');
var diffM = require('gitDiffCommand.js');
var gCCM = require('gitCommitCommand.js');
var cPM = require('conflictParser.js');

/**
 * Private function, modifies the graph (returned from tree.walk)
 * using the results from gitstatus added and changed arrays
 * For example if git adds object a/b.txt
 * we might have new entries
 * graph[0]['a'] and graph[some_index]['b.txt']
 * We don't update sha1s here except for blobs(we have their sha1 from index)
 * 
 * @param path = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 */
function addChangedGraph(path, graph, sha1, graphModified) {
    var splitPath = path.split('/');
    var graphEntry = 0;
    for (var i = 0; i < splitPath.length; ++i) {
        var nextEntry = -1;
        var entry = {};
        if (i !== splitPath.length - 1) {
            entry.mode = 40000;
            entry.type = 'tree';
            entry.sha1 = '';
            if(graph[graphEntry][splitPath[i]] === undefined) {
                nextEntry = graph.length;
                graph[nextEntry] = {};
            } else {
                nextEntry = graph[graphEntry][splitPath[i]]['next'];   
            }
        } else {
            entry.mode = 100644;
            entry.type = 'blob';
            entry.sha1 = sha1
        }
        if(!graphModified[graphEntry]) {
            graphModified[graphEntry] = {}
        }
        graphModified[graphEntry][splitPath[i]] = true;
        graph[graphEntry][splitPath[i]] = {'entry' : entry, 'next' : nextEntry};
        graphEntry = nextEntry;
    }
}

/**
 * Private function, modifies the graph (returned from tree.walk)
 * using the results from removed array
 * For example if git removes object a/b.txt
 * we might have deleted entries from dictionaries
 * graph[0]['a'](if 'a' directory is empty after 'b.txt' deletion)
 * and graph[some_index]['b.txt']
 * We don't update sha1s here
 * 
 * @param path = gitrepo without .git  example: /home/marcinek/gitrepo/
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 */
function removeGraph(path, graph, graphModified) {
    var splitPath = path.split('/');
    var graphEntry = 0;
    var graphEntries = [];
    for (var i = 0; i < splitPath.length; ++i) {
        if(!graphModified[graphEntry]) {
            graphModified[graphEntry] = {};   
        }
        graphModified[graphEntry][splitPath[i]] = true;
        graphEntries.push(graphEntry);
        graphEntry = graph[graphEntry][splitPath[i]]['next'];
    }
    var previousEmpty = true;
    for (var i = graphEntries.length - 2; i >= 0; --i) {
        if(previousEmpty)
            delete graph[graphEntries[i]][splitPath[i]];
        previousEmpty = Object.keys(graph[graphEntries[i]]).length === 0;
    }
    
}
/**
 * Function retrieves tree sha1 from graph object(from tree.js walk)
 * @param graphEntry = graph[some_index]
 * but this graph[some_index] must have sha1 for all entries
 * so if graph[some_index] = {'a.txt' : [Object], 'b' : [Object]}
 * graph[some_index]['a.txt']['treeInfo']['sha1'] should be correct sha1
 * the same with b directory
 * @return sha1 of that tree
 */
function getSha1(graphEntry) {
    var tmpTree = new tM.Tree({});
    for(var entry in graphEntry) {
        tmpTree.entries[entry] = graphEntry[entry]['entry'];
    }
    return tmpTree.getSha1();
}

/**After the graph is modified by the added,changed and removed
 * arrays from gitstatus it doesn't contain correct sha1 anymore
 * we have to fix the graph
 * @param graph = tree.js walk graph result
 * @param graphModified = 
 * local argument representing which files from
 * graph has been modified(added,changed,removed) by the commit algorithm
 * and has the following format
 * [{'a.txt' : true}, {'b.txt' : true}]
 * and it means that during the algorithm graph[0]['a.txt'] and graph[1]['b.txt']
 * are modified
 * @return tree's sha1 after inserting graph[0] treeInfo entries
 */
function fixsha1(graph, graphModified) {
    var graphIndex = 0;
    function fix(graphI) {
        for(var k in graphModified[graphI]) {
            if(graph[graphI][k]) {
                if(graph[graphI][k]['next'] !== -1) {
                    graph[graphI][k]['entry']['sha1'] = fix(graph[graphI][k]['next'])    
                }
            }
        }
        return getSha1(graph[graphI]);
    }
    return fix(graphIndex);
}


/*
 * DEBUGING FUNCTION
function displayGraph(graph) {
    console.log('--------------------');
    for(var i = 0; i < graph.length; ++i) {
        console.log(i);
        for(var k in graph[i]) {
            console.log(k + " " + graph[i][k]['entry']['sha1'] + " " + graph[i][k]['next']);   
        }
    }
    console.log('--------------------');
}

*/

/**Change the graph with git status result
 * added/changed/removed
 * @param graph = graph object returned from tree.js walk
 * @param index = object frmo indexFile.js
 * @statusRes = object representing git status results
 * @return graph[0] sha1
 */

function modifyGraph(graph, index, statusRes) {
    var graphModified = [];
    statusRes.added.forEach(function(path) {
        var sha1 = utils.convertDigestToHex(new Buffer(index.objects[path]['SHA_1'], 'hex'));
        addChangedGraph(path, graph, sha1, graphModified);   
    });
    statusRes.changed.forEach(function(path) {
        var sha1 = utils.convertDigestToHex(new Buffer(index.objects[path]['SHA_1'], 'hex'));
        addChangedGraph(path, graph, sha1, graphModified);   
    });
    statusRes.removed.forEach(function(path) {
        removeGraph(path, graph, graphModified);   
    });
    var sh = fixsha1(graph, graphModified);
    return sh;
}






var getCommitInfo = function(commitInfo) {
    var date = new Date();
    var timeZoneN = -(date.getTimezoneOffset())/60;
    var timeZone = '';
    timeZone += (timeZoneN >= 0) ? '+' : '-';
    timeZone += (Math.abs(timeZoneN) < 10) ? '0' : '';
    timeZone += timeZoneN.toString();
    timeZone += '00';
    var timestamp = Math.floor(date.getTime()/1000);
    var authorInfo = new utils.OperationDetails(commitInfo.author,
                                             commitInfo.authorMail, timestamp, timeZone); 
    var committerInfo = new utils.OperationDetails(commitInfo.committer,
                                                commitInfo.committerMail, timestamp, timeZone);
    return {'tz': timeZone, 'ts':timestamp, 
        'aI' : authorInfo, 'cI' : committerInfo, 'd' : commitInfo.description}
}



/**
 * gitCommitIndex
 * @param repopath = gitpath  example: /home/marcinek/gitrepo/.git/
 * @param commitInfo = dictionary { 'author' : author, 'authorMail' : authorMail,
 * 'committer' : committer, 'committerMail' : committerMail, 'description' : description}
 * @param callback(err, res);  atm res is empty dictionary
 * 
 * gitCommitIndex executes gitStatus, then modifies and creates a new tree and new commit
 * Updates HEAD and refs/heads according to what's there 
 * We can commit if HEAD points to commit which does not exist -> HEAD points to refs/heads/xx
 * and xx doesn't exist(in native git it's the state after git init)
 * 
 * 
 * Example:
 * 
   gcM.gitCommit('/home/xx/gitrepotest/.git/', commitInfo, function(err, result) {
        //it doesn't msg anything and result is empty dict atm
   });
 */

exports.emptyCommit = function(repopath, commitInfo, callback) {
    var result = {};
    var cI = getCommitInfo(commitInfo);
    var parents = [];
    var graph = [{}];
    tM.graphToRepo(repopath, graph, function(err) {
        if (err) {
            callback(err);
            return;
        }
        var commitObject = new cM.Commit(getSha1(graph[0]), parents,
            cI.d, cI.aI, cI.cI);
        var newHeadSha1 = commitObject.getSha1();
        commitObject.save(repopath, function(err) {;
            if (err) {
                callback(err);
                return;
            }
            guM.updateHead(repopath, newHeadSha1, function(err) {    
                if (err) {
                    callback(err);
                    return;
                }
                callback(undefined);
            });              
        });
    });
}

exports.gitCommitIndex = function(repopath, commitInfo, callback) {
    var cI = getCommitInfo(commitInfo);
    
    function work() {
        gsM.gitStatus(repopath, function(err, statusRes, treeDir, graph, index) {
            if (err) {
                callback(err);
                return;
            }
            if (statusRes.conflicts.length > 0) {
                callback(null);
                return;
            }/* ORION ALLOWS EMPTY COMMITS
            if (statusRes.changed.length === 0 && statusRes.added.length === 0 &&
                statusRes.removed.length === 0) {
                callback(null, 'can\'t commit');
                return ;
            }*/
            var function1 = function(err, headSha1) {
                if (err) {
                    callback(err);
                    return;
                }
                var parents = [];
                if(headSha1 !== undefined) {
                    parents.push(headSha1);
                }
                var treeSha1 = modifyGraph(graph, index, statusRes);
                tM.graphToRepo(repopath, graph, function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var commitObject = new cM.Commit(treeSha1, parents,
                        cI.d, cI.aI, cI.cI);
                    var newHeadSha1 = commitObject.getSha1();
                    commitObject.save(repopath, function(err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        guM.updateHead(repopath, newHeadSha1, function(err) {           
                            if (err) {
                                callback(err);
                                return;
                            }
                            fs.unlink(ph.join(repopath, 'MERGE_MSG'), function(err) {
                                callback(null, commitObject);
                            });
                            
                        });              
                    });
                });
            };
            if (err) {
                callback(err);
                return;
            }
            if (graph === undefined) {
                graph = [{}];
                function1(null, undefined);
            } else {
                guM.getHeadSha1(repopath, function1);
            }
        });
    }
    
    if ( !cI.d) {
        cPM.load(repopath, function(err, cParser) {
            if (err) {
                callback(err);
                return;
            } else {
                cI.d = cParser.description;   
                work();
            }
        });
    } else {
        work();   
    }
}



exports.gitCommitAmend = function(repopath, commitInfo, callback) {
    var cI = getCommitInfo(commitInfo);
    
    function work() {
        gsM.gitStatus(repopath, function(err, statusRes, treeDir, graph, index) {
            if(statusRes.conflicts.length > 0) {
                callback(null, 'conflicts');
                return;
            }
            var function1 = function(err, parents) {
                if (err) {
                    callback(err);
                    return;
                }
                var treeSha1 = undefined;
                var function2 = function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var commitObject = new cM.Commit(treeSha1, parents,
                        cI.d, cI.aI, cI.cI);
                    var newHeadSha1 = commitObject.getSha1();
                    commitObject.save(repopath, function(err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        guM.updateHead(repopath, newHeadSha1, function(err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            callback(null, commitObject);
                        });              
                    });   
                }
                if (statusRes.changed.length === 0 && statusRes.added.length === 0 &&
                    statusRes.removed.length === 0) {
                    treeSha1 = getSha1(graph[0]);
                    function2();
                } else {
                    treeSha1 = modifyGraph(graph, index, statusRes);
                    tM.graphToRepo(repopath, graph, function2);
                }
            };
            if (err) {
                callback(err);
                return;
            }
            if (graph === undefined) {
                callback(null);  //cant amend if there's no commit
            } else {
                guM.getHeadCommitParents(repopath, function1);
            }
            
        });
    }
    cPM.load(repopath, function(err, cParser) {
        if (err) {
            work();
        } else {
            callback(err);
        }
    });
}

exports.gitCommitSingleFile = function(repopath, commitInfo, path, callback) {
    var cI = getCommitInfo(commitInfo);
    function work() {
        gsM.gitStatus(repopath, function(err, statusRes, treeDir, graph, index) {
            if(statusRes.conflicts.length > 0) {
                callback(null, 'conflicts');
                return;
            }
            var function1 = function(err, headSha1) {
                if (err) {
                    callback(err);
                    return;
                }
                var parents = [];
                if(headSha1 !== undefined) {
                    parents.push(headSha1);
                }
                if(statusRes.modified.indexOf(path) > -1 || statusRes.added.indexOf(path) > -1 ||
                    statusRes.changed.indexOf(path) > -1) {     
                    var path2 = ph.join(ph.normalize(ph.join(repopath,'..')), path);
                    fs.readFile(path2, function(err, data) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        bM.fileToBlob(data, function(err, data) {            
                            if (err) {
                                callback(err);
                                return;
                            }
                            var sha1 = utils.getSha1(data);
                            var graphModified = [];
                            addChangedGraph(path, graph, sha1, graphModified);
                            var treeSha1 = fixsha1(graph, graphModified);
                            gaM.addOneFile(ph.join(repoPath,path), repopath, function(err) {
                                if (err) {
                                    callback(err);
                                    return;
                                }
                                tM.graphToRepo(repopath, graph, function(err) {
                                    if (err) {
                                        callback(err);
                                        return;
                                    }
                                    var commitObject = new cM.Commit(treeSha1, parents,
                                        cI.d, cI.aI, cI.cI);
                                    var newHeadSha1 = commitObject.getSha1();
                                    commitObject.save(repopath, function(err) {
                                        if (err) {
                                            callback(err);
                                            return;
                                        }
                                        guM.updateHead(repopath, newHeadSha1, function(err) {                                   
                                            if (err) {
                                                callback(err);
                                                return;
                                            }
                                            callback(null, commitObject);
                                        });              
                                    });
                                });
                            });
                        });
                    });
                } else {
                    callback(null, 'fail');   
                }
            };
            var result = 0;
            if (err) {
                callback(err);
                return;
            }
            if (graph === undefined) {
                graph = [{}];
                function1(null, undefined);
            } else {
                guM.getHeadSha1(repopath, function1);
            }
        });
    }   
    
    cPM.load(repopath, function(err, cParser) {
        if (err) {
            work();
        } else {
            callback(err);
        }
    });
}




/*  createFile - creates relativepath file inside repo;
 *  if contents are undefined , sha1 should be sha1 of correct blob
 *  it creates inside repo file with that sha1
 *  if contents are defined it creates file with that content..
 *  
 */
function createFile(repopath, relativepath, contents, sha1, callback) {
    var workPath = ph.normalize(ph.join(repopath,'..'));
    var splitRP = relativepath.split(ph.sep);
    
    function work(i) {
        workPath = ph.join(workPath, splitRP[i]);
        if (i < splitRP.length - 1) {
            fs.exists(workPath, function(exists) {
                if (exists) {
                    work(i+1);    
                } else {
                    fs.mkdir(path, 0777, function(err) {
                        if(err) callback(err);
                        else work(i+1);
                    });
                }
            });
        } else {
            
            if(contents === undefined) {
                saveBlobAsFile(sha1, repopath, workPath, callback)
            } else {
                fs.writeFile(workPath, contents, callback);
            }
        }
    }
    work(0);
}




//diffContents -> creates string with contents
function diffContents(sha1, diff)
{
    //TODO native git behaves strange in some cases
   
    /* namely 
     * US:
     * X
     * Y
     * THEM 
     * X
     * cherrypick deletes Y from US
     * and other strange cases when there's difference at the begining or end of the file
     * 
     * this version treats that events as conflicts...
     * this version is ok for now
     * 
     */
    var str = '';
    var added = '';
    var removed = '';
    var addBool = false;
    var removeBool = false;
    var work = function() {
        str += '<<<<<<< HEAD\n';
        str += removed;
        str += '=======\n';
        str += added;
        str += '>>>>>>> ' + sha1 + '\n';
        added = '';
        removed = '';
        addBool = false;
        removeBool = false;
    }
    for (var i = 0; i < diff.length; ++i) {
        var lines = diff[i]['value'].split('\n');
        if (addBool && removeBool) {
            work();  
        }
        if (!diff[i]['added'] && !diff[i]['removed']) {
            if (addBool || removeBool) {
                work();
            }
            str += diff[i]['value'];
        }
        else if (diff[i]['added']) {
            addBool = true;
            for (var j = 0; j < lines.length - 1; ++j) {
                added = added + lines[j] + '\n';
            }
        }
        else {
            removeBool = true;
            for (var j = 0; j < lines.length - 1; ++j) {
                removed = removed + lines[j] + '\n';
            }
        }
    } 
    if (addBool || removeBool) {
        work();
    }
    return str;
}



/*
 * git cherry pick
 * commitsha1 is the commit we want to cherrypick to our head
 * it creates file MERGE_MSG inside .git/
 * which contains the information about the conflicts and possible commit description
 * if there are any conflicts...
 * 
 */
exports.gitCherryPick = function gitCherryPick(repopath, commitsha1, callback) {
    var conflicts = [];
    var okFiles = [];
    var pending = 0;
    var commitheadsha1 = ''; 
    var commitDesc = '';
    var commitInfo = {};
    var result = 'Nothing';  
    var doIndexWork = function() {
    
        fs.unlink(ph.join(repopath, 'index'), function(err) {
            if(err) callback(err);
            else {
                var endFunction = function(err) {
                    if (err) callback(err);
                    //var description = 'Merge branch ' + 
                     //       commitsha1 + ' into ' + commitheadsha1 + '.';
                    var description = commitDesc;
                    if (conflicts.length > 0) {
                        var cParser = new cPM.conflictParser(repopath);
                        cParser.setDescription2(commitDesc);
                        cParser.setConflicts(conflicts);
                        cParser.save(function(err) {
                            if (err) {
                                callback(err);
                                return;
                            }
                            callback(undefined, result);
                        });
                    } else if(result === 'OK') {
                        commitInfo.description = description;                      
                        gitCommitIndex(repopath, commitInfo, function(err, res) {
                            callback(undefined, result); 
                        });
                    } else {
                        callback(undefined, result);   
                    }
                };
                if(okFiles.length > 0) {   
                    gaM.addManyFiles(okFiles, repopath, endFunction);
                } else {
                    endFunction(undefined);   
                }
                
            }
        });
    };
    
    var doFileWork = function(filepath, sha1_1, sha1_2) {
        //
        if(sha1_1 && !sha1_2) {
            okFiles.push(ph.join(ph.normalize(ph.join(repopath,'..')), filepath));
            if (!--pending) doIndexWork();
        } else if(!sha1_1 && sha1_2) {
            if (result !== 'Conflicting') {
                result = 'OK';   
            }
            okFiles.push(ph.join(ph.normalize(ph.join(repopath,'..')), filepath));
            createFile(repopath, filepath, undefined, sha1_2, function(err) {
                if (err) callback(err); 
                else { 
                    if (!--pending) doIndexWork();
                }
            });
        } else {
            
            conflicts.push(filepath);
            diffM.getDiffCommitCommit(repopath, commitheadsha1, commitsha1, function(err, diffs) {
                
                if (err) {
                    callback(err);
                    return;
                }
                if (diffs[filepath].length === 1) {
                    okFiles.push(ph.join(ph.normalize(ph.join(repopath,'..')), filepath));
                    if (!--pending) doIndexWork();
                } else {
                    result = 'Conflicting';
                    createFile(repopath, filepath, diffContents(sha1_2, diffs[filepath]), undefined, function(err) {   
                        
                        if (err) callback(err); 
                        else { 
                            if (!--pending) doIndexWork();
                        }
                    });
                }
            }, filepath);   
        }
    };
    function work() {
        gsM.gitStatus(repopath, function(err, statusRes, treePaths1, graph1, index) {
            if (err) {
                callback(err);
                return;
            }
            
            if(statusRes.conflicts.length > 0) {
                
                callback(null, 'conflicts');
                return;
            }
            
            if (!graph1) {
                
                callback(undefined, 'no head');
                return;
            }
            if (statusRes.modified.length !== 0 || statusRes.added.length !== 0 ||
                statusRes.changed.length !== 0 || statusRes.removed.length !== 0) {
                callback(undefined, 'Nothing'); //orion seems to throw Nothing when working tree differs from head
                
                return;
            }
            guM.getHeadSha1(repopath, function(err, sha1) {
                if (err) {
                    callback(err);
                    return;
                }
                commitheadsha1 = sha1;
                guM.getCommitAndTreeDir(repopath, commitsha1, function(err, commit, treePaths2, graph2) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    commitInfo.author = commit.author.author;
                    commitInfo.authorMail = commit.author.authorMail;
                    commitInfo.description = commit.description;
                    commitInfo.committer = commit.committer.author;
                    commitInfo.committerMail = commit.committer.authorMail;
                    commitDesc = commit.description;
                    var treePaths1Keys = Object.keys(treePaths1);
                    var treePaths2Keys = Object.keys(treePaths2);
                    treePaths1Keys.sort();
                    treePaths2Keys.sort();
                    var itpK1 = 0;
                    var itpK2 = 0;
                    var callPar = [];
                    var finished = false;
                    while (!finished) {
                        var getMinTmp = [];
                        var sha1_1 = undefined;
                        var sha1_2 = undefined;
                        pending++;               
                        if (itpK1 < treePaths1Keys.length)
                            getMinTmp.push(treePaths1Keys[itpK1]);
                        if (itpK2 < treePaths2Keys.length)
                            getMinTmp.push(treePaths1Keys[itpK2]);
                        getMinTmp.sort();
                        if (treePaths1Keys.indexOf(getMinTmp[0]) > -1) {
                            itpK1++;
                            sha1_1 = treePaths1[getMinTmp[0]]['sha1'];
                        }
                        if (treePaths2Keys.indexOf(getMinTmp[0]) > -1) {
                            itpK2++;
                            sha1_2 = treePaths2[getMinTmp[0]]['sha1'];
                        }
                        callPar.push([getMinTmp[0], sha1_1, sha1_2]);
                        finished = (itpK1 === treePaths1Keys.length && itpK2 === treePaths2Keys.length);
                    }  
                    for (var i = 0; i < callPar.length; ++i) {
                        doFileWork(callPar[i][0], callPar[i][1], callPar[i][2]); 
                    }
                    
                }); 
            });       
        });
    }
    cPM.load(repopath, function(err, cParser) {
        if (err) {
            work();
        } else {
            callback(err);
        }
    });
}



/*           
function intersection_destructive(a, b)
{
  var result = new Array();
  while( a.length > 0 && b.length > 0 )
  {  
     if      (a[0] < b[0] ){ a.shift(); }
     else if (a[0] > b[0] ){ b.shift(); }
     else //they are equal
     {
       result.push(a.shift());
       b.shift();
     }
  }

  return result;
}            
            

function getTwoCommitStatus(repopath, sha1_1, sha1_2, callback) {
    var commit1Ancestors = {};
    var commit2Ancestors = {};
    try {
        gCCM.getCommitAncestors(repopath, sha1_1, commit1Ancestors, function(err) {
            if (err) throw err;
            gCCM.getCommitAncestors(repopath, sha1_2, commit2Ancestors, function(err) {
                if (err) throw err;
                if (sha1_1 in commit2Ancestors) {
                    callback(undefined, 'fast-forward');   
                } else if (sha1_2 in commit1Ancestors) {
                    callback(undefined, 'already-up-to-date');   
                } else {
                    if (intersection_destructive().length > 0) {
                        
                    } else {
                        throw err   
                    }
                } 
            });
        });
    } catch (err) {
        callback(err);
    }
    
}
*/
//TODO IMPLEMENT 3 way merge strategy