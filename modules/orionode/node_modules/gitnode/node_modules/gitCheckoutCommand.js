var rM = require('refs');
var fs = require('fs');
var utils = require('utils');
var commit = require('commit');
var tree = require('tree');
var blob = require('blob');
var iM = require('indexFile');
var gitutils = require('gitutils');


/**
 * Changes one state of working directory to another, described by commit
 * @param commitDescription SHA_1 of the commit or branch name
 * @param repoPath path to .git folder
 * @param callback callback(err)
 */
var gitCheckout = function(commitDescription, repoPath, callback) {
	var indexManager = new iM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
		var refsManager = new rM.Refs(repoPath, function(err) {
			if (err) {
				callback(err);
				return;
			}
			getCommitSHA_1(repoPath, commitDescription, function(err, commitSHA_1){
				if (err) {
					if (err != ('error: pathspec \'' + commitDescription + '\' did not match any file(s) known to git')) {
						callback(err);
						return;
					}
					gitutils.getHeadSha1(repoPath.slice(0, repoPath.length - 4) + '/.git', function(err, headSHA_1) {
						if (err) {
							callback(err);
							return;
						}
						commit.readFileToCommit(headSHA_1, repoPath, function(err, commitObject) {
                            if (err) {
                                callback(err);
                                return;
                            }
							var treeSHA_1 = commitObject.objectId;
							removeFiles(treeSHA_1, repoPath, repoPathToRootPath(repoPath), indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								fs.writeFile(repoPath + '/HEAD', 'ref: refs/heads/' + commitDescription, function (err) {
									if (err) {
										callback(err);
										return;
									}
									refsManager.getBranchSHA_1UsingName(commitDescription, function(err, branchSHA_1) {
										commit.readFileToCommit(branchSHA_1, repoPath, function(err, commitObject) {
											var treeSHA_1 = commitObject.objectId;
											restoreFiles(treeSHA_1, repoPath, repoPathToRootPath(repoPath), indexManager, function(err) {
												if (err) {
													callback(err);
													return;
												}
												callback('');
												return;
											});
										});
									});
								});
							});
						});
					});
				} else {
					gitutils.getHeadSha1(repoPath.slice(0, repoPath.length - 4) + '/.git', function(err, headSHA_1) {
						if (err) {
							callback(err);
							return;
						}
						commit.readFileToCommit(headSHA_1, repoPath, function(err, commitObject) {
                            if (err) {
                                callback(err);
                                return;
                            }
							var treeSHA_1 = commitObject.objectId;
							removeFiles(treeSHA_1, repoPath, repoPathToRootPath(repoPath), indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								fs.writeFile(repoPath + '/HEAD', commitSHA_1, function (err) {
									if (err) {
										callback(err);
										return;
									}
									commit.readFileToCommit(commitSHA_1, repoPath, function(err, commitObject) {
										var treeSHA_1 = commitObject.objectId;
										restoreFiles(treeSHA_1, repoPath, repoPathToRootPath(repoPath), indexManager, function(err) {
											if (err) {
												callback(err);
												return;
											}
											callback('');
											return;
										});
									});
								});
							});
						});
					});
				}
			});
		});
	});
}

/**
 * Checks if some objects names contain the specified folder name
 * @param folderName name of the folder
 * @param objects some objects
 * @param callback callback(contains)
 */
var isFolderNameInObjects = function(folderName, objects, callback) {
	for (var index in objects) {
		if (folderName == objects[index]) {
			callback(true);
			return;
		}
	}

	callback(false);
	return;
}

/**
 * Checks how many objects have the save short SHA 1
 * @param objects some objects
 * @param SHA_1 specified SHA 1
 * @param callback(objectsNumber)
 */
var howManyObjectsMatchToShortSHA_1 = function(objects, SHA_1, callback) {
	var objectsNumber = 0;
	var SHA_1Last = SHA_1.slice(2);
	var SHA_1LastLength = SHA_1Last.length;
	for (var index in objects) {
		if (SHA_1Last == objects[index].slice(0, SHA_1LastLength)) {
			++objectsNumber;
		}
	}

	callback(objectsNumber);
	return;
}

/**
 * Gets long SHA 1, using short SHA 1
 * @param objects some objects in those SHA 1 will be searched
 * @param shortSHA_1 short SHA 1
 * @param callback(err, longSHA_1)
 */
var getLongSHA_1UsingShortSHA_1 = function(objects, shortSHA_1, callback) {
	var shortSHA_1Last = shortSHA_1.slice(2);
	var objectsNumber = 0;
	var longSHA_1;
	for (var index in objects) {
		if (shortSHA_1Last == objects[index].slice(0, shortSHA_1Last.length)) {
			longSHA_1 = shortSHA_1.slice(0, 2) + objects[index];
			++objectsNumber;
		}
	}

	switch (objectsNumber) {
		case 0: 	callback('fatal: Not a valid object name ' + shortSHA_1, '');
					return;
		case 1: 	callback('', longSHA_1);
					return;
		default:	callback('error: short SHA1 ' + shortSHA_1 + ' is ambiguous', '');
					return;
	}
}

/**
 * Checks if SHA 1, maybe short SHA 1 is correct and returns long SHA 1 or error with comment
 * @param repoPath path to .git folder
 * @param commit commit description
 * @param callback(err, longSHA_1)
 */
var getCommitSHA_1 = function(repoPath, commit, callback) {
	fs.readdir(repoPath + '/objects', function(err, objects) {
		if (err) {
			callback(err, '');
			return;
		}
		var folderName = commit.slice(0, 2);
		isFolderNameInObjects(folderName, objects, function(isFolder) {
			if (!isFolder) {
				callback('error: pathspec \'' + commit + '\' did not match any file(s) known to git', '');
				return;
			}
			fs.readdir(repoPath + '/objects/' + folderName, function(err, objects) {
				howManyObjectsMatchToShortSHA_1(objects, commit, function(objectsNumber) {
					switch (objectsNumber) {
						case 0: 	callback('fatal: Not a valid object name ' + commit, '');
									return;
						case 1: 	getLongSHA_1UsingShortSHA_1(objects, commit, function(err, SHA_1) {
										if (err) {
											callback(err, '');
											return;
										}
										callback('', SHA_1);
										return;
									});
									return;
						default: 	callback('error: short SHA1 ' + commit + ' is ambiguous', '');
									return;
					}
				});
				
			});
		});
	});
}

/**
 * Restores objects recursively
 * @param objects objects to restore
 * @param keys keys in objects dictionary
 * @param index of actually object restoring
 * @param repoPath path to .git folder
 * @param path actually path in file system
 * @param indexManager indexManager for .git/index file
 * @param callback callback(err)
 */
var makeRestoreForEveryObjectOnOneLevel = function(objects, keys, index, repoPath, path, indexManager, callback) {
	if (index == keys.length) {
		callback('');
		return;
	}
	var object = objects[keys[index]];
	var objectId = keys[index];
	if (object.type == 'tree') {
		fs.exists(path + objectId, function(exists) {
			if (exists) {
				restoreFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						callback('');
						return;
					});
				});
			} else {
				fs.mkdir(path + objectId, 0777, function(err) {
					if (err) {
						callback(err);
						return;
					}
					restoreFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					});
				});
			}
		});
	} else if (object.type == 'blob') {
		blob.saveBlobAsFile(object.sha1, repoPath, path + objectId, function(err) {
			if (err) {
				callback(err);
				return;
			}
			indexManager.addObject(path + objectId, function(err) {
				if (err) {
					callback(err);
					return;
				}

				makeRestoreForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					callback('');
					return;
				});
			});
		});
	}		
}

/**
 * Restores objects
 * @param treeSHA_1 SHA 1 of tree object representing directory
 * @param path actually path in file system
 * @param indexManager indexManager for .git/index file
 * @param callback(err)
 */
var restoreFiles = function(treeSHA_1, repoPath, path, indexManager, callback) {
	tree.readFileToTree(treeSHA_1, repoPath, function(err, treeObject) {
		var treeDict = treeObject['entries'];
		var keys = new Array();
		for (var key in treeDict) {
			keys.push(key);
		}
		makeRestoreForEveryObjectOnOneLevel(treeDict, keys, 0, repoPath, path, indexManager, function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});		
	});
}

/**
 * Removes objects recursively
 * @param objects objects to remove
 * @param keys keys in objects dictionary
 * @param index of actually object restoring
 * @param repoPath path to .git folder
 * @param path actually path in file system
 * @param indexManager indexManager for .git/index file
 * @param callback callback(err)
 */
var makeRemoveForEveryObjectOnOneLevel = function(objects, keys, index, repoPath, path, indexManager, callback) {
	if (index == keys.length) {
		callback('');
		return;
	}
	var object = objects[keys[index]];
	var objectId = keys[index];
	if (object.type == 'tree') {
		removeFiles(object.sha1, repoPath, path + objectId + '/', indexManager, function(err) {
			if (err) {
				callback(err);
				return;
			}
			fs.exists(path + objectId, function(exists) {
				if (exists) {
					fs.readdir(path + objectId, function(err, files) {
						if (err) {
							callback(err);
							return;
						}
						if (files.length == 0) {
							fs.rmdir(path + objectId, function(err) {
								if (err) {
									callback(err);
									return;
								}
								makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
									if (err) {
										callback(err);
										return;
									}
									callback('');
									return;
								});
							});
						} else {
							makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
								if (err) {
									callback(err);
									return;
								}
								callback('');
								return;
							});
						}
					});
				} else {
					makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
						if (err) {
							callback(err);
							return;
						}
						callback('');
						return;
					});
				}
			});
		});
	} else if (object.type == 'blob') {
		fs.exists(path + objectId, function(exists) {
			if (exists) {
				indexManager.removeObject(path + objectId, function(err) {
					if (err) {
						callback(err);
						return;
					}
					fs.unlink(path + objectId, function(err) {
						if (err) {
							callback(err);
							return;
						}
						makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					});
				});	
			} else {
				makeRemoveForEveryObjectOnOneLevel(objects, keys, index + 1, repoPath, path, indexManager, function(err) {
					if (err) {
						callback(err);
						return;
					}
					callback('');
					return;
				});
			}
		});
	}		
}

/**
 * Removes objects
 * @param treeSHA_1 SHA 1 of tree object representing directory
 * @param path actually path in file system
 * @param indexManager indexManager for .git/index file
 * @param callback(err)
 */
var removeFiles = function(treeSHA_1, repoPath, path, indexManager, callback) {
	tree.readFileToTree(treeSHA_1, repoPath, function(err, treeObject) {
		var treeDict = treeObject['entries'];
		var keys = new Array();
		for (var key in treeDict) {
			keys.push(key);
		}
		makeRemoveForEveryObjectOnOneLevel(treeDict, keys, 0, repoPath, path, indexManager, function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	});
}

/**
 * Converts from path to /.git to /
 * @param path path to .git folder
 */
var repoPathToRootPath = function(path) {
	var paths = path.split('/');
	while (paths[paths.length - 1] != '.git') {
		paths.pop();
	}
	paths.pop();

	if (paths.length == 0) {
		return '';
	} else {
		return paths.join('/') + '/';
	}
}

/**
 * Restores selected file to it's state from current commit
 * @param filePath path to file
 * @param repoPath path to .git
 * @param callback callback(err)
 */
var discardChanges = function (filePath, repoPath, callback) {
	//filePath = getRelativePath(filePath, repoPath);
	getSteps(filePath, function(pathStructure) {
		gitutils.getHeadCommit(repoPath, function(err, commitCurrent) {
			if (err) {
				callback(err);
				return;
			}
			if (!commitCurrent) {
				callback('There is any commit yet');
				return;
			}
			var goToFileLevel = function(treeDict, stepIndex, path, callback) {
				if (stepIndex == pathStructure['folders'].length) {
					if (!(pathStructure['file'] in treeDict['entries'])) {
						callback('error: pathspec \'' + path + pathStructure['file'] + '\' did not match any file(s) known to git', '');
						return;
					}
					callback('', treeDict);
					return;
				}
				if (!(pathStructure['folders'][stepIndex] in treeDict['entries'])) {
					callback('error: pathspec \'' + path + pathStructure['folders'][stepIndex] + '/' + '\' did not match any file(s) known to git', '');
					return;
				}
				tree.readFileToTree(treeDict['entries'][pathStructure['folders'][stepIndex]]['sha1'], repoPath, function(err, treeDict) {
					if (err) {
						callback(err);
						return;
					}
					goToFileLevel(treeDict, stepIndex + 1, path + pathStructure['folders'][stepIndex] + '/', function(err, treeDict) {
						if (err) {
							callback(err, '');
							return;
						}
						callback('', treeDict);
						return;
					});
				});				
			};
			var makeFolderPathOnDisk = function(path, stepIndex, callback) {
				if (stepIndex == pathStructure['folders'].length) {
					callback('');
					return;
				}
				fs.exists(path + pathStructure['folders'][stepIndex], function (exists) {
					if (!exists) {
						fs.mkdir(path + pathStructure['folders'][stepIndex], function(err) {
							if (err) {
								callback(err);
								return;
							}
							makeFolderPathOnDisk(path + pathStructure['folders'][stepIndex] + '/', stepIndex + 1, function(err) {
								if (err) {
									callback(err);
									return;
								}
								callback('');
								return;
							});
						});
					} else {
						makeFolderPathOnDisk(path + pathStructure['folders'][stepIndex] + '/', stepIndex + 1, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					}
				});
			};
			tree.readFileToTree(commitCurrent.objectId, repoPath, function(err, treeDict) {
				if (err) {
					callback(err);
					return;
				}
				goToFileLevel(treeDict, 0, '', function(err, fileLevel) {
					if (err) {
						callback(err);
						return;
					}
					makeFolderPathOnDisk(repoPathToRootPath(repoPath), 0, function(err) {
						if (err) {
							callback(err);
							return;
						}
						blob.saveBlobAsFile(fileLevel['entries'][pathStructure['file']]['sha1'], repoPath, repoPathToRootPath(repoPath) + filePath, function(err) {
							if (err) {
								callback(err);
								return;
							}
							callback('');
							return;
						});
					});
				});
			});
		});
	});
}

var getRelativePath = function (path, repoPath, callback) {
    return path.slice(path.slice(repoPath.length - 4));
}

var getSteps = function (path, callback) {
    //console.log(path);
	var steps = path.split('/');
	var structure = new Array();
	structure['folders'] = steps.slice(0, steps.length - 1);
	structure['file'] = steps[steps.length - 1];

	callback(structure);
	return;
}

exports.gitCheckout = gitCheckout;
exports.discardChanges = discardChanges;
