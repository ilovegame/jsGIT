var utils = require('utils');

/* Creates Tag object
 * @ param objectId - sha1 sum of file content
 * @ param type
 * @ param name - tag name
 * @ param description - tag description
 * @ param tagger - OperationDetails object
 */
function Tag(objectId, type, name, description, tagger)
{
	this.objectId = objectId;
	this.type = type;
	this.name = name;
	this.description = description;
	this.tagger = tagger;
}

/* Saves Tag object to file
 * @callback - function (err)
 */
Tag.prototype.toFile = function()
	{
		var newLine = '\n';
		var data = 'object ' + this.objectId + newLine;
		data += 'type ' + this.type + newLine;
		data += 'tag ' + this.name + newLine;
		data += 'tagger ' + this.tagger.toString() + newLine;
		data += newLine;
		data += this.description + newLine;
		data = 'tag ' + data.length  + '\0'+ data;
		return data;
	};

/* Parses data to Tag, returns [false, null] for incorrect data
 * and [true, Tag object] otherwise
 * @data buffer with tag file content
 */
function parse(data)
{
	var dataToSplit = data.toString('utf-8', 0, data.length);
	var lines = dataToSplit.split('\n');

	if (lines.length !== 7)
	{
		return [false, null];
	}
	//parsing line 1 (tag bytes\uuuuobject sha1)
	if (lines[0].substring(0,4) !== 'tag ' || lines[0].indexOf('\u0000object ') === -1)
	{
		return [false, null];
	}
	var header = utils.splitByFirst(lines[0], '\u0000object ');
	var objectId = header[1];
	var lengthStr = utils.splitByFirst(header[0], 'tag ')[1];
	var length = parseInt(lengthStr);
	if (isNaN(length))
	{
		return [false, null];
	}
	var contentSize = data.length - header[0].length - 1;
	if (length !== contentSize)
	{
		return [false, null];
	}
	//parsing line 2 (type ...)
	if (lines[1].substring(0,5) !== 'type ')
	{
		return [false, null];
	}
	var type = utils.splitByFirst(lines[1], 'type ')[1];
	
	//line 3
	var name = utils.splitByFirst(lines[2], ' ')[1];
	
	//parsing line 4
	if (lines[3].substring(0,7) !== 'tagger ') {
		return [false, null];
	}
	
	var taggerDetails = utils.splitByFirst(lines[3], 'tagger ');
	var tagger = utils.parseOperationDetails(taggerDetails[1]);
	if (tagger === null) {
		return [false, null];
	}
	//line 6
	var description = lines[5];
	
	//parsing lines 5, 7
	if (lines[4] !== '' || lines[6] !== '')
	{
		return [false, null];
	}

	var tag = new Tag(objectId, type, name, description, tagger);
	return [true, tag];
}



/* Calls parse function and callback with result
 * @data buffer with commit file content
 * @callback function(err, tag)
 */
function tagParser(data, callback)
{
	var parsingResult = parse(data);
	if (!parsingResult[0])
	{
		callback('Tag file: invalid file format', null);
	}
	else
	{
		callback(null, parsingResult[1]);
	}
}

/* Reads tag from file and gives Tag object
 * @sha1 - tag sha1
 * @repoPath - path of .git directory
 */
var readFileToTag = function(sha1, repoPath, callback) {
		utils.readAndParse(sha1, repoPath, tagParser, callback);	
	};

/* Saves Tag object to file
 * @param repoPath - path of .git directory
 * @callback - function (err)
 */
Tag.prototype.save = function (repoPath, callback)
{
	utils.saveObject(this.toFile(), repoPath, {}, callback);
}

Tag.prototype.getSha1 = function()
{
	return utils.getSha1(this.toFile());
}

exports.Tag = Tag;
exports.readFileToTag = readFileToTag;