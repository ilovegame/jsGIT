var utils = require('utils');

/* Creates Commit object
 * @ param objectId - sha1 sum of file data
 * @ param parents - array sha1 sum of commit's parent
 * @ param description - commit description
 * @ param author - OperationDetails object
 * @ param committer - OperationDetails object
 */
//TODO should have sha1
function Commit(objectId, parents, description, author, committer)

{
	this.objectId = objectId;
	this.parents = parents;
	this.description = description;
	this.author = author;
	this.committer = committer;
}



Commit.prototype.getSha1 = function () {
    var buf = this.toFile();
    return utils.getSha1(buf);
}
/* Saves Commit object to file
 * @param repoPath - path of .git directory
 * @callback - function (err)
 */
Commit.prototype.save = function (repoPath, callback)
{
	utils.saveObject(this.toFile(), repoPath, {}, callback);
}

/* Returns commit representation as string, in appropriate git object format */
Commit.prototype.toFile = function ()
{
	var newLine = '\n';
	var data = 'tree ' + this.objectId + newLine;
	var i;
	for (i = 0; i < this.parents.length; ++i)
	{
		data += 'parent ' + this.parents[i] + newLine;
	}
	
	data += 'author ' + this.author.toString() + newLine;
	data += 'committer ' + this.committer.toString() + newLine;
	data += newLine;
	data += this.description + newLine;
	data = 'commit ' + data.length  + '\0'+ data;
	return data;
};

/* Parses data to Commit, returns [false, null] for incorrect data
 * and [true, Commit object] otherwise
 * @data buffer with commit file content
 */
function parse(data)
{
	var dataToSplit = data.toString('utf-8', 0, data.length);
        var lines = dataToSplit.split('\n');

	//parsing 1. line ( commit bytes\uuuutree sha1)
	if (lines[0].substring(0,7) !== 'commit ' || lines[0].indexOf('\u0000tree ') === -1)
	{
		return [false, null];
	}
	var header = utils.splitByFirst(lines[0], '\u0000tree ');
	var objectId = header[1];
	var lengthStr = utils.splitByFirst(header[0], 'commit ')[1];
	var length = parseInt(lengthStr);
	if (isNaN(length))
	{
		return [false, null];
	}
	
	var parentId = null;
	
	var parentsCount = 0;
	var index = 1;
	var parents = new Array();
	
	while (lines[index].substring(0,7) === 'parent ')
	{
		var parentId = utils.splitByFirst(lines[index], 'parent ')[1];
		parents.push(parentId);
		parentsCount++;
		index++;
	}

	if (lines[index].substring(0,7) !== 'author ') {
		return [false, null];
	}
	
	var authorDetails = utils.splitByFirst(lines[index], 'author ');
	index++;
	
	var author = utils.parseOperationDetails(authorDetails[1]);
	if (author === null || lines[index].substring(0,10) !== 'committer ')			
	{
		return [false, null];
	}

	var committerDetails = utils.splitByFirst(lines[index], 'committer ');
	var committer = utils.parseOperationDetails(committerDetails[1]);

	if (committer === null || lines[3 + parentsCount] !== '' || lines[lines.length - 1] !== '')
	{
		return [false, null];
	}
	
	var description = '';
	for (var i = 4 + parentsCount; i <= lines.length - 2; ++i)
	{
		description += lines[i];
		if (i < lines.length - 2)
		{
			 description += '\n';
		}
	}
	var commit = new Commit(objectId, parents, description, author, committer);
	
	return [true, commit];
}

/* Calls parse function and callback with result
 * @data buffer with commit file content
 * @callback function(err, commit)
 */
function commitParser(data, callback)
{
	var parsingResult = parse(data);
	if (!parsingResult[0])
	{
		callback('Commit file: invalid file format', null);
	}
	else
	{
		callback(null, parsingResult[1]);
	}
}

/* Reads commit from file and gives Commit object
 * @sha1 - commit sha1
 * @repoPath - path of .git directory
 */
var readFileToCommit = function(sha1, repoPath, callback) {
		utils.readAndParse(sha1, repoPath, commitParser, callback);	
	};

exports.Commit = Commit;
exports.readFileToCommit = readFileToCommit;