var utils = require('utils');

/* Creates Commit object
 * @ param objectId - sha1 sum of file data
 * @ param parentId - sha1 sum of commit's parent
 * @ param description - commit description
 * @ param author - OperationDetails object
 * @ param committer - OperationDetails object
 */3
function Commit(objectId, parentId, description, author, committer)
{
	this.objectId = objectId;
	this.parentId = parentId;
	this.description = description;
	this.author = author;
	this.committer = committer;
}



Commit.prototype.getSha1 = function () {
    var buf = this.toFile();
    return utils.getSha1(buf);
}
/* Saves Commit object to file
 * @param repoPath - path of .git directory
 * @callback - function (err)
 */
Commit.prototype.save = function (repoPath, callback)
{
	utils.saveObject(this.toFile(), repoPath, {}, callback);
}

/* Returns commit representation as string, in appropriate git object format */
Commit.prototype.toFile = function ()
{
	var newLine = '\n';
	var data = 'tree ' + this.objectId + newLine;
	if (this.parentId != null) {
		data += 'parent ' + this.parentId + newLine;
	}
	data += 'author ' + this.author.toString() + newLine;
	data += 'committer ' + this.committer.toString() + newLine;
	data += newLine;
	data += this.description + newLine;
	data = 'commit ' + data.length  + '\0'+ data;
	return data;
};

/* Parses data to Commit object
 * @data buffer with commit file content
 * @callback function(err, commit)
 */
function commitParser(data, callback)
{
        var dataToSplit = data.toString('utf-8', 0, data.length);
        var lines = dataToSplit.split('\n');

	if (lines.length != 6 && lines.length != 7)
	{
		callback( 'Commit file: invalid file format', null);
	}
	//parsing 1. line ( commit bytes\uuuutree sha1)
	if (lines[0].substring(0,7) != 'commit ' || lines[0].indexOf('\u0000tree ') == -1)
	{
		callback('Commit file: invalid file format', null);
	}
	var header = utils.splitByFirst(lines[0], '\u0000tree ');
	var objectId = header[1];
	var lengthStr = utils.splitByFirst(header[0], 'commit ')[1];
	var length = parseInt(lengthStr);
	if (isNaN(length))
	{
		callback('Commit file: invalid file format', null);
	}
	
	var parentId = null;
	
	//parsing 2. line, maybe: parent sha1
	var hasParent = 0;
	if (lines[1].substring(0,7) == 'parent ')
	{
		parentId = utils.splitByFirst(lines[1], 'parent ')[1];
		hasParent = 1;
	}
	
	if (lines[1 + hasParent].substring(0,7) != 'author ') {
		callback('Commit file: invalid file format', null);
	}
	
	//parsing 2. or 3. line (it depends on hasParent)
	var authorDetails = utils.splitByFirst(lines[1 + hasParent], 'author ');
	var author = utils.parseOperationDetails(authorDetails[1]);
	if (author == null || lines[2 + hasParent].substring(0,10) != 'committer ')			
	{
		callback('Commit file: invalid file format', null);
	}

	var committerDetails = utils.splitByFirst(lines[2 + hasParent], 'committer ');
	var committer = utils.parseOperationDetails(committerDetails[1]);
	
	//parsing 4. or 5. line
	if (committer == null || lines[3 + hasParent] != '' || lines[5 + hasParent] != '')
	{
		callback('Commit file: invalid file format', null);
	}
	
	var description = lines[4 + hasParent];
	var commit = new Commit(objectId, parentId, description, author, committer);
	callback(null, commit);
}

/* Reads commit from file and gives Commit object
 * @sha1 - commit sha1
 * @repoPath - path of .git directory
 */
var readFileToCommit = function(sha1, repoPath, callback) {
		utils.readAndParse(sha1, repoPath, commitParser, callback);	
	};

exports.Commit = Commit;
exports.readFileToCommit = readFileToCommit;