var iFM = require('indexFile');
var bM = require('blob');
var utils = require('utils');
var gsM = require('gitstatus.js');
var cPM = require('conflictParser.js');
var ph = require('path');
var gsM = require('gitstatus.js');
var fs = require('fs');
/**
 * adds one file to .git/index file
 * and creates representation in .git/objects directory
 * @param path path to file
 * @param repoPath path to .git directory
 * @param callback callback(err)
 */
var addOneFile = function(path, repoPath, callback) {
    var jobsCompleted = 0;
    var jobsAll = 2;
    var finished = false;
    var relativePath =  path.slice(ph.normalize(ph.join(repoPath,'..')).length+1);
    var work = function() {
        var indexFileManager = new iFM.Index(repoPath, function(err) {
            if (err) {
                callback(err);
                return;
            }
            fs.exists(path, function (exists) {
                if (exists) {
                    indexFileManager.addObject(path, function(err) {
                        if (err) {
                            finished = true;
                            if (!finished) {
                                callback(err);
                            }
                            return;
                        }
                        ++jobsCompleted;

                        if (jobsCompleted == jobsAll) {
                            callback('');
                            return;
                        }
                    });
                    bM.saveFileAsBlob(path, repoPath, {}, function(err) {
                        if (err) {
                            finished = true;
                            if (!finished) {
                                callback(err);
                            }
                            return;
                        }
                        ++jobsCompleted;

                        if (jobsCompleted == jobsAll) {
                            callback('');
                            return;
                        }
                    });
                } else {
                    indexFileManager.removeObject(path, function(err) {
                        if (err) {
                            callback(err);
                            return;
                        }
                        callback(undefined);
                    });
                }
            });
        });       
    }
    
    //pobierz conflikty
    //wyjeb z konfliktow
    //jesli byl w konfliktach nic nie rob ->koniec
    //jesli plik nie istnieje wywal z indexu -> byc moze error?
    cPM.load(repoPath, function(err, cParser) {
        if (err) {
            work();   
        } else {
            if (cParser.prototype.removeConflict(relativePath)) {
                 cParser.save(function(err) {
                     if (err) {
                        callback(err);
                        return;
                     }
                     callback('');
                 });
            } else {
                work();   
            }
        }
    });
    
}

/**
 * adds many files to .git/index file
 * and creates representations in .git/objects directory
 * @param path paths in array to files
 * @param repoPath path to .git directory
 * @param callback callback(err)
 */
var addManyFiles = function(paths, repoPath, callback) {
	var addOneFileRecursively = function(index, callback) {
		if (paths.length == index) {
			callback('');
			return;
		}
		addOneFile(paths[index], repoPath, function(err) {
			if (err) {
				callback(err);
				return;
			}
			addOneFileRecursively(index + 1, function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
		});
	}
	addOneFileRecursively(0, function(err) {
		if (err) {
			callback(err);
			return;
		}
		callback('');
		return;
	});
}

/**
 * removes one file from .git/index file
 * @param path path to file
 * @param repoPath path to .git directory
 * @param callback callback(err)
 */
var removeOneFile = function(path, repoPath, callback) {
	var indexFileManager = new iFM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
    	indexFileManager.removeObject(path, function(err) {
    		if (err) {
    			callback(err);
    			return;
    		}
    		callback('');
    		return;
    	});
    });
}

/**
 * removes many files from .git/index file
 * @param path paths in array to files
 * @param repoPath path to .git directory
 * @param callback callback(err)
 */
var removeManyFiles = function(paths, repoPath, callback) {
	var removeOneFileRecursively = function(index, callback) {
		if (paths.length == index) {
			callback('');
			return;
		}
		removeOneFile(paths[index], repoPath, function(err) {
			if (err) {
				callback(err);
				return;
			}
			removeOneFileRecursively(index + 1, function(err) {
				if (err) {
					callback(err);
					return;
				}
				callback('');
				return;
			});
		});
	}
	removeOneFileRecursively(0, function(err) {
		if (err) {
			callback(err);
			return;
		}
		callback('');
		return;
	});
}

/**
 * removes all files from .git/index file
 * @param repoPath path to .git directory
 * @param callback callback(err)
 */
var removeAllFiles = function(repoPath, callback) {
	var indexFileManager = new iFM.Index(repoPath, function(err) {
		if (err) {
			callback(err);
			return;
		}
		indexFileManager.removeAllObjects(function(err) {
			if (err) {
				callback(err);
				return;
			}
			callback('');
			return;
		});
	});
}

/**
 * gets content and size of the file
 * @param path path to file
 * @param repoPath path to .git
 * @param callback callback(err, content_and_size)
 */
//TODO temp solution.
var getFileContent = function(path, repoPath, callback) {
	var indexFileManager = new iFM.Index(repoPath, function() {
		indexFileManager.getObject(path, function(err, object) {
            if (err)
            {
                callback('');
            }
            else
            {
                var returnInfo = new Array();
                returnInfo['ContentLength'] = object['size'];
                utils.readObjectAndType(object['SHA_1'], repoPath, function(err, objectContent, objectType) {
                    returnInfo['Content'] = objectContent.toString('utf8')
                    callback(returnInfo);
                });
            }
		});
	});
}

exports.addOneFile = addOneFile;
exports.addManyFiles = addManyFiles;
exports.removeOneFile = removeOneFile;
exports.removeManyFiles = removeManyFiles;
exports.removeAllFiles = removeAllFiles;
exports.getFileContent = getFileContent;
