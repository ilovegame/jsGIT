/*
 * Algorithm:
 * https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java
 * Take 
 * tree paths
 * index paths
 * workdir paths
 * sort them in alphabetical order
 * take the first one of them and do the following
 * (kind of like sorting sorted lists in mergesort):
 * one if else
 * // in repo, in index, content diff => changed
 * // in repo, not in index => removed
 * // not in repo, in index => added
 * // not in repo, not in index => untracked
 * 
 * and then:
 * // in index, not in workdir => missing
 * // in index, in workdir, content differs => modified
 * 
 * return to callback results
 * 
 * 
 * We also return all paths and treegraph to callback
 * 
 * if head points to commit which does not exist
 * we return graph = undefined to callback and treeInfo = {}
 * 
 * treeInfo and graph are of the same format as the result of tree.walk 
 * from tree.js
 * 
 * 
 * Usage example:
 * 
 * 
 * 
gitstatus.status('/home/marcinek/gitrepotest/', function(err, result, treeInfo, graph) {
    if(err) {
        console.log(err)   
    } else {
        console.log(result.modified);
        console.log(result.untracked);
        console.log(result.added);
        console.log(result.missing);
        console.log(result.changed);
        console.log(result.removed);
        console.log(result.conflicts);
        console.log(treeInfo);
        console.log(graph);
    }
});
 */
var gitindex = require('indexFile.js');
var dw = require('dirwalk.js');
var gitcommit = require('commit.js');
var tree_module = require('tree.js');
var utils = require('utils.js');
var guM = require('gitutils.js');
var bM = require('blob.js');
var fs = require('fs');
var ph = require('path');
var cPM = require('conflictParser.js');

exports.gitStatus = function(repopath, callback) {
    
    
    var function2 = function(treeInfo, index, workdir, graph) {
        console.log('bug5');
        var treeKeys = Object.keys(treeInfo);
        var indexKeys = Object.keys(index.objects);
        var workdirKeys = Object.keys(workdir);
        var treeC = 0;
        var indexC = 0;
        var workdirC = 0;
        var result = {};
        result.modified = [];
        result.untracked = [];
        result.added = [];
        result.removed = [];
        result.missing = [];
        result.changed = [];
        result.conflicts = [];
        var pending = 0;
        treeKeys.sort();
        indexKeys.sort();
        workdirKeys.sort();     
        cPM.load(repopath, function(err, cParser) {
            console.log('bug6');
            if (!err)
                result.conflicts = cParser.conflicts;
            while (treeC < treeKeys.length || indexC < indexKeys.length || workdirC < workdirKeys.length) {
                console.log('bug7 ' + treeC + ' ' + indexC + ' ' + workdirC);
                var tmparray = []
                if(treeC < treeKeys.length) tmparray.push(treeKeys[treeC]);
                if(indexC < indexKeys.length) tmparray.push(indexKeys[indexC]);
                if(workdirC < workdirKeys.length) tmparray.push(workdirKeys[workdirC]);
                tmparray.sort();
                
                if(treeInfo[tmparray[0]] !== undefined) treeC++;
                if(index.objects[tmparray[0]] !== undefined) indexC++;
                if(workdir[tmparray[0]] !== undefined) workdirC++;
                
                if (treeInfo[tmparray[0]] !== undefined) {
                    if(index.objects[tmparray[0]] === undefined) {
                        // in repo, not in index => removed
                        if(result.conflicts.indexOf(tmparray[0]) === -1)
                            result.removed.push(tmparray[0]);   
                    } else {
                        //in repo, in index, content diff => changed
                        if(treeInfo[tmparray[0]]['sha1']
                            !== utils.convertDigestToHex(new Buffer(index.objects[tmparray[0]]['SHA_1'], 'hex'))) {
                            if(result.conflicts.indexOf(tmparray[0]) === -1)
                                result.changed.push(tmparray[0]);
                        }
                    }
                } else {          
                    if(index.objects[tmparray[0]] === undefined) {
                        // not in repo, not in index => untracked
                        if(result.conflicts.indexOf(tmparray[0]) === -1)
                            result.untracked.push(tmparray[0]);   
                    } else {
                        // not in repo, in index => added
                        if(result.conflicts.indexOf(tmparray[0]) === -1)
                            result.added.push(tmparray[0]);  
                    }
                }
                
                if(index.objects[tmparray[0]]) {
                    if(workdir[tmparray[0]] !== undefined) {
                        if(index.objects[tmparray[0]]['mtime'] !== workdir[tmparray[0]]['mtime']) {
                            pending++;
                            var tmpfunction = function(filename) {
                                fs.readFile(ph.join(ph.normalize(ph.join(repopath,'..')), tmparray[0]), function(err, data) {
                                    if(err) callback(err);
                                    else {
                                        bM.fileToBlob(data, function(err, data) {
                                            
                                            var sha1 = utils.getSha1(data);
                                            if (sha1  !== 
                                                utils.convertDigestToHex(new Buffer(index.objects[tmparray[0]]['SHA_1'], 'hex')) ) {
                                                // in index, in workdir, content differs => modified
                                                if(result.conflicts.indexOf(tmparray[0]) === -1)
                                                    result.modified.push(filename);
                                                if(!--pending) {
                                                    callback(null, result, treeInfo, graph, index);
                                                }
                                            } else {
                                                if(!--pending) {
                                                    callback(null, result, treeInfo, graph, index);
                                                }   
                                            }
                                        });
                                    }           
                                });
                            }
                            tmpfunction(tmparray[0]);
                        }
                    } else {
                        // in index, not in workdir => missing
                        if(result.conflicts.indexOf(tmparray[0]) === -1)
                            result.missing.push(tmparray[0]);
                    }
                }
                
            }
            if(pending === 0) {
                callback(null, result, treeInfo, graph, index);  
            }
            
        });
        
    }

    //read index
    console.log('bug1');
    gitindex.Index(repopath, function(err, index) {
        if (err) {
            callback(err);
            return;
        }
        console.log('bug2');
        //read working directory, there's no error in index(if index doesn't exist we get empty index)
        var repopath2 = ph.normalize(ph.join(repopath, '..'));
        dw.walk(repopath2, function(err, workdir) {
            console.log('bug3');
            if(err) {
                callback(err);   
            } else {
                //workdir is path dictionary
                //get HEAD
                guM.getHeadAndTreeDir(repopath, function(err, head, treeInfo, graph) {
                    console.log('bug4');
                    if (err) callback(err);                
                    else if (head === undefined) {
                        treeInfo = {};
                        function2(treeInfo, index, workdir);
                    } else {
                        function2(treeInfo, index, workdir, graph);   
                    }
                });
            }
        });

    });
    
}

