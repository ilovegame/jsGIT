/*
 * Algorithm:
 * https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java
 * Take 
 * tree paths
 * index paths
 * workdir paths
 * sort them in alphabetical order
 * take the first one of them and do the following
 * (kind of like sorting sorted lists in mergesort):
 * one if else
 * // in repo, in index, content diff => changed
 * // in repo, not in index => removed
 * // not in repo, in index => added
 * // not in repo, not in index => untracked
 * 
 * and then:
 * // in index, not in workdir => missing
 * // in index, in workdir, content differs => modified
 * 
 * return to callback results
 * 
 * Usage example:
gitstatus.status('/home/marcinek/gitrepotest/', function(err, modified, untracked, added, missing, changed, removed) {
    if(err) {
        console.log(err)   
    } else {
        console.log(modified);
        console.log(untracked);
        console.log(added);
        console.log(missing);
        console.log(changed);
        console.log(removed);
    }
});
 */
gitindex = require('indexFile.js');
dw = require('dirwalk.js');
gitcommit = require('commit.js');
tree_module = require('tree.js');
utils = require('utils.js');



exports.status = function(gitpath, callback) {
    
    if(gitpath.length > 0 && gitpath[gitpath.length - 1] !== '/')
        gitpath = gitpath + '/';
    
    var function2 = function(treeInfo, index, workdir) {
        var treeKeys = Object.keys(treeInfo);
        var indexKeys = Object.keys(index.objects);
        var workdirKeys = Object.keys(workdir);
        var treeC = 0;
        var indexC = 0;
        var workdirC = 0;
        var modified = [];
        var untracked = [];
        var added = [];
        var removed = [];
        var missing = [];
        var changed = [];
        var pending = 0;
        treeKeys.sort();
        indexKeys.sort();
        workdirKeys.sort();
      
        while (treeC < treeKeys.length || indexC < indexKeys.length || workdirC < workdirKeys.length) {
            var tmparray = []
            if(treeC < treeKeys.length) tmparray.push(treeKeys[treeC]);
            if(indexC < indexKeys.length) tmparray.push(indexKeys[indexC]);
            if(workdirC < workdirKeys.length) tmparray.push(workdirKeys[workdirC]);
            tmparray.sort();
            
            if(treeInfo[tmparray[0]] !== undefined) treeC++;
            if(index.objects[tmparray[0]] !== undefined) indexC++;
            if(workdir[tmparray[0]] !== undefined) workdirC++;
            
            if (treeInfo[tmparray[0]] !== undefined) {
                if(index.objects[tmparray[0]] === undefined) {
                    // in repo, not in index => removed
                    removed.push(tmparray[0]);   
                } else {
                    //in repo, in index, content diff => changed
                    if(treeInfo[tmparray[0]]['sha1']
                        !== utils.convertDigestToHex(new Buffer(index.objects[tmparray[0]]['SHA_1'], 'binary'))) {
                        changed.push(tmparray[0]);
                    }
                }
            } else {          
                if(index.objects[tmparray[0]] === undefined) {
                    // not in repo, not in index => untracked
                    untracked.push(tmparray[0]);   
                } else {
                    // not in repo, in index => added
                    added.push(tmparray[0]);  
                }
            }
            if(index.objects[tmparray[0]]) {
                if(workdir[tmparray[0]] !== undefined) {
                    if(index.objects[tmparray[0]]['mtime'] !== workdir[tmparray[0]]['mtime']) {
                        pending++;
                        utils.getSha1OfFile(gitpath + tmparray[0], function(err, sha1) {
                            if(err) callback(err);
                            else {
                                if (index.objects[tmparray[0]]['SHA_1'] !== sha1) {
                                    // in index, in workdir, content differs => modified
                                    modified.push(tmparray[0]);
                                    if(!--pending) callback(null, modified, untracked, added, missing, changed, removed);
                                }
                            }
                        });
                    }
                } else {
                    // in index, not in workdir => missing
                    missing.push(tmparray[0]);
                }
            }
            
        }
        if(pending === 0) {
            callback(null, modified, untracked, added, missing, changed, removed);   
        }
    }
  
    var function1 = function(commitsha1, index, workdir) {
        //get tree info
        //if commitsha1 empty we threat tree as empty 
        if(commitsha1 === undefined) {
            //do status
            function2({}, index, workdir);   
        } else {
            gitcommit.readFileToCommit(commitsha1, gitpath + '.git', function(err, commit) {
                if(err) callback(err);
                else {
                    tree_module.readFileToTree(commit.objectId,gitpath + '.git', function(err, tree) {
                        //console.log(Object.keys(tree.entries)); 
                        if(err) callback(err);
                        else {
                            tree.walk(gitpath, function(err, treeInfo) {
                                if(err) callback(err);
                                else {
                                    //do mstatus
                                    function2(treeInfo, index, workdir);   
                                }
                            });
                        }
                    });   
                }
            });
        }
    }
    
    
    //read index
    gitindex.Index(gitpath+'.git/index', function(err, index) {
        
        //read working directory, there's no error in index(if index doesn't exist we get empty index)
        dw.walk(gitpath, function(err, workdir) {
            if(err) {
                callback(err);   
            } else {
                //workdir is path dictionary
                //get HEAD
                fs.readFile(gitpath + '.git/HEAD', function (err, data) {
                    
                    if(err) {
                        callback(err);   
                    } else {
                        //HEAD is either ref: refs/heads/master
                        //or sha1
                        var datastr = data.toString();
                        var refsmaster = 'ref: refs/heads/master';
                        var commitsha1 = datastr;
                        datastr = datastr.substr(0, datastr.length - 1);
                        if(datastr === refsmaster) {
                            
                            fs.readFile(gitpath+'.git/refs/heads/master', function(err, data) {
                                if(err) {
                                    //In empty repo .git/refs/heads/master doesn't exist
                                    //there's no single commit
                                    //standard git threats it as empty tree
                                    commitsha1 = undefined;
                                    function1(commitsha1, index, workdir);
                                } else {
                                    commitsha1 = data.toString();
                                    //we read '/n'
                                    commitsha1 = commitsha1.substr(0, commitsha1.length - 1);
                                    //domorework
                                    function1(commitsha1, index, workdir);
                                }
                            });
                        } else {
                            //we read '/n'
                            commitsha1 = commitsha1.substr(0, commitsha1.length - 1);
                            //do more work
                            function1(commitsha1, index, workdir);   
                        }
                    }
                });
            }
        });

    });
}

