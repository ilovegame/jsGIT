/*
 * Algorithm:
 * https://github.com/eclipse/jgit/blob/master/org.eclipse.jgit/src/org/eclipse/jgit/lib/IndexDiff.java
 * Take 
 * tree paths
 * index paths
 * workdir paths
 * sort them in alphabetical order
 * take the first one of them and do the following
 * (kind of like sorting sorted lists in mergesort):
 * one if else
 * // in repo, in index, content diff => changed
 * // in repo, not in index => removed
 * // not in repo, in index => added
 * // not in repo, not in index => untracked
 * 
 * and then:
 * // in index, not in workdir => missing
 * // in index, in workdir, content differs => modified
 * 
 * return to callback results
 * 
 * 
 * We also return all paths and treegraph to callback
 * 
 * if head points to commit which does not exist
 * we return graph = undefined to callback and treeInfo = {}
 * 
 * treeInfo and graph are of the same format as the result of tree.walk 
 * from tree.js
 * 
 * 
 * Usage example:
 * 
 * 
 * 
gitstatus.status('/home/marcinek/gitrepotest/', function(err, result, treeInfo, graph) {
    if(err) {
        console.log(err)   
    } else {
        console.log(result.modified);
        console.log(result.untracked);
        console.log(result.added);
        console.log(result.missing);
        console.log(result.changed);
        console.log(result.removed);
        console.log(treeInfo);
        console.log(graph);
    }
});
 */
gitindex = require('indexFile.js');
dw = require('dirwalk.js');
gitcommit = require('commit.js');
tree_module = require('tree.js');
utils = require('utils.js');
guM = require('gitutils.js');
bM = require('blob.js');
fs = require('fs');



exports.gitStatus = function(gitpath, callback) {
    
    if(gitpath.length > 0 && gitpath[gitpath.length - 1] !== '/')
        gitpath = gitpath + '/';
    
    var function2 = function(treeInfo, index, workdir, graph) {
        var treeKeys = Object.keys(treeInfo);
        var indexKeys = Object.keys(index.objects);
        var workdirKeys = Object.keys(workdir);
        var treeC = 0;
        var indexC = 0;
        var workdirC = 0;
        var result = {};
        result.modified = [];
        result.untracked = [];
        result.added = [];
        result.removed = [];
        result.missing = [];
        result.changed = [];
        
        var pending = 0;
        treeKeys.sort();
        indexKeys.sort();
        workdirKeys.sort();
      
        while (treeC < treeKeys.length || indexC < indexKeys.length || workdirC < workdirKeys.length) {
            var tmparray = []
            if(treeC < treeKeys.length) tmparray.push(treeKeys[treeC]);
            if(indexC < indexKeys.length) tmparray.push(indexKeys[indexC]);
            if(workdirC < workdirKeys.length) tmparray.push(workdirKeys[workdirC]);
            tmparray.sort();
            
            if(treeInfo[tmparray[0]] !== undefined) treeC++;
            if(index.objects[tmparray[0]] !== undefined) indexC++;
            if(workdir[tmparray[0]] !== undefined) workdirC++;
            
            if (treeInfo[tmparray[0]] !== undefined) {
                if(index.objects[tmparray[0]] === undefined) {
                    // in repo, not in index => removed
                    result.removed.push(tmparray[0]);   
                } else {
                    //in repo, in index, content diff => changed
                    if(treeInfo[tmparray[0]]['sha1']
                        !== utils.convertDigestToHex(new Buffer(index.objects[tmparray[0]]['SHA_1'], 'binary'))) {
                        result.changed.push(tmparray[0]);
                    }
                }
            } else {          
                if(index.objects[tmparray[0]] === undefined) {
                    // not in repo, not in index => untracked
                    result.untracked.push(tmparray[0]);   
                } else {
                    // not in repo, in index => added
                    result.added.push(tmparray[0]);  
                }
            }
            
            if(index.objects[tmparray[0]]) {
                if(workdir[tmparray[0]] !== undefined) {
                    if(index.objects[tmparray[0]]['mtime'] !== workdir[tmparray[0]]['mtime']) {
                        pending++;
                        var tmpfunction = function(filename) {
                            fs.readFile(gitpath + tmparray[0], function(err, data) {
                                if(err) callback(err);
                                else {
                                    bM.fileToBlob(data, function(err, data) {
                                        var sha1 = utils.getSha1(data);
                                        if (sha1  !== 
                                            utils.convertDigestToHex(new Buffer(index.objects[tmparray[0]]['SHA_1'], 'binary')) ) {
                                            // in index, in workdir, content differs => modified
                                            result.modified.push(filename);
                                            if(!--pending) callback(null, result, treeInfo, graph, index);
                                        }
                                    });
                                }           
                            });
                        }
                        tmpfunction(tmparray[0]);
                    }
                } else {
                    // in index, not in workdir => missing
                    result.missing.push(tmparray[0]);
                }
            }
            
        }
        if(pending === 0) {
            callback(null, result, treeInfo, graph, index);  
        }
    }

    //read index
    gitindex.Index(gitpath+'.git/', function(err, index) {
        //read working directory, there's no error in index(if index doesn't exist we get empty index)
        dw.walk(gitpath, function(err, workdir) {
            if(err) {
                callback(err);   
            } else {
                //workdir is path dictionary
                //get HEAD
                guM.getHeadAndTreeDir(gitpath, function(err, head, treeInfo, graph) {
                    if (err) callback(err);   
                    else if (head === undefined) {
                        treeInfo = {};
                        function2(treeInfo, index, workdir);
                    } else {
                        function2(treeInfo, index, workdir, graph);   
                    }
                });
            }
        });

    });
    
}

