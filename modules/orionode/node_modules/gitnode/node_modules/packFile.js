//TODO read first n bytes of file?
//TODO offsetEntries
//TODO git/objects/info/packs

//TODO what functions do we need for pack?
//1. get file by sha1
//2. modify pack and store to file
//TODO callbacks
//TODO verify correctness

var ph = require('path');
var fs = require('fs');
var zlib = require('zlib');
var utils = require('utils');
var packIndex = require('packIndex.js');

//handleEncoded1Object(packIndex, packBuffer, sha1, index, endIndex);
//TODO rozpakowane
function readHunk(bufferIndex, buffer, rozpakowane, baza)
{
				
/*<DELTA_DATA>
:	<BASE_OBJECT_LENGTH>
	<RESULT_OBJECT_LENGTH>
	( <DELTA_HUNK> )+	
	* 
	*/

//TODO COPIED !!!
	console.log("first hunk byte = " + buffer[bufferIndex] + " at " + (bufferIndex));
	if ( (buffer[bufferIndex] & 128) == 0)
	{
		console.log("insert " + (buffer[bufferIndex] & (~128)) + " bytes");
		var len = buffer[bufferIndex] & (~128);
		bufferIndex++;
		var p = buffer.toString('utf-8', bufferIndex, bufferIndex + len);
		console.log(p);
		rozpakowane += p;
		
		bufferIndex += len;
	} else {
		console.log("copy");
		var delta_hunk_start = bufferIndex;
		var data = buffer[delta_hunk_start];

		var opcode = data;
		bufferIndex++;
		data = buffer[bufferIndex];
		
		var copy_offset= 0;
		var copy_length = 0;

		for (shift=i=0; i<4; i++) {
			if (opcode & 0x01) {
				//copy_offset |= (*data++)<<shift;
				copy_offset |= (data)<<shift;
				bufferIndex++;
				data = buffer[bufferIndex];
			}
			opcode >>= 1;
			shift += 8;
			}

		for (shift=i=0; i<2; i++) {
			if (opcode & 0x01) {
				copy_length |= (data)<<shift;
				bufferIndex++;
				data = buffer[bufferIndex];
			}
			opcode >>= 1;
			shift += 8;
			}

		if (!copy_length) {
			copy_length = 1<<16;
			}

		copy_from_result = opcode & 0x01;

		console.log("copy_offset = " + copy_offset);
		console.log(" copy_length = " +  copy_length);
		console.log("copy_from_result = " + copy_from_result);
		rozpakowane += baza.substring(copy_offset, copy_offset + copy_length);
		
	}
	return [bufferIndex, rozpakowane];
}


Pack.prototype.handleEncoded1Object = function(packBuffer, sha1, indexCopy, index, endIndex)
{
	var packIndex = this.packIndex;
	var byte = packBuffer[index];
	//TODO copied!!!
	index += 1;
	var number = byte & 127;
	while (byte & 128) {
		byte = packBuffer[index];
		index += 1;
		console.log("+1");
		number = ((number + 1) << 7) | (byte & 127);
	}
	console.log("number = " + number + ", byte = " + byte);
	var index2 = indexCopy - number;
	var endIndex2 = getFirstGreater(packIndex.offsetValues, index2);
	//console.log("endIndex2 = " + endIndex2);
	if (endIndex2 == -1)//TODO it should not happen?
	{
		endIndex2 = packBuffer.length;
	}
	console.log("We'll take base from [" + index2 + ", " + endIndex2 + ")");//TODO ?
	
	//call parseObject
	
	//function (sha1, packBuffer, index, endIndex, callback)
	//TODO can object be encoded with another encoded object as base?
	this.parseObject(sha1, packBuffer, index2, endIndex2, function(err, buff) {
		
		var baza = buff.toString('utf-8', 0);//TODO
		console.log(baza);
		var rozpakowane = "";
		//TODO tego nie musze natychmiast robic, bo przeciez i tak znam te tresc
		//moge wiec spokojnie sobie parsowac do delta data

		console.log("parsing DELTA_DATA");
		console.log("inflating [" + index + ", " + endIndex + ")");
		zlib.inflate(packBuffer.slice(index, endIndex), function(err, buffer) {
			//console.log("ddd " + tt);
			console.log("-------------------------------");
			
			console.log("err = " + err);
			//if err
			if (!err){
				//callback(null, buffer);
				console.log("packBuffer len " + buffer.length);
				console.log(buffer);
				
			//	<BASE_OBJECT_LENGTH>
			//:	<LITTLE_ENDIAN_BASE_128_NUMBER>
				var bufferIndex = 0;
				var moreFlag = 1;
				console.log("moreFlag=" + moreFlag);
				var length = 0;
				var coeff = 1;
				while (moreFlag != 0)
				{
					var nextByte = buffer[bufferIndex];
					console.log("NEXT BYTE = " + nextByte + " at index = " + bufferIndex);
					bufferIndex += 1;
					moreFlag = nextByte & 128;
					var lengthBits = nextByte & (~128);
					length += lengthBits * coeff;
					coeff *= 64;//*2^6
				}
				console.log("BASE_OBJECT_LENGTH = " + length);
				
				
				//TODO copy paste :(
				var moreFlag = 1;
				console.log("moreFlag=" + moreFlag);
				var length = 0;
				var coeff = 1;
				while (moreFlag != 0)
				{
					var nextByte = buffer[bufferIndex];
					console.log("NEXT BYTE = " + nextByte + " at index = " + bufferIndex);
					bufferIndex += 1;
					moreFlag = nextByte & 128;
					var lengthBits = nextByte & (~128);
					length += lengthBits * coeff;
					coeff *= 64;//*2^6
				}
				console.log("RESULT_OBJECT_LENGTH = " + length);
				
				
				//console.log("pierwszy bajt hunk-a = " + buffer[bufferIndex] + " at " + (bufferIndex));
				var yy = 1;
				while(bufferIndex != buffer.length && yy != 15)
				{
					var abc = readHunk(bufferIndex, buffer, rozpakowane, baza)
					bufferIndex = abc[0];
					rozpakowane = abc[1];
					yy ++;
					
					
				}
				console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
				console.log(rozpakowane);
				
			}
			console.log("-------------------------------");
				
		});
		
		
	});
	
	
	
	

}



//TODO
function getFirstGreater(tab, x)
{
	//there are no two equal values in tab
	var firstGreater = x + 1;
	var i = 0;
	var isFound = false;
	while (i < tab.length)
	{
		if ( x < tab[i] && (firstGreater > tab[i] || !isFound ))
		{
			firstGreater = tab[i];
			isFound = true;
		}
		++i;
	}

	if (!isFound)
	{
		return -1;
	}
	else 
	{
		return firstGreater;
	}
	
}

//TODO callback: function(err, string/buffer)
Pack.prototype.parseObject = function (sha1, packBuffer, index, endIndex, callback)
{		
		console.log("sha1 = " + this.sha1);
		console.log("packIndex = ");
		console.log(this.packIndex);
		var indexCopy = index;
		console.log("sha1 = " + sha1);
		//TODO network endianess?
		var firstByte = packBuffer[index];
		console.log('firstByte=' + firstByte + ' at index ' +  index);
		index += 1;
		
		
		var length = firstByte & (1 + 2 + 4 + 8);//bits 0-3
		console.log("first length = " + length);
		//11001011
		var type = firstByte & (16 + 32 + 64);//bits 6-4
		//console.log("type1 = " + type);
		type = type / 16;//TODO ?
		//console.log("type2 = " + type);

		//TODO
		if (parseInt("000", 2) == type)
		{
			console.log("TYPE = invalid1");
		} else if (parseInt("001", 2) == type)
		{
			console.log("TYPE = commit");
		} else if (parseInt("010", 2) == type)
		{
			console.log("TYPE = tree");
		}  else if (parseInt("011", 2) == type)
		{
			console.log("TYPE = blob ");
		} else if (parseInt("100", 2) == type)
		{
			console.log("TYPE = tag ");
		} else if (parseInt("101", 2) == type)
		{
			console.log("TYPE = invalid2");
		} else if (parseInt("110", 2) == type)
		{
			console.log("TYPE = DELTA_ENCODED1 ");
		} else if (parseInt("111", 2) == type)
		{
			console.log("TYPE = DELTA_ENCODED2");
		}
		else {
			console.log(":(");
		}

		var moreFlag = (firstByte & 128)/128;
		console.log("moreFlag=" + moreFlag);
	
		var coeff = 16;
		while (moreFlag != 0)
		{
			var nextByte = packBuffer[index];
			console.log("NEXT BYTE = " + nextByte + " at index = " + index);
			index += 1;
			moreFlag = nextByte & 128;
			var lengthBits = nextByte & (~128);
			length += lengthBits * coeff;
			coeff *= 64;//*2^6
		}
		
		
		console.log("length = " + length);
		console.log("index = " + index);
		

		if (parseInt("111", 2) == type) //encoded2
		{
			console.log("ENCODED 2");
			
			var dy = packBuffer.toString('hex', index, index+20);
			index += 20;
			console.log("dy = " + dy);

			//zlib.inflate.......
		}
		else if (parseInt("110", 2) == type ) {
			console.log("ENCODED 1");
			//w/ offset to base

			//<DELTA_BASE_OFFSET> _deflate_( <DELTA_DATA> )
			//offset = 
			/*<BIG_ENDIAN_MODIFIED_BASE_128_NUMBER>
			# The following C code will decode these.
			#
			#	byte = *data++;
			#	number = byte & 0x7f;
			#	while (byte & 0x80) {
			#		byte = *data++;
			#		number = ((number + 1) << 7) | (byte & 0x7f);
			#	}
			 * 
			 * 
			*/
			this.handleEncoded1Object(packBuffer, sha1, indexCopy, index, endIndex);
			

		}
		else //without encoding
		{
			//TODO if not delta encoded
			console.log("read data from [" + index + ", " + endIndex + ")");
			console.log("mean " + packBuffer.slice(index, endIndex).length + " bytes");
			
			zlib.inflate(packBuffer.slice(index, endIndex), function(err, buffer) {
				//console.log("ddd " + tt);
				console.log("-------------------------------");
				console.log("packBuffer len " + packBuffer.length);
				console.log("err = " + err);
				if (!err){
					callback(null, buffer);
				}
				console.log("-------------------------------");
				console.log("-------------------------------");
			
			});
		}
};

//callback(err, object) 
//maybe one more argument - object type
Pack.prototype.getObject = function (sha1, callback)
{
	var dir = ph.join(this.repoPath, 'objects/pack');
	var file = 'pack-' + this.sha1 + '.pack';
	var path = ph.join(dir, file);
	console.log(this.packIndex);
	
	var pack = this;
	
	
	fs.readFile(path, function (err, packBuffer) {
		if (err)
		{
			callback(err, null);
		}
		else {
			console.log(pack.packIndex.offsetValues);
			console.log("packBuffer length " + packBuffer.length);
			var index = 0;
			//var dummy = packBuffer.readInt32BE(index);
				//packBuffer.toString('hex', index, index+20);
			
			var signature = packBuffer.toString('utf-8', index, index+4);// 'PACK'
			console.log("signature = " + signature);
			index += 4;
			var gitVersion = packBuffer.readInt32BE(index); //TODO
			index += 4;
			console.log("gitVersion = " + gitVersion);
			var objectsCount = packBuffer.readInt32BE(index);//== this.packIndex.objectsCount
			index += 4;
			console.log("objectsCount = " + objectsCount);
			console.log("---------------");

			var i = 0;
			while(pack.packIndex.objects[i] != sha1 && i < objectsCount)
			{
				++i;
			}
			//TODO isFound?
			index = pack.packIndex.offsetValues[i];//TODO offsetEntries
			var endIndex = getFirstGreater(pack.packIndex.offsetValues, index);
			console.log("endIndex = " + endIndex);
			if (endIndex == -1)
			{
				endIndex = packBuffer.length;
			}

			pack.parseObject(sha1, packBuffer, index, endIndex, callback);
			console.log('-----------');
		}
	});
}

function Pack(sha1, repoPath, packIndex)
{
	this.sha1 = sha1;
	this.packIndex = packIndex; //TODO
	this.repoPath = repoPath;
}


function readFileToPack(sha1, repoPath, callback) {
//callback - function(err, pack)
	packIndex.readPackIndex(sha1, repoPath, function (err, packIndex) {
		if (err)
		{
			callback(err, null);
		}
		else {
			var pack = new Pack(sha1, repoPath, packIndex);
			callback(null, pack);
		}
	});
}

exports.readFileToPack = readFileToPack;