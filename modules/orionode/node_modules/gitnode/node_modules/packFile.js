//TODO git/objects/info/packs
//TODO save to file
//TODO does fs.read always read all bytes we want?

/*
For now, PackFile gives two functions:
- getObject
- hasObject

Use case:
var pf = require('packFile');
function handleObject(err, buffer)
{
	console.log(buffer.toString('utf-8', 0, buffer.length));

}

pf.readFileToPack(packSha1, repoPath, function (err, pack) { 
	pack.getObject(objSha1, handleObject);
});

 */
var ph = require('path');
var fs = require('fs');
var zlib = require('zlib');
var utils = require('utils');
var packIndex = require('packIndex.js');

var types = { 
	0 : 'invalid',
	1 : 'commit',
	2 : 'tree',
	3 : 'blob',
	4 : 'tag',
	5 : 'invalid',
	6 : 'delta1',
	8 : 'delta2'
}

function getCopyOffset(delta, deltaPtr, cmd) {
	var copyOffset = 0;
	if ((cmd & 0x01) != 0)
		copyOffset = delta[deltaPtr++] & 0xff;
	if ((cmd & 0x02) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 8;
	if ((cmd & 0x04) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 16;
	if ((cmd & 0x08) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 24;
	return [deltaPtr, copyOffset];
}

function getCopySize (delta, deltaPtr, cmd)
{
	var copySize = 0;
	if ((cmd & 0x10) != 0)
		copySize = delta[deltaPtr++] & 0xff;
	if ((cmd & 0x20) != 0)
		copySize |= (delta[deltaPtr++] & 0xff) << 8;
	if ((cmd & 0x40) != 0)
		copySize |= (delta[deltaPtr++] & 0xff) << 16;
	if (copySize == 0)
		copySize = 0x10000;
	return [deltaPtr, copySize];
}

// decodes delta segment
// @param bufferIndex - where we start reading
// @param buffer - delta segment
// @param baza - base object
function readSegment(bufferIndex, buffer, baza)
{
	var cmd = buffer[bufferIndex++] & 0xff;
	
	if ((cmd & 0x80) !== 0) {
		//copy segment
		var res = getCopyOffset(buffer, bufferIndex, cmd );
		bufferIndex = res[0];
		var copy_offset = res[1];

		res = getCopySize(buffer, bufferIndex, cmd);
		bufferIndex = res[0];
		var copy_length = res[1];
		var decoded = baza.substring(copy_offset, copy_offset + copy_length);
	}
	else
	{
		//insert segment
		var len = cmd;//buffer[bufferIndex-1] & (~128);
		var decoded = buffer.toString('utf-8', bufferIndex, bufferIndex + len);
		bufferIndex += len;
	}
	return [bufferIndex, decoded];
}

// Decodes encoded length. If the most sign. bit is set - read next byte
// @param buffer - delta encoded objects
// @param objectOffset - index of object's first byte in pack file
// returns pair: number of bytes read, length
function getIntLE128Base(buffer, bufferIndex)
{
	var moreFlag = 1;
	var length = 0;
	var coeff = 1;
	while (moreFlag !== 0)
	{
		var nextByte = buffer[bufferIndex];
		bufferIndex += 1;
		moreFlag = nextByte & 128;
		var lengthBits = nextByte & (~128);
		length += lengthBits * coeff;
		coeff *= 64;// *2^6
	}
	return [bufferIndex, length];
}

// Decodes delta base offset
// @param buffer - delta encoded objects
// @param objectOffset - index of object's first byte in pack file
// returns pair: number of bytes read, base object offset
Pack.prototype.getBaseObjectOffset = function (buffer, objectOffset)
{
	var index = 0;
	var c = buffer[index++] & 0xff;
	var ofs = c & 127;
	while ((c & 128) != 0) {
		ofs += 1;
		c = buffer[index++] & 0xff;
		ofs <<= 7;
		ofs += (c & 127);
	}
	return [index, objectOffset - ofs];
}

// Decodes delta segments
// @param buffer - object's delta encoded segments
// @param baseBuffer - content of base object
// @param callback - function (err, buffer)
Pack.prototype.parseDeltaData = function(buffer, baseBuffer, callback)
{
	var base = baseBuffer.toString('utf-8', 0);
	var res = getIntLE128Base(buffer, 0);
	var bufferIndex = res[0];
	var baseObjectLength = res[1];

	res = getIntLE128Base(buffer, bufferIndex);
	var bufferIndex = res[0];
	var resultObjectLength = res[1];
	var decoded = '';
	while(bufferIndex !== buffer.length)
	{
		var segment = readSegment(bufferIndex, buffer, base)
		bufferIndex = segment[0];
		decoded += segment[1];
	}
	callback(null, new Buffer(decoded));
}

// Reads delta base (by moving backwards in pack file) and calls delta parsing function
// @param objectOffset - index of object's first byte in pack file
// @param dataBuffer - object's data from pack file, without header with type, length
// @param callback - function(err, buffer)
Pack.prototype.handleDelta1Object = function(objectOffset, objectBuffer, callback)
{
	var index = 0;
	var packIndex = this.packIndex;
	var res = this.getBaseObjectOffset(objectBuffer, objectOffset);
	index = res[0];
	var baseStartIndex = res[1];
	var baseEndIndex = packIndex.getLastByteIndex(baseStartIndex, this.size);
	var pack = this;

	var offset = baseStartIndex;
	var length = baseEndIndex - baseStartIndex + 1;
	
	this.readObject(offset, length, function (err, baseBuffer)
	{
		if (err)
		{
			throw err;
		}
		zlib.inflate(objectBuffer.slice(index, objectBuffer.length), function(err, buffer) {
			if (err)
			{
				throw err;
			}
			pack.parseDeltaData(buffer, baseBuffer, callback);
		});
	});
	
}

// Reads delta base (by sha1) and calls delta parsing function
// @param objectOffset - index of object's first byte in pack file
// @param dataBuffer - object's data from pack file, without header with type, length
// @param callback - function(err, buffer)
Pack.prototype.handleDelta2Object = function (objectOffset, dataBuffer, callback)
{
	var packIndex = this.packIndex;
	var pack = this;
	var index = 0;
	var baseSha1 = dataBuffer.toString('hex', index, index+20);
	index += 20;

	this.readSha1Object(baseSha1, function (err, baseBuffer)
	{
		if (err)
		{
			throw err;
		}
		zlib.inflate(objectBuffer.slice(index, objectBuffer.length), function(err, buffer) {
			if (err)
			{
				throw err;
			}
			pack.parseDeltaData(buffer, baseBuffer, callback);
		});
	});
}

// Reads first object's bytes - length, type etc and calls delta parser if object is encoded
// @param objectOffset - index of object's first byte in pack file
// @param buffer - object's data from pack file
// @param callback - function(err, buffer)
Pack.prototype.parseObject = function (objectOffset, buffer, callback)
{		
	var index = 0;
	var firstByte = buffer[index];
	index += 1;

	var length = firstByte & (1 + 2 + 4 + 8);//bits 0-3
	var typeCode = (firstByte & (16 + 32 + 64)) / 16;//bits 6-4
	var type = types[typeCode];
	var moreFlag = (firstByte & 128)/128;

	var coeff = 16;
	while (moreFlag !== 0)
	{
		var nextByte = buffer[index];
		index += 1;
		moreFlag = nextByte & 128;
		var lengthBits = nextByte & (~128);
		length += lengthBits * coeff;
		coeff *= 64;// *2^6
	}

	var dataBuffer = buffer.slice(index, buffer.length);
	
	if ('invalid' === type)
	{
		throw 'invalid object type';
	} else if ('delta2' === type)
	{
		this.handleDelta2Object(objectOffset, dataBuffer, callback);
	}
	else if ('delta1' === type ) {
		this.handleDelta1Object(objectOffset, dataBuffer, callback);
	}
	else //without delta encoding
	{
		zlib.inflate(dataBuffer, function(err, decodedBuffer) {
			if (err)
			{
				throw err;
			}
			callback(null, decodedBuffer);
		});
	}
};

// Interface for other modules. Checks whether object is stored in this pack
// @param sha1 - object's we look for sha1
Pack.prototype.hasObject = function (sha1, callback)
{
	var i = this.packIndex.getObjectIndex(sha1);
	//callback(null, i !== -1)
	return (i !== -1);
}

// callback - function (err, dataBuffer)
// Reads and parses object from pack
// @param offset - index of object's first byte in pack file
// @param length - number of object's bytes in pack file
Pack.prototype.readObject = function (offset, length, callback)
{
	var pack = this;
	
	this.readFromFile(false, true, null, offset, length, function (dataBuffer, fd){
		pack.parseObject(offset, dataBuffer, callback);
	});
};

// callback - function (err, buffer)
// Interface for other modules. Reads object from pack
// @param sha1 - sha1 of file to file we want to read
// @param callback - function (err, buffer)
Pack.prototype.getObject = function (sha1, callback)
{
	try
	{
		this.readSha1Object(sha1, callback);
	} 
	catch (err)
	{
		callback(err, null);
	}
}

// Reads and parses object from pack
// @param sha1 - sha1 of file to file we want to read
// @param callback - function (err, buffer)
Pack.prototype.readSha1Object = function (sha1, callback)
{
	var pack = this;
	var i = pack.packIndex.getObjectIndex(sha1);
	var index = pack.packIndex.getOffset(i);
	var endIndex = pack.packIndex.getLastByteIndex(index, this.size);
	var length = endIndex - index + 1;
	this.readObject(index, length, callback);
}

// Helps to handle reading part of file
// @param isOpen - whether file is already open or not
// @param close - whether close file after reading
// @param fd - file decriptor (if file open), can be null, if !isOpen
// @param offset - where to start reading
// @param length - number of bytes to read
// @param callback - function (buffer, fd) (fd - passed if we open file here)
Pack.prototype.readFromFile = function (isOpen, close, fd, offset, length, callback) 
{
	var pack = this;
	function handleOpened(fd)
	{
		fs.read(fd, new Buffer(length), 0, length, offset, function(err, bytesRead, dataBuffer) {
			if (err)
			{
				throw err;
			}

			if (close)
			{
				fs.close(fd, function(err) {
					if (err)
					{
						throw err;
					}
					callback(dataBuffer, fd);
				});
			}
			else
			{
				callback(dataBuffer, fd);
			}
		});
	}
	
	if (!isOpen)
	{
		fs.open(pack.path, 'r', function(err, fd) {
			if (err)
			{
				throw err;
			}
			handleOpened(fd);
		});
	}
	else
	{
		handleOpened(fd);
	}
}

// Parsing header of pack file.
// @param callback - function (err, pack)
Pack.prototype.parseInfo = function (callback)
{
	var pack = this;
	var headerLength = 12;
	this.readFromFile(false, false, null, 0, headerLength, function (headerBuffer, fd) {
		var index = 0;
		var signature = headerBuffer.toString('utf-8', index, index+4);// 'PACK'
		index += 4;
		var gitVersion = headerBuffer.readUInt32BE(index); //we accept only 2
		index += 4;
		var objectsCount = headerBuffer.readUInt32BE(index);//=== pack.packIndex.objectsCount
		index += 4;
		
		pack.parseFooter(fd, callback);
	});
}

// Parsing footer of pack file. In fact, it only reads last 20 bytes - checksum
// @param fd - file descriptor of open file
// @param callback - function (err, pack)
Pack.prototype.parseFooter = function (fd, callback)
{
	var pack = this;
	fs.stat(pack.path, function (err, stats) {
		if (err)
		{
			throw err;
		}
		pack.size = stats.size;
		var length = 20;
		pack.readFromFile(true, true, fd, 0, length, function (buffer, fd) {
			var checksum = buffer.toString('hex', 0, 20);
			callback(null, pack);
		});
	});
}

// Pack constructor
// @param sha1 - pack's checksum
// @param repoPath - path of .git directory
// @param packIndex - PackIndex object
function Pack(sha1, repoPath, packIndex)
{
	this.sha1 = sha1;
	this.packIndex = packIndex;
	this.repoPath = repoPath;
	this.size = 0;
	//this.size is set later
	var dir = ph.join(this.repoPath, 'objects/pack');
	var file = 'pack-' + this.sha1 + '.pack';
	this.path = ph.join(dir, file);
}

// Reads pack file and creates Pack object
// @param sha1 - pack's checksum
// @param repoPath - path of .git directory
// @param callback - function(err, pack)
function readFileToPack(sha1, repoPath, callback) {
	packIndex.readPackIndex(sha1, repoPath, function (err, packIndex) {
		if (err)
		{
			throw err;
		}
		var pack = new Pack(sha1, repoPath, packIndex);
		pack.parseInfo(callback);
	});
}

exports.readFileToPack = readFileToPack;