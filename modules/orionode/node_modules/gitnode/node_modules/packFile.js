//TODO read only part of file?
//TODO git/objects/info/packs
//TODO creating objects - Commit etc
//TODO save to file
//TODO slice


/*
For now, PackFile gives two functions:
- getObject
- hasObject

Use case:
var pf = require('packFile');
function handleObject(err, buffer)
{
	console.log(buffer.toString('utf-8', 0, buffer.length));

}

pf.readFileToPack(packSha1, repoPath, function (err, pack) { 
	pack.getObject(objSha1, handleObject);
});


 */
var ph = require('path');
var fs = require('fs');
var zlib = require('zlib');
var utils = require('utils');
var packIndex = require('packIndex.js');

var types = { 
	0 : 'invalid',
	1 : 'commit',
	2 : 'tree',
	3 : 'blob',
	4 : 'tag',
	5 : 'invalid',
	6 : 'delta1',
	8 : 'delta2'
}

function getCopyOffset(delta, deltaPtr, cmd) {
	var copyOffset = 0;
	if ((cmd & 0x01) != 0)
		copyOffset = delta[deltaPtr++] & 0xff;
	if ((cmd & 0x02) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 8;
	if ((cmd & 0x04) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 16;
	if ((cmd & 0x08) != 0)
		copyOffset |= (delta[deltaPtr++] & 0xff) << 24;
	return [deltaPtr, copyOffset];
}
	
function getCopySize (delta, deltaPtr, cmd)
{
	var copySize = 0;
	if ((cmd & 0x10) != 0)
		copySize = delta[deltaPtr++] & 0xff;
	if ((cmd & 0x20) != 0)
		copySize |= (delta[deltaPtr++] & 0xff) << 8;
	if ((cmd & 0x40) != 0)
		copySize |= (delta[deltaPtr++] & 0xff) << 16;
	if (copySize == 0)
		copySize = 0x10000;
	return [deltaPtr, copySize];
}

function readSegment(bufferIndex, buffer, baza)
{
	var cmd = buffer[bufferIndex++] & 0xff;
	
	if ((cmd & 0x80) !== 0) {
		//copy segment
		var res = getCopyOffset(buffer, bufferIndex, cmd );
		bufferIndex = res[0];
		var copy_offset = res[1];

		res = getCopySize(buffer, bufferIndex, cmd);
		bufferIndex = res[0];
		var copy_length = res[1];
		var decoded = baza.substring(copy_offset, copy_offset + copy_length);
	}
	else
	{
		//insert segment
		var len = cmd;//buffer[bufferIndex-1] & (~128);
		var decoded = buffer.toString('utf-8', bufferIndex, bufferIndex + len);
		bufferIndex += len;
	}
	return [bufferIndex, decoded];
}

function getIntLE128Base(buffer, bufferIndex)
{
	var moreFlag = 1;
	var length = 0;
	var coeff = 1;
	while (moreFlag !== 0)
	{
		var nextByte = buffer[bufferIndex];
		bufferIndex += 1;
		moreFlag = nextByte & 128;
		var lengthBits = nextByte & (~128);
		length += lengthBits * coeff;
		coeff *= 64;//*2^6
	}
	return [bufferIndex, length];
}


Pack.prototype.getBaseObjectOffset = function (packBuffer, index, startPos)
{
	var byte = packBuffer[index];
	index += 1;
	var ofs = byte & 127;
	while (byte & 128 != 0) {
		byte = packBuffer[index];
		index += 1;
		ofs += 1;
		ofs = ofs << 7;
		ofs += (byte & 127);
	}
	return [index, startPos - ofs];
}


Pack.prototype.parseDeltaData = function(buffer, baseBuffer, callback)
{
	var base = baseBuffer.toString('utf-8', 0);
	var res = getIntLE128Base(buffer, 0);
	var bufferIndex = res[0];
	var baseObjectLength = res[1];

	res = getIntLE128Base(buffer, bufferIndex);
	var bufferIndex = res[0];
	var resultObjectLength = res[1];
	var decoded = '';
	while(bufferIndex !== buffer.length)
	{
		var abc = readSegment(bufferIndex, buffer, base)
		bufferIndex = abc[0];
		decoded += abc[1];
	}
	callback(null, new Buffer(decoded));
}

//callback(err, ?
Pack.prototype.handleDelta1Object = function(packBuffer, sha1, indexCopy, index, endIndex, callback)
{
	var packIndex = this.packIndex;
	var res = this.getBaseObjectOffset(packBuffer, index, indexCopy);
	index = res[0];
	var baseStartIndex = res[1];
	var baseEndIndex = packIndex.getLastByteIndex(baseStartIndex);
	var pack = this;
	
	this.parseObject(sha1, packBuffer, baseStartIndex, baseEndIndex, function(err, baseBuffer) {
		zlib.inflate(packBuffer.slice(index, endIndex), function(err, buffer) {
			if (err)
			{
				callback(err, null);
			}
			else {
				pack.parseDeltaData(buffer, baseBuffer, callback);
			}
		});
	});
}

Pack.prototype.handleDelta2Object = function(packBuffer, sha1, baseSha1, index, endIndex, callback)
{
	var packIndex = this.packIndex;
	var pack = this;
	
	this.parseObject(sha1, packBuffer, baseStartIndex, baseEndIndex, function(err, baseBuffer) {
		zlib.inflate(packBuffer.slice(index, endIndex), function(err, buffer) {
			if (err)
			{
				throw err;
			}
			this.getObject(baseSha1, function handleObject(err, baseBuffer)	{
				if (err)
				{
					throw err;
				}
				pack.parseDeltaData(buffer, baseBuffer, callback);
			});
			
		});
	});
}

//TODO callback: function(err, string/buffer)
Pack.prototype.parseObject = function (sha1, packBuffer, index, endIndex, callback)
{		
		var indexCopy = index;
		var firstByte = packBuffer[index];
		index += 1;

		var length = firstByte & (1 + 2 + 4 + 8);//bits 0-3
		var typeCode = (firstByte & (16 + 32 + 64)) / 16;//bits 6-4
		var type = types[typeCode];
		var moreFlag = (firstByte & 128)/128;
	
		var coeff = 16;
		while (moreFlag !== 0)
		{
			var nextByte = packBuffer[index];
			index += 1;
			moreFlag = nextByte & 128;
			var lengthBits = nextByte & (~128);
			length += lengthBits * coeff;
			coeff *= 64;//*2^6
		}

		if ('delta2' === type)
		{
			var baseSha1 = packBuffer.toString('hex', index, index+20);
			index += 20;
			this.handleDelta2Object(packBuffer, sha1, baseSha1, index, endIndex, callback);
		}
		else if ('delta1' === type ) {
			this.handleDelta1Object(packBuffer, sha1, indexCopy, index, endIndex,callback);
		}
		else //without delta encoding
		{
			zlib.inflate(packBuffer.slice(index, endIndex), function(err, buffer) {
				if (err)
				{
					throw err;
				}
				callback(null, buffer);
			});
		}
};

Pack.prototype.hasObject = function (sha1, callback)
{
	var i = this.packIndex.getObjectIndex(sha1);
	callback(null, i !== -1)
}

Pack.prototype.getObject = function (sha1, callback)
{
	var dir = ph.join(this.repoPath, 'objects/pack');
	var file = 'pack-' + this.sha1 + '.pack';
	var path = ph.join(dir, file);
	var pack = this;
	
	fs.readFile(path, function (err, packBuffer) {
		if (err)
		{
			callback(err, null);
		}
		else {
			var index = 0;
			var signature = packBuffer.toString('utf-8', index, index+4);// 'PACK'
			index += 4;
			var gitVersion = packBuffer.readUInt32BE(index); //we accept only 2
			index += 4;
			var objectsCount = packBuffer.readUInt32BE(index);//=== pack.packIndex.objectsCount
			index += 4;
			
			var checksum = packBuffer.toString('hex', packBuffer.length-20, packBuffer.length);
						//checksum of packBuffer.slice(0, packBuffer.length-20)

			var i = pack.packIndex.getObjectIndex(sha1);
			index = pack.packIndex.getOffset(i);
			var lastIndex = pack.packIndex.getLastByteIndex(index);
			pack.parseObject(sha1, packBuffer, index, lastIndex, callback);
		}
	});
}

function Pack(sha1, repoPath, packIndex)
{
	this.sha1 = sha1;
	this.packIndex = packIndex;
	this.repoPath = repoPath;
}

//callback - function(err, pack)
function readFileToPack(sha1, repoPath, callback) {
	packIndex.readPackIndex(sha1, repoPath, function (err, packIndex) {
		if (err)
		{
			callback(err, null);
		}
		else {
			var pack = new Pack(sha1, repoPath, packIndex);
			callback(null, pack);
		}
	});
}

exports.readFileToPack = readFileToPack;