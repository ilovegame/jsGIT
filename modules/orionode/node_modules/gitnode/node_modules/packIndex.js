var fs = require('fs');
var ph = require('path');
//TODO save to file

var IS_O64 = 1 << 31;
/**
 * Produces PackIndex object
 * @fanout, objects, crc32, offset32, offset64 - arrays
 * @objectsCount - number of objects in packfile
 */
function PackIndex(fanout, objectsCount, objects, crc32, offset32, offset64)
{
	this.fanout = fanout;
	this.objectsCount = objectsCount;
	this.objects = objects;
	this.crc32 = crc32;
	this.offset32 = offset32;
	this.offset64 = offset64;
}


PackIndex.prototype.getObjectIndex = function (sha1)
{
	var i = 0;
	var isFound = false;
	while(!isFound && i < this.objectsCount)
	{
		if (this.objects[i] !== sha1)
		{
			++i;
		}
		else
		{
			isFound = true;
		}
	}
	
	if (!isFound)
	{
		return -1;
	}
	return i;
}


/**
 * Parses pack index, calls callback with created PackIndex object
 * @buffer - buffer with pack index file content
 * @callback - function (err, packIndex)
 */
function parsePackIndex(buffer, callback)
{
	var index = 0;
	var dummy = buffer.readUInt32BE(index);
	index += 4;
	if (dummy !== parseInt('0xff744f63', 16))
	{
		throw 'invalid first byte';
	}
	
	var gitVersion = buffer.readUInt32BE(index);
	index += 4;
	if (gitVersion !== 2)
	{
		throw 'git version different from 2'
	}
	
	var fanout = new Array(256);
	for (var i = 0; i < fanout.length; ++i)
	{
		fanout[i] = buffer.readUInt32BE(index);
		index += 4;
	}

	var objectsCount = fanout[fanout.length - 1];

	var objects = new Array(objectsCount);
	for (var i = 0; i < objectsCount; ++i)
	{
		objects[i] = buffer.toString('hex', index, index+20);
		index += 20;
	}
	
	var crc32 = new Array(objectsCount);
	for (var i = 0; i < objectsCount; ++i)
	{
		crc32[i] = buffer.toString('hex', index, index+4);
		index += 4;
	}

	var offset64count = 0;
	var offset32 = new Array(objectsCount);
	for (var i = 0; i < objectsCount; ++i)
	{
		offset32[i] = buffer.readUInt32BE(index);
		//check if the most significant bit is set
		if (buffer[index] & 128)
		{
			offset64count++;
		}
		index += 4;
	}
	console.log(offset32);
	if (offset64count > 0) {
		offset64 = buffer.slice(index, index + 8*offset64count);
	} else {
		offset64 = null;
	}

	var checksum = buffer.toString('hex', buffer.length-20, buffer.length);
	var packIdx = new PackIndex(fanout, objectsCount, objects, crc32, offset32, offset64);
	callback(null, packIdx);
}

PackIndex.prototype.getOffset = function (index)
{
	if (this.offset32[index] & IS_O64)
	{
		var offset64Index = this.offset32[index] & (~IS_O64);
		var firstByte = offset64.readUInt32BE(offset64Index);
		offset64 += 4;
		var secondByte = offset64.readUInt32BE(offset64Index);
		var offset = 128*firstByte + secondByte;
	}
	else 
	{	
 		return this.offset32[index];
	}
}

PackIndex.prototype.getLastByteIndex = function (index, size)
{
	//there are no two equal values in offsets
	var firstGreater = index + 1;
	var i = 0;
	var isFound = false;
	while (i < this.objectsCount)
	{
		var offset = this.getOffset(i);
		if ( index < offset && (firstGreater > offset || !isFound ))
		{
			firstGreater = offset;
			isFound = true;
		}
		++i;
	}

	if (!isFound)
	{
		//return packBuffer.length - 20;
		return size - 20;
	}
	else 
	{
		return firstGreater;
	}
	
}

/**
 * Reads pack index file and produces PackIndex object
 * @sha1 - checksum of pack
 * @repoPath - path of .git dir
 * @callback - function (err, packIndex)
 */
function readPackIndex(sha1, repoPath, callback)
{
	var dir = ph.join(repoPath, 'objects/pack');
	var file = 'pack-' + sha1 + '.idx';
	var path = ph.join(dir, file);
	
	fs.readFile(path, function (err, content) {
		if (err)
		{
			callback(err, null);
		}
		else {
			try {
				parsePackIndex(content, callback);
			}
			catch (err)
			{
				callback(err, null);
			}
		}
	});
}

exports.readPackIndex = readPackIndex; 