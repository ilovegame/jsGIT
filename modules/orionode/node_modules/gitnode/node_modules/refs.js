/*******************************************************************************
 * Module for managing refs directory in git repositiry
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var packedRefs = require('packedRefs');
var tag = require('tag');

/**
 * Constructor for Refs object
 * @param path path to .git folder
 * @param callback callback(err)
 */
function Refs(path, callback) {
    this.path = path;
    var refsObject = this;
    this.packedRefsManager = new packedRefs.PackedRefs(this.path,
        function(err) {
        if (err) {
            callback(err);
            return;
        }
        callback('');
        return;
        /*fs.mkdir(refsObject.path + '/refs', 0777, function (err) {
            if (err) {
                callback(err);
                return;
            }
            fs.mkdir(refsObject.path + '/refs/heads', 0777, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                fs.mkdir(refsObject.path + '/refs/tags', 0777, function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
            });
        });*/
    });   
}

/**
 * Creates branch
 * @param name name of the branch
 * @param SHA_1 value connected with branch
 * @param callback callback(err)
 */
Refs.prototype.createBranch = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function(exists) {
        if (exists) {
            callback('fatal: branch \'' + name + '\' already exists');
            return;
        } else {
            fs.writeFile(refsObject.path + '/refs/heads/' + name, SHA_1,
                function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                callback('');
                return;
            });
        }
    });
}

/**
 * Updates branch when branch exists and only SHA_1 is changing
 * @param name name of the branch
 * @param SHA_1 new SHA_1
 * @param callback callback(err)
 */
Refs.prototype.updateBranch = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function(exists) {
        if (!exists) {
            refsObject.packedRefsManager.updateBranch(name, SHA_1,
                function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        } else {
            fs.writeFile(refsObject.path + '/refs/heads/' + name, SHA_1,
                function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                callback('');
                return;
            });
        }
    });
}

/**
 * Makes new name for existing branch
 * @param nameOld current name of the branch
 * @param nameNew new name
 * @param callback callback(err)
 */
Refs.prototype.renameBranch = function (nameOld, nameNew, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + nameOld, function (exists) {
        if (exists) {
            fs.rename(refsObject.path + '/refs/heads/' + nameOld,
                refsObject.path + '/refs/heads/' + nameNew, function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
        } else {
            refsObject.packedRefsManager.renameBranch(nameOld, nameNew,
                function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        }
    });
}

/**
 * Removes branch
 * @param name name of the branch
 * @param callback callback(err)
 */
Refs.prototype.removeBranch = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/heads/' + name, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        } else {
            refsObject.packedRefsManager.removeBranch(name, function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        }
    });
}

/**
 * Gets all branches names
 * @param callback callback(err, names)
 */
Refs.prototype.getBranchesNames = function (callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/heads/', function (err, files) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.packedRefsManager.getBranchesNames(function(branches) {
            var branches = files.concat(branches);

            callback('', branches);
            return;
        });
    });
}

/**
 * Reads SHA_1 from .git/HEAD file
 * @param callback callback(err, SHA_1)
 */
Refs.prototype.getSHA_1OfTheActiveBranch = function(callback) {
    var refsObject = this;

    fs.readFile(this.path + '/HEAD', 'utf8', function (err, content) {
        if (err) {
            callback(err, '');
            return;
        }
        var lines = content.split('\n');
        callback('', lines[0]);
        return;
    });
}

/**
 * Uses SHA_1 and gets name of a branch, which has that one SHA_1
 * @param SHA_1 branch's SHA_1 
 * @param callback callback(err, x), where x == '' if there is not branch with
 * given SHA_1 and x is a name if there is a branch 
 */
Refs.prototype.getBranchNameUsingSHA_1 = function(SHA_1, callback) {
    var refsObject = this;
    var filesChecked = 0;
    fs.readdir(this.path + '/refs/heads/', function (err, branchesNames) {
        if (err) {
            callback(err, '');
            return;
        }
        for (index in branchesNames) {
            fs.readFile(refsObject.path + '/refs/heads/' + branchesNames[index],
                'utf8', function(err, content) {
                if (err) {
                    callback(err, '');
                    return;
                }

                if (SHA_1 == content.split('\n')[0]) {
                    callback('', branchesNames[index]);
                    return;
                }
                ++filesChecked;
                if (filesChecked == branchesNames.length) {
                    callback('', '');
                    return;
                }
            });
        }
    });
}

Refs.prototype.getBranchSHA_1UsingName = function(name, callback) {
    var refsObject = this;
    var filesChecked = 0;
    fs.readdir(this.path + '/refs/heads/', function(err, branchesNames) {
        if (err) {
            callback(err, '');
            return;
        }

        for (index in branchesNames) {
            if (branchesNames[index] == name) {
                fs.readFile(refsObject.path + '/refs/heads/' +
                    branchesNames[index], 'utf8', function(err, content) {
                    if (err) {
                        callback(err, '');
                        return;
                    }
                    callback('', content.split('\n')[0]);
                    return;
                });
                return;
            }
            ++filesChecked;
            if (filesChecked == branchesNames.length) {
                callback('', '');
                return;
            }
        }
    });
}

/**
 * Gets the name of active branch
 * @param callback callback(err, name)
 */ 
Refs.prototype.getActiveBranchName = function(callback) {
    var refsObject = this;

    refsObject.getSHA_1OfTheActiveBranch(function(err, activeBranchSHA_1) {
        if (err) {
            callback(err, '');
            return;
        }
        if (activeBranchSHA_1.split(' ')[0] == 'ref:') {
            var parts = activeBranchSHA_1.split('/');
            callback('', parts[parts.length - 1]);
            return;
        }
        refsObject.getBranchNameUsingSHA_1(activeBranchSHA_1, function(name) {
            if (name == '') {
                refsObject.packedRefsManager.getBranchNameUsingSHA_1(
                    activeBranchSHA_1, function(name) {
                    callback('', name);
                    return;
                });
            } else {
                callback('', name);
                return;
            }
        });
    });
}

/**
 * Gets all branches names and next to each of them marks if this one
 * is active one
 * @param callback callback(err, structure)
 */
Refs.prototype.getBranchesNamesWithActiveMarks = function (callback) {
    var refsObject = this;
    this.getActiveBranchName(function(err, activeBranchName) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.getBranchesNames(function(err, branchesNames){
            if (err) {
                callback(err, '');
                return;
            }
            var returnStructure = new Array();
            for (var index in branchesNames) {
                var branchStructure = new Array();
                if (branchesNames[index] == activeBranchName) {
                    branchStructure['active'] = true;
                } else {
                    branchStructure['active'] = false;
                }
                returnStructure[branchesNames[index]] = branchStructure;
            }
            callback('', returnStructure);
            return;
        });
    });
    
}

/**
 * Creates tag
 * @param name name of the tag
 * @param SHA_1 value connected with branch
 * @param callback callback(err)
 */
Refs.prototype.createTag = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            callback('fatal: tag \'' + name + '\' already exists');
            return;
        } else {
            fs.writeFile(refsObject.path + '/refs/tags/' + name, SHA_1,
                function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                callback('');
                return;
            });
        }
    });
}

/**
 * Updates tag when tag exists and only SHA_1 is changing
 * @param name name of the tag
 * @param SHA_1 new SHA_1
 * @param callback callback(err)
 */
Refs.prototype.updateTag = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (!exists) {
            refsObject.packedRefsManager.updateTag(name, SHA_1, function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        } else {
            fs.writeFile(refsObject.path + '/refs/tags/' + name, SHA_1,
                function (err) {
                if (err) {
                    callback(err);
                    return;
                }

                callback('');
                return;
            });
        }
    });
}

/**
 * Makes new name for existing tag
 * @param nameOld current name of the tag
 * @param nameNew new name
 * @param callback callback(err)
 */
Refs.prototype.renameTag = function (nameOld, nameNew, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + nameOld, function (exists) {
        if (exists) {
            fs.rename(refsObject.path + '/refs/tags/' + nameOld,
                refsObject.path + '/refs/tags/' + nameNew, function (err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
        } else {
            refsObject.packedRefsManager.renameTag(nameOld, nameNew,
                function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        }
    });
}

/**
 * Removes tag
 * @param name name of the tag
 * @param callback callback(err)
 */
Refs.prototype.removeTag = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/tags/' + name, function (err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        } else {
            refsObject.packedRefsManager.removeTag(name, function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        }
    });
}

/**
 * Gets all tags names
 * @param callback callback(err, names)
 */
Refs.prototype.getTagsNames = function (callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/tags/', function (err, files) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.packedRefsManager.getTagsNames(function(tags) {
            var tags = files.concat(tags);

            callback('', tags);
            return;
        });
    });
}

/**
 * Adds branches to .git/packed-refs
 * @param branchesNames names of the branches
 * @param index index of the current adding branch
 * @param callback callback(err)
 */
Refs.prototype.addBranchesToPackedRefs = function(branchesNames, index,
    callback) {
    if (index == branchesNames.length) {
        callback('')
        return;
    }
    var refsObject = this;
    fs.readFile(refsObject.path + '/refs/heads/' + branchesNames[index], 'utf8',
        function(err, content) {
        if (err) {
            callback(err);
            return;
        }
        refsObject.packedRefsManager.addBranch(content.split('\n')[0],
            'refs/heads/' + branchesNames[index], function() {
            refsObject.addBranchesToPackedRefs(branchesNames, index + 1,
                function(err) {
                if (err) {
                    callback(err);
                    return;
                }
                callback('');
                return;
            });
        });
    });
}

/**
 * Adds tags to .git/packed-refs
 * @param tagsNames names of the tags
 * @param index index of the current adding tag
 * @param callback callback(err)
 */
Refs.prototype.addTagsToPackedRefs = function(tagsNames, index,
    callback) {
    if (index == tagsNames.length) {
        callback('')
        return;
    }
    var refsObject = this;
    fs.readFile(refsObject.path + '/refs/tags/' + tagsNames[index], 'utf8',
        function(err, content) {
        if (err) {
            callback(err);
            return;
        }
        var tagSHA_1 = content.split('\n')[0];
        tag.readFileToTag(tagSHA_1, refsObject.path, function(err, tagObject) {
            if (err) {
                callback(err);
                return;
            }
            refsObject.packedRefsManager.addTag(tagSHA_1,
                'refs/tags/' + tagsNames[index], tagObject.objectId,
                function() {
                refsObject.addTagsToPackedRefs(tagsNames, index + 1,
                    function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    callback('');
                    return;
                });
            });
        });
    });
}

/**
 * Packs refs folder to .git/packed-refs file
 * @param callback callback(err)
 */
Refs.prototype.packRefs = function(callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/heads/', function (err, files) {
        if (err) {
            callback(err);
            return;
        }
        refsObject.addBranchesToPackedRefs(files, 0, function(err) {
            if (err) {
                callback(err);
                return;
            }
            fs.readdir(refsObject.path + '/refs/tags/', function (err, files) {
                if (err) {
                    callback(err);
                    return;
                }
                refsObject.addTagsToPackedRefs(files, 0, function(err) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    refsObject.packedRefsManager.saveInFile(function(err) {
                        if (err) {
                            callback(err);
                            return;
                        }

                        callback('');
                        return;
                    });
                });
            });
        });
    });
}

exports.Refs = Refs;