/*******************************************************************************
 * Object for managing refs directory in git repositiry
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var packedRefs = require('packedRefs');

function Refs(path, callback) {
    this.path = path;
    this.packedRefsManager = new packedRefs.PackedRefs(this.path, function() {
        var refsObject = this;
        fs.mkdir(this.path + '/refs', 0777, function () {
            fs.mkdir(refsObject.path + '/refs/heads', 0777, function () {
                fs.mkdir(refsObject.path + '/refs/tags', 0777, function () {
                    callback();
                });
            });
        });
    });   
}

Refs.prototype.createBranch = function (name, SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            throw err;
        }

        callback();
    });
}

Refs.prototype.updateBranch = function (name , SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            throw err;
        }

        callback();
    });
}

Refs.prototype.renameBranch = function (nameOld, nameNew, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + nameOld, function (exists) {
        if (exists) {
            fs.rename(refsObject.path + '/refs/heads/' + nameOld,
                refsObject.path + '/refs/heads/' + nameNew, function () {
                    callback();
                });
        }

        callback('error: branch \'' + nameOld + '\' not found');
    });
}

Refs.prototype.removeBranch = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/heads/' + name, function () {
                callback();
            });
        }

        callback('error: branch \'' + nameOld + '\' not found');
    });
}

Refs.prototype.getBranchesNames = function (callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/heads/', function (err, files) {
        refsObject.packedRefsManager.getBranchesNames(function(branches) {
            var branches = files.concat(branches);

            callback(branches);
        });
    });
}

Refs.prototype.createTag = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            callback('fatal: tag \'' + name + '\'already exists');
        }
        fs.writeFile(refsObject.path + '/refs/tags/' + name, SHA_1,
            function (err) {
                if (err) {
                    throw err;
                }

                callback();
            });
    });
}

Refs.prototype.removeTag = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/tags/' + name, function () {
                callback();
            });
        }
        
        callback('error: tag \'' + nameOld + '\' not found');
    });
}

Refs.prototype.getTagsNames = function (callback) {
    fs.readdir(this.path + '/refs/tags/', function (err, files) {
        callback(files);
    });
}

Refs.prototype.packBranches = function(callback) {
    this.packedRefsManager.saveInFile(function() {
        callback();
    });
}

exports.Refs = Refs;