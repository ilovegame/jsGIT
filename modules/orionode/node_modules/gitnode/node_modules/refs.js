/*******************************************************************************
 * Object for managing refs directory in git repositiry
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var packedRefs = require('packedRefs');

function Refs(path, callback) {
    this.path = path;
    this.packedRefsManager = new packedRefs.PackedRefs(this.path, function() {
        var refsObject = this;
        fs.mkdir(this.path + '/refs', 0777, function () {
            fs.mkdir(refsObject.path + '/refs/heads', 0777, function () {
                fs.mkdir(refsObject.path + '/refs/tags', 0777, function () {
                    callback();
                });
            });
        });
    });   
}

Refs.prototype.createBranch = function (name, SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            throw err;
        }

        callback();
    });
}

Refs.prototype.updateBranch = function (name , SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            throw err;
        }

        callback();
    });
}

Refs.prototype.renameBranch = function (nameOld, nameNew, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + nameOld, function (exists) {
        if (exists) {
            fs.rename(refsObject.path + '/refs/heads/' + nameOld,
                refsObject.path + '/refs/heads/' + nameNew, function () {
                    callback();
                });
        }

        callback('error: branch \'' + nameOld + '\' not found');
    });
}

Refs.prototype.removeBranch = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/heads/' + name, function () {
                callback();
                return;
            });
        }

        callback('error: branch \'' + name + '\' not found');
    });
}

Refs.prototype.getBranchesNames = function (callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/heads/', function (err, files) {
        refsObject.packedRefsManager.getBranchesNames(function(branches) {
            var branches = files.concat(branches);

            callback(branches);
        });
    });
}

Refs.prototype.getSHA_1OfTheActiveBranch = function(callback) {
    var refsObject = this;

    fs.readFile(this.path + '/HEAD', 'utf8', function (err, content) {
        if (err) {
            throw err;
        }
        var lines = content.split('\n');
        callback(lines[0]);
    });
}

Refs.prototype.getBranchNameUsingSHA_1 = function(SHA_1, callback) {
    var refsObject = this;
    var filesChecked = 0;
    fs.readdir(this.path + '/refs/heads/', function (err, branchesNames) {
        if (err) {
            throw err;
        }
        for (index in branchesNames) {
            //console.log(refsObject.path + '/refs/heads' + branchesNames[index]);
            fs.readFile(refsObject.path + '/refs/heads/' + branchesNames[index], 'utf8', function(err, content) {
                if (err) {
                    throw err;
                }

                if (SHA_1 == content.split('\n')[0]) {
                    callback(branchesNames[index]);
                    return;
                }
                ++filesChecked;
                if (filesChecked == branchesNames.length) {
                    callback('');
                    return;
                }
            });
        }
    });
}

Refs.prototype.getActiveBranchName = function(callback) {
    var refsObject = this;

    refsObject.getSHA_1OfTheActiveBranch(function(activeBranchSHA_1) {
        refsObject.getBranchNameUsingSHA_1(activeBranchSHA_1, function(name) {
            if (name == '') {
                refsObject.packedRefsManager.getBranchNameUsingSHA_1(activeBranchSHA_1, function(name) {
                    callback(name);
                });
            } else {
                callback(name);
            }
        });
    });
}

Refs.prototype.getBranchesNamesWithActiveMarks = function (callback) {
    var refsObject = this;
    this.getActiveBranchName(function(activeBranchName) {
        refsObject.getBranchesNames(function(branchesNames){
            var returnStructure = new Array();
            for (var index in branchesNames) {
                var branchStructure = new Array();
                if (branchesNames[index] == activeBranchName) {
                    branchStructure['active'] = true;
                } else {
                    branchStructure['active'] = false;
                }
                returnStructure[branchesNames[index]] = branchStructure;
            }
            callback(returnStructure);
        });
    });
    
}

Refs.prototype.createTag = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            callback('fatal: tag \'' + name + '\'already exists');
        }
        fs.writeFile(refsObject.path + '/refs/tags/' + name, SHA_1,
            function (err) {
                if (err) {
                    throw err;
                }

                callback();
            });
    });
}

Refs.prototype.removeTag = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/tags/' + name, function () {
                callback();
            });
        }
        
        callback('error: tag \'' + nameOld + '\' not found');
    });
}

Refs.prototype.getTagsNames = function (callback) {
    fs.readdir(this.path + '/refs/tags/', function (err, files) {
        callback(files);
    });
}

Refs.prototype.packBranches = function(callback) {
    this.packedRefsManager.saveInFile(function() {
        callback();
    });
}

exports.Refs = Refs;