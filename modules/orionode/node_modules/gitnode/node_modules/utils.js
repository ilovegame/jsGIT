var co = require('crypto');
var ph = require('path');
var zlib = require('zlib')
var fs = require('fs');

/**
 * "Convienience method" for deflate with easy access to compresion options.
 * @param data 
 * @param calback function(err, deflatedData)
 * @param options optional, default level set to 1
 */
var deflateOpts = function(data, callback, options)
{
    //set default options for 1
    options = options || {};
    options.level = options.level || 1;
    // create a new deflate object
    var deflate = zlib.createDeflate(options); 
    var buffers=[];
       
    // attach event handlers...
    deflate.on('error', function(err) {
        callback(err);
        deflate.removeAllListeners();
        deflate=null;
    });

    deflate.on('data', function(chunk) {
        buffers.push(chunk);
    });

    deflate.on('end', function() {
        var endBuffer = Buffer.concat(buffers);
        deflate.removeAllListeners();
        deflate=null;

        // return the buffer to callback
        callback(undefined, endBuffer);
    });

    // pass the data
    deflate.write(data);
    deflate.end();
}


/**
 * "Convienience method" for deflate with easy access to compresion options.
 * Deflate and save to file at once.
 * @param data
 * @param filePath
 * @param options optional, default level set to 1
 * @param callback optional, called after end of saving data
 */
var deflateOptsToFile = function(data, filePath, options, callback)
{
    callback = callback || function(){};
    options = options || {};
    options.level = options.level || 1;
    var fileStream = fs.createWriteStream(filePath);
    var deflate = zlib.createDeflate(options); 
    //pipe data from deflate (readStream) to fileStream (writeStream);
    deflate.on('end', function(){
       callback(); 
    });
    deflate.pipe(fileStream);
    //send the data
    deflate.write(data);
    deflate.end();
}

/**
 * Calculate sha1 sum of data
 * @param data
 * @return sha1(data)
 */
var getSha1 = function(data)
{
    var shasum = co.createHash('sha1');
    shasum.update(data);
    return shasum.digest('hex');
}

/**
 * Check if object with sha1 hash is new object and if so create new file for it
 * @param sha1 hash of object
 * @param repoPath path to .git
 * @param callback function(err, boolean) gets true if object was new and file
 * was created, otherwise false
 */
var checkSha1Path = function(sha1, repoPath, callback)
{
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    fs.exists(dir, function(dirExists){
        if(dirExists)
        {
            fs.exists(file, function(fileExists){
                if(fileExists)
                {
                    callback(undefined, false);
                }
                else
                {
                    fs.open(file, 'w', function(err, fd){
                        fs.close(fd, function(err){
                            callback(err, true);
                        });
                    });
                }
            });
        }
        else
        {
            //isn't mode necessary?
            fs.mkdir(dir, function(err){
                if(err) callback(err);
                fs.open(file, 'w', function(err, fd){
                    fs.close(fd, function(err){
                        callback(err, true);
                    });
                });
            })
        }
    });
}


/**
 * Create path to git object
 * @param sha1 hash code of git object
 * @param repoPath path to .git (repo)
 * @return repoPath/sha1[0..1]/sha1[2..]/
 */
var getFilePath = function(sha1, repoPath){
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    return file;
}


/**
 * Produce buffer with uncompressed object contents
 * @param sha1 hash of object
 * @param repoPath
 * @param callback function(err, object)
 */
var readObject = function(sha1, repoPath, callback)
{
    fs.readFile(getFilePath(sha1, repoPath), function (err, data) {
        if(err) callback(err);
        else {
            zlib.inflate(data, function(err, buffer) {
                callback(err, buffer); 
            });
        }
    });
}

/**
 * Produce buffer with uncompressed object contents
 * @param sha1 hash of object
 * @param repoPath
 * @param callback function(err, object, type)
 */
var readObjectAndType = function(sha1, repoPath, callback)
{
    fs.readFile(getFilePath(sha1, repoPath), function (err, data) {
        if(err) callback(err);
        zlib.inflate(data, function(err, buffer) {
            var i = 0;
            while(buffer[i] != " ")
            {
                i++;
            }
            var type = buffer.slice(i+1);
            callback(err, fileBuffer, type); 
        });
    });
}


/**
 * Creates blob from buffer and stores it in repo
 * http://stackoverflow.com/questions/9392365/how-would-git-handle-a-sha-1-collision-on-a-blob
 * @param data Buffer with uncompressed object data
 * @param repoPath path to .git folder f.e. /my_project/.git/
 * @param options optional zlib compression options
 * @param callback optional callback(err) fired after end of operation
 */
var saveObject = function(data, repoPath, options, callback)
{
	console.log("saveobject");
    options = options || {};
    callback = callback || function(){};
    var sha1 = getSha1(data);
    checkSha1Path(sha1, repoPath, function(err, fileIsUnique){
        if(err) callback(err);
        //skip if there is sha1 collision - Linus approves
        else if(fileIsUnique)
        {
            deflateOptsToFile(data, getFilePath(sha1, repoPath), options, callback);
        } else {
            callback(null);   
        }
    });
}


/**
 * Read object from repo, inflate it and parse with parsingFunction
 * @param sha1 hash of object
 * @param repoPath
 * @param parsingFunction - function(data, callback) used for parsing 
 * @param callback function(err, object) - fuction passed to parsing function
 */
var readAndParse = function(sha1, repoPath, parsingFunction, callback)
{
    readObject(sha1, repoPath, function(err, data){
        if(err) callback(err);
        else parsingFunction(data, callback);
    });
    
}


function getSha1OfFile(path, callback)
{
    fs.readFile(path, function(err, data) {
        if(!err) {
            callback(err, getSha1(data));
        } else {
            callback(err);
        }
    });
        
}

function splitByFirst(string, separator)
{
	var i = string.indexOf(separator);
	var n = separator.length;
	return [string.slice(0,i), string.slice(i+n)];
}

function store(gitObject, path) 
{
    var data = gitObject.toFile();
    deflateOptsToFile(data, path, null);
}

function sha1Store (gitObject, repoPath) 
{
	var data = gitObject.toFile();
	var sha1 = getSha1(data);
	var path = getFilePath(sha1, repoPath);
	
	checkSha1Path(sha1, repoPath, function (err, boolean) {	
		if (err) {
			throw 'error';
		}
		else
		{
			deflateOptsToFile(data, path, null);
		}
	});
}



function parseOperationDetails(line)
//line format: author <mail> timeZone timestamp
{
	var words = line.split(' ');
	var timestamp = words[words.length - 1];
	var timeZone = words[words.length - 2];
	var mail = words[words.length - 3]; //<mail>
	mail = mail.substring(1, mail.length-1);//mail

	var author = '';
	for (var i = 0; i < words.length-3; ++i)
	{
		if (i > 0)
		{
			author += ' ';
		}
		author += words[i];
	}
	return new OperationDetails(author, mail, timestamp, timeZone);
}

function OperationDetails(author, authorMail, timestamp, timeZone)
{
	this.author = author;
	this.authorMail = authorMail;
	this.timestamp = timestamp;
	this.timeZone = timeZone;
}

OperationDetails.prototype.toString = function() {
	return this.author + ' <' + this.authorMail + '> ' + this.timeZone + ' ' + this.timestamp;
};


/**
 * Convert buffer containing 20 byte sha1 to 40 byte hex representation
 * @param buffer 20byte sha1
 * @return string hex sha1 representation
 */
var convertDigestToHex = function(buffer) {
    var dict = {10: 'a', 11 : 'b', 12 : 'c' , 13 : 'd', 14 : 'e', 15 : 'f'};
    var res = '';
    for(var i = 0; i <= 9; ++i) dict[i] = i.toString();
    for(var i = 0 ; i < buffer.length; ++i) {
        res = res + (dict[Math.floor(buffer[i]/16)]);
        res = res + (dict[buffer[i] % 16]);
    }
    return res;
}

/**
 * Convert sha1 40 byte hex string to 20 byte sha1 buffer
 * @param string hex sha1 representation
 * @return buffer 20byte sha1
 */
var convertHexToDigest = function(sha1) {
    var dict = {10: 'a', 11 : 'b', 12 : 'c' , 13 : 'd', 14 : 'e', 15 : 'f'};
    for(var i = 0; i <= 9; ++i) dict[i] = i.toString();
    var dictRev = {}
    for (var v in dict)
        if(dict.hasOwnProperty(v))
            dictRev[dict[v]] = v;
    var resBuf = new Buffer(20);
    for(var i = 0; i < 20; ++i) {
        var value1 = parseInt(dictRev[sha1[2*i]]*16);
        var value2 = parseInt(dictRev[sha1[2*i+1]]);
        resBuf[i] = value1 + value2;
    }
    return resBuf;
}


exports.convertDigestToHex = convertDigestToHex;
exports.convertHexToDigest = convertHexToDigest;
exports.checkSha1Path = checkSha1Path;
exports.deflateOpts = deflateOpts;
exports.deflateOptsToFile = deflateOptsToFile;
exports.readObject = readObject;
exports.readAndParse = readAndParse;
exports.saveObject = saveObject;
exports.getSha1OfFile = getSha1OfFile;
exports.OperationDetails = OperationDetails;
exports.parseOperationDetails = parseOperationDetails;

exports.getSha1 = getSha1;
exports.splitByFirst = splitByFirst;
exports.store = store;
exports.sha1Store = sha1Store;
