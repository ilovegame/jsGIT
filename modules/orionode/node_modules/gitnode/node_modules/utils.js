var co = require('crypto');
var ph = require('path');
var zlib = require('zlib')
/**
 * "Convienience method" for deflate with easy access to compresion options.
 * @param data 
 * @param calback function(err, deflatedData)
 * @param options optional, default level set to 1
 */
var deflateOpts = function(data, callback, options)
{
    //set default options for 1
    options = options || {};
    options.level = options.level || 1;
    // create a new deflate object
    var deflate = zlib.createDeflate(options); 
    var buffers=[];
       
    // attach event handlers...
    deflate.on('error', function(err) {
        callback(err);
        deflate.removeAllListeners();
        deflate=null;
    });

    deflate.on('data', function(chunk) {
        buffers.push(chunk);
    });

    deflate.on('end', function() {
        var endBuffer = Buffer.concat(buffers);
        deflate.removeAllListeners();
        deflate=null;

        // return the buffer to callback
        callback(undefined, endBuffer);
    });

    // pass the data
    deflate.write(data);
    deflate.end();
}


/**
 * "Convienience method" for deflate with easy access to compresion options.
 * Deflate and save to file at once.
 * @param data
 * @param filePath
 * @param options optional, default level set to 1
 * @param callback optional, called after end of saving data
 */
var deflateOptsToFile = function(data, filePath, options, callback)
{
    callback = callback || function(){};
    options = options || {};
    options.level = options.level || 1;
    var fileStream = fs.createWriteStream(filePath);
    var deflate = zlib.createDeflate(options); 
    //pipe data from deflate (readStream) to fileStream (writeStream);
    deflate.on('end', function(){
       callback(); 
    });
    deflate.pipe(fileStream);
    //send the data
    deflate.write(data);
    deflate.end();
}



function getSha1(data)
{
    var shasum = co.createHash('sha1');
    shasum.update(data);
    return shasum.digest('hex');
}

/**
 * Check if object with sha1 hash is new object and if so create new file for it
 * @param sha1 hash of object
 * @param repoPath path to .git
 * @param callback function(err, boolean) gets true if object was new and file
 * was created, otherwise false
 */
var checkSha1Path = function(sha1, repoPath, callback)
{
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    fs.exists(dir, function(dirExists){
        if(dirExists)
        {
            fs.exists(file, function(fileExists){
                if(fileExists)
                {
                    callback(undefined, false);
                }
                else
                {
                    fs.open(file, 'w', function(err, fd){
                        fs.close(fd, function(err){
                            callback(err, true);
                        });
                    });
                }
            });
        }
        else
        {
            //isn't mode necessary?
            fs.mkdir(dir, function(err){
                if(err) callback(err);
                fs.open(file, 'w', function(err, fd){
                    fs.close(fd, function(err){
                        callback(err, true);
                    });
                });
            })
        }
    });
}


/**
 * Create path to git object
 * @param sha1 hash code of git object
 * @param repoPath path to .git (repo)
 * @return repoPath/sha1[0..1]/sha1[2..]/
 */
var getFilePath = function(sha1, repoPath){
    var dir = sha1.slice(0, 2);
    var file = sha1.slice(2);
    var obj = ph.join(repoPath, 'objects');
    dir = ph.join(obj, dir);
    file = ph.join(dir, file);
    return file;
}


/**
 * Produce buffer with uncompressed object contents
 * @param sha1 hash of object
 * @param repoPath
 * @param callback function(err, fileBuffer)
 */
var readObject = function(sha1, repoPath, callback)
{
    fs.readFile(utils.getFilePath(sha1, repoPath), function (err, data) {
        if(err) callback(err);
        zlib.inflate(data, function(err, buffer) {
            var i = 0;
            while(buffer[i] != 0)
            {
                i++;
            }
            var fileBuffer = buffer.slice(i+1);
            callback(err, fileBuffer); 
        });
    });
}


/**
 * Creates blob from buffer and stores it in repo
 * @param data Buffer with uncompressed object data
 * @param repoPath path to .git folder f.e. /my_project/.git/
 * @param options optional zlib compression options
 * @param callback optional callback(err) fired after end of operation
 */
var saveObject = function(data, repoPath, options, callback)
{
    options = options || {};
    callback = callback || function(){};
    var sha1 = getSha1(data);
    checkSha1Path(sha1, repoPath, function(err, fileIsUnique){
        if(err) callback(err);
        if(fileIsUnique)
        {
            deflateOptsToFile(data, getFilePath(sha1, repoPath), options, callback);
        }
    });
}

function splitByFirst(string, separator)
{
	var i = string.indexOf(separator);
	var n = separator.length;
	return [string.slice(0,i), string.slice(i+n)];
}

function store(gitObject, path) 
{
    var data = gitObject.toFile();
    deflateOptsToFile(data, path, null);
}

function sha1Store (gitObject, repoPath) 
{
	var data = gitObject.toFile();
	var sha1 = getSha1(data);
	var path = getFilePath(sha1, repoPath);
	checkSha1Path(sha1, repoPath, function (err, boolean) {	
		if (err) {
			throw 'error';
		}
		else
		{
			deflateOptsToFile(data, path, null);
		}
	});
}



function parseOperationDetails(line)
//line format: author <mail> timeZone timestamp
{
	var words = line.split(' ');
	var timestamp = words[words.length - 1];
	var timeZone = words[words.length - 2];
	var mail = words[words.length - 3]; //<mail>
	mail = mail.substring(1, mail.length-1);//mail

	var author = '';
	for (var i = 0; i < words.length-3; ++i)
	{
		if (i > 0)
		{
			author += ' ';
		}
		author += words[i];
	}
	return new OperationDetails(author, mail, timestamp, timeZone);
}

function OperationDetails(author, authorMail, timestamp, timeZone)
{
	this.author = author;
	this.authorMail = authorMail;
	this.timestamp = timestamp;
	this.timeZone = timeZone;
}

OperationDetails.prototype.toString = function() {
	return this.author + ' <' + this.authorMail + '> ' + this.timeZone + ' ' + this.timestamp;
};

exports.checkSha1Path = checkSha1Path;
exports.deflateOpts = deflateOpts;
exports.deflateOptsToFile = deflateOptsToFile;


exports.OperationDetails = OperationDetails;
exports.parseOperationDetails = parseOperationDetails;

exports.getSha1 = getSha1;
exports.splitByFirst = splitByFirst;
exports.store = store;
exports.sha1Store = sha1Store;